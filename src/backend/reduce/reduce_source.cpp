#include <sstream>
#include "reduce_source.h"

const std::string reduce_source() {
  std::ostringstream s; 
  s
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "load_package \"ineq\";\n"
<< "load_package \"laplace\";\n"
<< "load_package \"numeric\";\n"
<< "load_package \"redlog\"; rlset R;\n"
<< "load_package \"sets\";\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "operator interval;\n"
<< "\n"
<< "operator prev;\n"
<< "\n"
<< "\n"
<< "off nat;\n"
<< "linelength(100000000);\n"
<< "\n"
<< "\n"
<< "on ltrig;\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "irrationalNumberIntervalList__:= {};\n"
<< "optUseApproximateCompare__:= nil;\n"
<< "approxPrecision__:= 30; \n"
<< "intervalPrecision__:= 2; \n"
<< "piInterval__:= interval(3141592/1000000, 3141593/1000000, closed__);\n"
<< "eInterval__:= interval(2718281/1000000, 2718282/1000000, closed__);\n"
<< "\n"
<< "loadedOperator__:={};\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure head(expr_)$\n"
<< "  if(arglength(expr_)=-1) then nil\n"
<< "  else part(expr_, 0);\n"
<< "\n"
<< "\n"
<< "procedure foldLeft(func_, init_, list_)$\n"
<< "  if(list_ = {}) then init_\n"
<< "  else foldLeft(func_, func_(init_, first(list_)), rest(list_));\n"
<< "\n"
<< "\n"
<< "procedure myApply(func_, expr_)$\n"
<< "  part(expr_, 0):= func_;\n"
<< "\n"
<< "\n"
<< "procedure drop(exprs_, idx_)$\n"
<< "  for i:= 1 : length(exprs_) join if(i <> idx_) then {part(exprs_, i)} else {};\n"
<< "\n"
<< "\n"
<< "procedure filter(func, exprs_)$\n"
<< "  for each x in exprs_ join if(func(x)) then {x} else {};\n"
<< "\n"
<< "\n"
<< "procedure filterNot(func, exprs_)$\n"
<< "  for each x in exprs_ join if(func(x)) then {} else {x};\n"
<< "\n"
<< "\n"
<< "procedure getArgsList(expr_)$\n"
<< "  if(arglength(expr_)=-1) then {}\n"
<< "  else for i:=1 : arglength(expr_) collect part(expr_, i);\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure myUniq(expr_)$\n"
<< "begin;\n"
<< "  scalar ans_, copy_;\n"
<< "  ans_:= {};\n"
<< "  copy_:= expr_;\n"
<< "  for i:= 1 : length(copy_) do <<\n"
<< "    ans_:= union(ans_, {part(copy_, i)});\n"
<< "    for j:= i+1 : length(copy_) do <<\n"
<< "      if(part(copy_, i) = part(copy_, j)) then <<\n"
<< "        copy_ := drop(copy_, j);\n"
<< "      >>;\n"
<< "    >>;\n"
<< "  >>;\n"
<< "  return ansWrite(\"myUniq\", ans_);\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure hasMinusHead(expr_)$\n"
<< "  if(arglength(expr_)=-1) then nil\n"
<< "  else if(part(expr_, 1) = -1*expr_) then t\n"
<< "  else nil;\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure rationalise(expr_)$\n"
<< "  ansWrite(\"rationalise\", rationaliseMain(expr_));\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure rationaliseMain(expr_)$\n"
<< "begin;\n"
<< "  scalar head_, denominator_, numerator_, denominatorHead_, denomPlusArgsList_,\n"
<< "         frontTwoElemList_, restElemList_, timesRhs_, conjugate_, \n"
<< "         rationalisedArgsList_, rationalisedExpr_, flag_;\n"
<< "\n"
<< "  if(getArgsList(expr_)={}) then return expr_;\n"
<< "\n"
<< "  head_:= head(expr_);\n"
<< "  if(head_=quotient) then <<\n"
<< "    numerator_:= part(expr_, 1);\n"
<< "    denominator_:= part(expr_, 2);\n"
<< "    \n"
<< "    if(numberp(denominator_)) then return expr_;\n"
<< "\n"
<< "    denominatorHead_:= head(denominator_);\n"
<< "    if((denominatorHead_=plus) or (denominatorHead_=times)) then <<\n"
<< "      denomPlusArgsList_:= if(denominatorHead_=plus) then getArgsList(denominator_)\n"
<< "      else << \n"
<< "        \n"
<< "        if(head(part(denominator_, 2))=plus) then getArgsList(part(denominator_, 2))\n"
<< "        else {part(denominator_, 2)}\n"
<< "      >>;\n"
<< "\n"
<< "      \n"
<< "      if(length(denomPlusArgsList_)>2) then <<\n"
<< "        frontTwoElemList_:= getFrontTwoElemList(denomPlusArgsList_);\n"
<< "        restElemList_:= denomPlusArgsList_ \\ frontTwoElemList_;\n"
<< "        if(denominatorHead_=plus) then <<\n"
<< "          conjugate_:= plus(myApply(plus, frontTwoElemList_), -1*(myApply(plus, restElemList_)));\n"
<< "        >> else <<\n"
<< "          \n"
<< "          timesRhs_:= plus(myApply(plus, frontTwoElemList_), -1*(myApply(plus, restElemList_)));\n"
<< "          conjugate_:= part(denominator_, 1) * timesRhs_;\n"
<< "        >>;\n"
<< "      >> else if(length(denomPlusArgsList_)=2) then <<\n"
<< "        if(denominatorHead_=plus) then <<\n"
<< "          conjugate_:= plus(part(denomPlusArgsList_, 1), -1*part(denomPlusArgsList_, 2));\n"
<< "        >> else <<\n"
<< "          \n"
<< "          timesRhs_:= plus(part(denomPlusArgsList_, 1), -1*part(denomPlusArgsList_, 2));\n"
<< "          conjugate_:= part(denominator_, 1) * timesRhs_;\n"
<< "        >>;\n"
<< "      >> else <<\n"
<< "        \n"
<< "        conjugate_:= -1*first(denomPlusArgsList_);\n"
<< "      >>;\n"
<< "    >> else if(denominatorHead_=difference) then <<\n"
<< "      conjugate_:= difference(part(denominator_, 1), -1*part(denominator_, 2));\n"
<< "    >> else <<\n"
<< "      conjugate_:= -1*denominator_;\n"
<< "    >>;\n"
<< "    \n"
<< "    numerator_:= numerator_ * conjugate_;\n"
<< "    denominator_:= denominator_ * conjugate_;\n"
<< "    rationalisedExpr_:= numerator_ / denominator_;\n"
<< "    flag_:= true;\n"
<< "  >> else if(length(expr_)>1) then <<\n"
<< "    rationalisedArgsList_:= map(rationaliseMain, getArgsList(expr_));\n"
<< "    rationalisedExpr_:= myApply(head_, rationalisedArgsList_);\n"
<< "  >> else <<\n"
<< "    rationalisedExpr_:= expr_;\n"
<< "  >>;\n"
<< "\n"
<< "  if(flag_=true) then rationalisedExpr_:= rationaliseMain(rationalisedExpr_);\n"
<< "\n"
<< "  return rationalisedExpr_;\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "procedure exSub(patternList_, exprs_)$\n"
<< "  if(head(exprs_) = list) then\n"
<< "    map(exSub(patternList_, ~w), exprs_)\n"
<< "  else exSubMain(patternList_, exprs_);\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure exSubMain(patternList_, expr_)$\n"
<< "begin;\n"
<< "  scalar subAppliedExpr_, head_, subAppliedLeft_, subAppliedRight_, \n"
<< "         argCount_, subAppliedExprList_, test_;\n"
<< "\n"
<< "  \n"
<< "  if(arglength(expr_)=-1) then <<\n"
<< "    subAppliedExpr_:= sub(patternList_, expr_);\n"
<< "    return subAppliedExpr_;\n"
<< "  >>;\n"
<< "  \n"
<< "  patternList_:= removeTrueList(patternList_);\n"
<< "  head_:= head(expr_);\n"
<< "\n"
<< "  \n"
<< "  if(isIneqRelop(head_)) then <<\n"
<< "    \n"
<< "    subAppliedLeft_:= exSubMain(patternList_, lhs(expr_));\n"
<< "    subAppliedRight_:= exSubMain(patternList_, rhs(expr_));\n"
<< "    subAppliedExpr_:= myApply(head_, {subAppliedLeft_, subAppliedRight_});\n"
<< "  >> else if(isLogicalOp(head_)) then <<\n"
<< "    \n"
<< "    argCount_:= arglength(expr_);\n"
<< "    subAppliedExprList_:= for i:=1 : argCount_ collect exSubMain(patternList_, part(expr_, i));\n"
<< "    subAppliedExpr_:= myApply(head_, subAppliedExprList_);\n"
<< "\n"
<< "  >> else <<\n"
<< "    \n"
<< "    subAppliedExpr_:= sub(patternList_, expr_);\n"
<< "  >>;\n"
<< "\n"
<< "  return subAppliedExpr_;\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure getSqrtList(expr_, var_, mode_)$\n"
<< "begin;\n"
<< "  scalar head_, argsAnsList_, coefficientList_, exprList_, insideSqrt_;\n"
<< "\n"
<< "  \n"
<< "  if(freeof(expr_, var_) or freeof(expr_, sqrt)) then return {};\n"
<< "\n"
<< "  head_:= head(expr_);\n"
<< "  if(hasMinusHead(expr_)) then <<\n"
<< "    coefficientList_:= {-1*first(getSqrtList(part(expr_, 1), var_, mode_))};\n"
<< "    exprList_:= getSqrtList(part(expr_, 1), var_, mode_);\n"
<< "  >> else if(head_=plus) then <<\n"
<< "    \n"
<< "    argsAnsList_:= for each x in getArgsList(expr_) join getSqrtList(x, var_, mode_);\n"
<< "    coefficientList_:= argsAnsList_;\n"
<< "    exprList_:= argsAnsList_;\n"
<< "  >> else if(head_=times) then <<\n"
<< "    argsAnsList_:= for each x in getArgsList(expr_) join getSqrtList(x, var_, mode_);\n"
<< "    coefficientList_:= {foldLeft(times, 1, argsAnsList_)};\n"
<< "    exprList_:= argsAnsList_;\n"
<< "  >> else if(head_=sqrt) then <<\n"
<< "    insideSqrt_:= part(expr_, 1);\n"
<< "    exprList_:= {insideSqrt_};\n"
<< "\n"
<< "    if(freeof(insideSqrt_, sqrt)) then <<\n"
<< "      \n"
<< "      coefficientList_:= {lcof(insideSqrt_, var_)};\n"
<< "    >> else <<\n"
<< "      \n"
<< "      argsAnsList_:= for each x in getArgsList(insideSqrt_) join getSqrtList(x, var_, mode_);\n"
<< "      coefficientList_:= {first(argsAnsList_)};\n"
<< "      exprList_:= union(exprList_, argsAnsList_);\n"
<< "    >>;\n"
<< "  >> else <<\n"
<< "    coefficientList_:= hogehoge;\n"
<< "    exprList_:= fugafuga;\n"
<< "  >>;\n"
<< "\n"
<< "  if(mode_=COEFF) then return coefficientList_\n"
<< "  else if(mode_=INSIDE) then return exprList_;\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "procedure hasSEqualArbComplex(expr_)$\n"
<< "begin;\n"
<< "  scalar ans_;\n"
<< "  debugWrite(\"hasSEqualArbComplex: \", expr_);\n"
<< "  ans_:= nil;\n"
<< "  for each x in expr_ do\n"
<< "    if(lhs(x) = s and not freeof(rhs(x), arbcomplex)) then ans_:= t;\n"
<< "  return ans_;\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "procedure notHaveSExpr(expr_)$\n"
<< "begin;\n"
<< "  scalar ans_;\n"
<< "  debugWrite(\"notHaveSExpr: \", expr_);\n"
<< "  ans_:= t;\n"
<< "  for each x in expr_ do\n"
<< "    if(lhs(x) = s) then ans_:= nil;\n"
<< "  return ans_;\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure isIneqRelop(expr_)$\n"
<< "  if((expr_=neq) or (expr_=not) or\n"
<< "    (expr_=geq) or (expr_=greaterp) or \n"
<< "    (expr_=leq) or (expr_=lessp)) then t else nil;\n"
<< "\n"
<< "\n"
<< "procedure hasIneqRelop(expr_)$\n"
<< "  if(freeof(expr_, neq) and freeof(expr_, not) and\n"
<< "     freeof(expr_, geq) and freeof(expr_, greaterp) and\n"
<< "     freeof(expr_, leq) and freeof(expr_, lessp)) then nil else t;\n"
<< "\n"
<< "\n"
<< "procedure hasEqual(expr_)$\n"
<< "  if(freeof(expr_, equal)) then nil else t;\n"
<< "\n"
<< "\n"
<< "procedure getReverseRelop(relop_)$\n"
<< "  if(relop_=equal) then equal\n"
<< "  else if(relop_=neq) then neq\n"
<< "  else if(relop_=geq) then leq\n"
<< "  else if(relop_=greaterp) then lessp\n"
<< "  else if(relop_=leq) then geq\n"
<< "  else if(relop_=lessp) then greaterp\n"
<< "  else nil;\n"
<< "\n"
<< "\n"
<< "procedure getInverseRelop(relop_)$\n"
<< "  if(relop_=equal) then neq\n"
<< "  else if(relop_=neq) then equal\n"
<< "  else if(relop_=geq) then lessp\n"
<< "  else if(relop_=greaterp) then leq\n"
<< "  else if(relop_=leq) then greaterp\n"
<< "  else if(relop_=lessp) then geq\n"
<< "  else nil;\n"
<< "\n"
<< "\n"
<< "procedure getReverseCons(cons_)$\n"
<< "begin;\n"
<< "  scalar reverseRelop_, lhs_, rhs_;\n"
<< "\n"
<< "  reverseRelop_:= getReverseRelop(head(cons_));\n"
<< "  lhs_:= lhs(cons_);\n"
<< "  rhs_:= rhs(cons_);\n"
<< "  return reverseRelop_(rhs_, lhs_);\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "procedure getExprCode(cons_)$\n"
<< "begin;\n"
<< "  scalar head_;\n"
<< "\n"
<< "  \n"
<< "  if(arglength(cons_)=-1) then head_:= cons_\n"
<< "  else head_:= head(cons_);\n"
<< "\n"
<< "  if(head_=equal) then return 0\n"
<< "  else if(head_=lessp) then return 1\n"
<< "  else if(head_=greaterp) then return 2\n"
<< "  else if(head_=leq) then return 3\n"
<< "  else if(head_=geq) then return 4\n"
<< "  else return nil;\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure isLogicalOp(expr_)$\n"
<< "  if((expr_=or) or (expr_=and)) then t else nil;\n"
<< "\n"
<< "procedure hasLogicalOp(expr_)$\n"
<< "  if(freeof(expr_, and) and freeof(expr_, or)) then nil else t;\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure isTrigonometricFunc(expr_)$\n"
<< "  if((expr_=sin) or (expr_ = cos) or (expr_ = tan)) then t else nil;\n"
<< "\n"
<< "procedure hasTrigonometricFunc(expr_)$\n"
<< "  if((not freeof(expr_, sin)) or (not freeof(expr_, cos)) or (not freeof(expr_, tan))) then t else nil;\n"
<< "\n"
<< "procedure isInvTrigonometricFunc(expr_)$\n"
<< "  if((expr_=asin) or (expr_=acos) or (expr_=atan)) then t else nil;\n"
<< "\n"
<< "procedure hasInvTrigonometricFunc(expr_)$\n"
<< "  if((not freeof(expr_, asin)) or (not freeof(expr_, acos)) or (not freeof(expr_, atan))) then t else nil;\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure isInterval(expr_)$\n"
<< "  if(arglength(expr_)=-1) then nil\n"
<< "  else if(head(expr_)=interval) then t\n"
<< "  else nil;\n"
<< "\n"
<< "procedure isZeroInterval(expr_)$\n"
<< "  if(expr_=makePointInterval(0)) then t else nil;\n"
<< "\n"
<< "procedure getLb(expr_)$\n"
<< "  if(isInterval(expr_)) then part(expr_, 1)\n"
<< "  else ERROR;\n"
<< "\n"
<< "procedure getUb(expr_)$\n"
<< "  if(isInterval(expr_)) then part(expr_, 2)\n"
<< "  else ERROR;\n"
<< "\n"
<< "procedure getClosure(expr_)$\n"
<< "  if(isInterval(expr_)) then part(expr_, 3)\n"
<< "  else ERROR;\n"
<< "\n"
<< "\n"
<< "procedure isLbOpen(interval_)$\n"
<< "  if(isInterval(interval_)) then\n"
<< "      if(part(interval_, 3) = open__ or part(interval_, 3) = open_closed__) then t\n"
<< "        else nil\n"
<< "    else ERROR;\n"
<< "\n"
<< "procedure isUbOpen(interval_)$\n"
<< "  if(isInterval(interval_)) then\n"
<< "      if(part(interval_, 3) = open__ or part(interval_, 3) = closed_open__) then t\n"
<< "        else nil\n"
<< "    else ERROR;\n"
<< "\n"
<< "procedure setLbOpen(closure_)$\n"
<< "  if(closure_ = closed__) then open_closed\n"
<< "    else if(closure_ = closed_open__) then open__\n"
<< "      else closure_;\n"
<< "\n"
<< "procedure setUbOpen(closure_)$\n"
<< "  if(closure_ = closed__) then closed_open__\n"
<< "    else if(closure_ = open_closed__) then open__\n"
<< "      else closure_;\n"
<< "\n"
<< "procedure setReverseClosure(closure_)$\n"
<< "  if(closure_ = open_closed__) then closed_open__\n"
<< "    else if(closure_ = closed_open__) then open_closed__\n"
<< "      else closure_;\n"
<< "\n"
<< "\n"
<< "procedure timesClosure(closure1_, closure2_)$\n"
<< "begin;\n"
<< "  scalar closure_;\n"
<< "\n"
<< "  closure_:= closed__;\n"
<< "  if(isLbOpen(closure1_) or isLbOpen(closure2_)) then closure_:= setLbOpen(closure_);\n"
<< "  if(isUbOpen(closure1_) or isUbOpen(closure2_)) then closure_:= setUbOpen(closure_);\n"
<< "  return closure_;\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure compareInterval(interval1_, op_, interval2_)$\n"
<< "begin;\n"
<< "  scalar ans_;\n"
<< "  debugWrite(\"in compareInterval\", \" \");\n"
<< "  debugWrite(\"interval1_: \", interval1_);\n"
<< "  debugWrite(\"op_: \", op_);\n"
<< "  debugWrite(\"interval2_: \", interval2_);\n"
<< "\n"
<< "  ans_:=\n"
<< "  if (op_ = geq) then\n"
<< "    if (getLb(interval1_) >= getUb(interval2_)) then t\n"
<< "    else if(getUb(interval1_) = getLb(interval2_) and (isUbOpen(getClosure(interval1_)) or isLbOpen(getClosure(interval2_)))) then nil\n"
<< "    else if(getUb(interval1_) < getLb(interval2_)) then nil\n"
<< "    else unknown\n"
<< "  else if (op_ = greaterp) then\n"
<< "    if (getLb(interval1_) = getUb(interval2_) and (isLbOpen(getClosure(interval1_)) or isUbOpen(getClosure(interval2_)))) then t\n"
<< "    else if(getLb(interval1_) > getUb(interval2_)) then t\n"
<< "    else if(getUb(interval1_) <= getLb(interval2_)) then nil\n"
<< "    else unknown\n"
<< "  else if (op_ = leq) then\n"
<< "    if (getUb(interval1_) <= getLb(interval2_)) then t\n"
<< "    else if(getLb(interval1_) = getUb(interval2_) and (isLbOpen(getClosure(interval1_)) or isUbOpen(getClosure(interval2_)))) then nil\n"
<< "    else if(getLb(interval1_) > getUb(interval2_)) then nil\n"
<< "    else unknown\n"
<< "  else if (op_ = lessp) then\n"
<< "    if (getUb(interval1_) = getLb(interval2_) and (isUbOpen(getClosure(interval1_)) or isLbOpen(getClosure(interval2_)))) then t\n"
<< "    else if(getUb(interval1_) < getLb(interval2_)) then t\n"
<< "    else if(getLb(interval1_) >= getUb(interval2_)) then nil\n"
<< "    else unknown;\n"
<< "\n"
<< "  return ansWrite(\"compareInterval\", ans_);\n"
<< "end;\n"
<< "\n"
<< "procedure plusInterval(interval1_, interval2_)$\n"
<< "  ansWrite(\"plusInterval\", interval(getLb(interval1_)+getLb(interval2_), getUb(interval1_)+getUb(interval2_), \n"
<< "                             timesClosure(getClosure(interval1_), getClosure(interval2_))));\n"
<< "\n"
<< "procedure timesInterval(interval1_, interval2_)$\n"
<< "begin;\n"
<< "  scalar closure1_, closure2_, comparedList_,  min_, max_, isLbOpen_, isUbOpen_, closure_;\n"
<< "\n"
<< "  closure1_:= getClosure(interval1_); closure2_:= getClosure(interval2_);\n"
<< "  comparedList_:= {{getLb(interval1_) * getLb(interval2_), (if(isLbOpen(closure1_) or isLbOpen(closure2_)) then t else nil)}, \n"
<< "                  {getLb(interval1_) * getUb(interval2_), (if(isLbOpen(closure1_) or isUbOpen(closure2_)) then t else nil)},\n"
<< "                  {getUb(interval1_) * getLb(interval2_), (if(isUbOpen(closure1_) or isLbOpen(closure2_)) then t else nil)},\n"
<< "                  {getUb(interval1_) * getUb(interval2_), (if(isUbOpen(closure1_) or isUbOpen(closure2_)) then t else nil)}};\n"
<< "\n"
<< "  min_:= INFINITY; max_:= -INFINITY;\n"
<< "  isLbOpen_:= t; isUbOpen_:= t;\n"
<< "\n"
<< "  for each x in comparedList_ do <<\n"
<< "    if(min_ = first(x)) then <<\n"
<< "      if(not isLbOpen_ or not second(x)) then isLbOpen_:= nil;\n"
<< "    >> else <<\n"
<< "      if(mymin(min_, first(x)) = first(x)) then <<\n"
<< "        min_:= first(x);\n"
<< "        isLbOpen_:= second(x);\n"
<< "      >>\n"
<< "    >>;\n"
<< "\n"
<< "    if(max_ = first(x)) then <<\n"
<< "      if(not isUbOpen_ or not second(x)) then isUbOpen_:= nil;\n"
<< "    >> else <<\n"
<< "      if(mymax(max_, first(x)) = first(x)) then <<\n"
<< "        max_:= first(x);\n"
<< "        isUbOpen_:= second(x);\n"
<< "      >>\n"
<< "    >>;\n"
<< "  >>;\n"
<< "\n"
<< "  closure_:= closed__;\n"
<< "  if(isLbOpen_) then closure_:= setLbOpen(closure_);\n"
<< "  if(isUbOpen_) then closure_:= setUbOpen(closure_);\n"
<< "\n"
<< "  return ansWrite(\"timesInterval\", interval(min_, max_, closure_));\n"
<< "end;\n"
<< "\n"
<< "procedure quotientInterval(interval1_, interval2_)$\n"
<< "  ansWrite(\"quotientInterval\",\n"
<< "           if((getLb(interval2_)=0) or (getUb(interval2_)=0)) then ERROR\n"
<< "             else timesInterval(interval1_, interval(1/getUb(interval2_), 1/getLb(interval2_), setReverseClosure(getClosure(interval2_)))));\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure getSqrtInterval(value_, mode_)$\n"
<< "begin;\n"
<< "  scalar sqrtInterval_, sqrtLb_, sqrtUb_, midPoint_, loopCount_,\n"
<< "         tmpNewtonSol_, newTmpNewtonSol_, iIntervalList_;\n"
<< "\n"
<< "  debugWrite(\"in getSqrtInterval: \", {value_, mode_});\n"
<< "  \n"
<< "  iIntervalList_:= getIrrationalNumberInterval(sqrt(value_));\n"
<< "  if(iIntervalList_ neq {}) then return first(iIntervalList_);\n"
<< "\n"
<< "  if(mode_=BINARY_SEARCH) then <<\n"
<< "    \n"
<< "    sqrtLb_:= 0;\n"
<< "    sqrtUb_:= value_;\n"
<< "    loopCount_:= 1;\n"
<< "    while (sqrtUb_ - sqrtLb_ >= 1/10^intervalPrecision__) do <<\n"
<< "      debugWrite(\"loopCount_: \", loopCount_);\n"
<< "      midPoint_:= (sqrtLb_ + sqrtUb_)/2;\n"
<< "      debugWrite(\"midPoint_: \", midPoint_);\n"
<< "      if(midPoint_ * midPoint_ < value_) then sqrtLb_:= midPoint_\n"
<< "      else sqrtUb_:= sqrtUb_:= midPoint_;\n"
<< "      loopCount_:= loopCount_+1;\n"
<< "    >>;\n"
<< "    sqrtInterval_:= interval(sqrtLb_, sqrtUb_, closed__);\n"
<< "    putIrrationalNumberInterval(sqrt(value_), sqrtInterval_);\n"
<< "  >> else if(mode_=NEWTON) then <<\n"
<< "    \n"
<< "    newTmpNewtonSol_:= value_;\n"
<< "    loopCount_:= 1;\n"
<< "    repeat <<\n"
<< "      tmpNewtonsol_:= newTmpNewtonSol_;\n"
<< "      newTmpNewtonSol_:= 1/2*(tmpNewtonSol_+value_ / tmpNewtonSol_);\n"
<< "      debugWrite(\"{loopCount_, new Newton Sol}: \", {loopCount_, newTmpNewtonSol_});\n"
<< "      loopCount_:= loopCount_+1;\n"
<< "    >> until (tmpNewtonSol_ - newTmpNewtonSol_ < 1/10^intervalPrecision__);\n"
<< "    sqrtLb_:= 2*newTmpNewtonSol_ - tmpNewtonSol_;\n"
<< "    sqrtUb_:= newTmpNewtonSol_;\n"
<< "    sqrtInterval_:= interval(sqrtLb_, sqrtUb_, closed__);\n"
<< "    putIrrationalNumberInterval(sqrt(value_), sqrtInterval_);\n"
<< "  >>;\n"
<< "\n"
<< "  return ansWrite(\"getSqrtInterval\", sqrtInterval_);\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "procedure makePointInterval(value_)$\n"
<< "  interval(value_, value_, closed__);\n"
<< "\n"
<< "\n"
<< "procedure convertValueToInterval(value_)$\n"
<< "begin;\n"
<< "  scalar head_, retInterval_, argsList_, insideSqrt_;\n"
<< "\n"
<< "  debugWrite(\"in convertValueToInterval: \", value_);\n"
<< "\n"
<< "  \n"
<< "  if(numberp(value_)) then <<\n"
<< "    retInterval_:= makePointInterval(value_);\n"
<< "    debugWrite(\"ans in convertValueInterval\", retInterval_);\n"
<< "    return retInterval_;\n"
<< "  >>;\n"
<< "\n"
<< "  if(arglength(value_) neq -1) then <<\n"
<< "    head_:= head(value_);\n"
<< "    debugWrite(\"head_: \", head_);\n"
<< "    if(hasMinusHead(value_)) then <<\n"
<< "      \n"
<< "      retInterval_:= timesInterval(makePointInterval(-1), convertValueToInterval(part(value_, 1)));\n"
<< "    >> else if((head_=plus) or (head_= times)) then <<\n"
<< "      argsList_:= getArgsList(value_);\n"
<< "      debugWrite(\"argsList_: \", argsList_);\n"
<< "      if(head_=plus) then <<\n"
<< "        retInterval_:= makePointInterval(0);\n"
<< "        for each x in argsList_ do\n"
<< "          retInterval_:= plusInterval(convertValueToInterval(x), retInterval_);\n"
<< "      >> else <<\n"
<< "        retInterval_:= makePointInterval(1);\n"
<< "        for each x in argsList_ do\n"
<< "          retInterval_:= timesInterval(convertValueToInterval(x), retInterval_);\n"
<< "      >>;\n"
<< "    >> else if(head_=quotient) then <<\n"
<< "      retInterval_:= quotientInterval(part(value_, 1), part(value_, 2));\n"
<< "    >> else if(head_=expt) then <<\n"
<< "      \n"
<< "      retInterval_:= makePointInterval(1);\n"
<< "      for i:=1 : part(value_, 2) do <<\n"
<< "        retInterval_:= timesInterval(retInterval_, convertValueToInterval(part(value_, 1)));\n"
<< "      >>;\n"
<< "    >> else if(head_=sqrt) then <<\n"
<< "      insideSqrt_:= part(value_, 1);\n"
<< "      retInterval_:= getSqrtInterval(insideSqrt_, NEWTON);\n"
<< "    >> else if(head_=sin) then <<\n"
<< "      retInterval_:= interval(-1, 1, closed__);\n"
<< "    >> else if(head_=cos) then <<\n"
<< "      retInterval_:= interval(-1, 1, closed__);\n"
<< "    >> else if(head_=tan) then <<\n"
<< "      retInterval_:= interval(-1, 1, closed__);\n"
<< "    >> else if(head_=asin) then <<\n"
<< "      \n"
<< "      retInterval_:= interval(getLb(timesInterval(makePointInterval(-1), piInterval__)), getUb(piInterval__), closed__);\n"
<< "    >> else if(head_=acos) then <<\n"
<< "      retInterval_:= interval(getLb(timesInterval(makePointInterval(-1), piInterval__)), getUb(piInterval__), closed__);\n"
<< "    >> else if(head_=atan) then <<\n"
<< "      retInterval_:= interval(getLb(timesInterval(makePointInterval(-1), piInterval__)), getUb(piInterval__), closed__);\n"
<< "    >> else <<\n"
<< "      \n"
<< "      retInterval_:= interval(unknown, unknown, closed__);\n"
<< "    >>;\n"
<< "  >> else <<\n"
<< "    if(value_=pi) then retInterval_:= piInterval__\n"
<< "    else if(value_=e) then retInterval_:= eInterval__\n"
<< "    else if(hasParameter(value_)) then <<\n"
<< "      valueConstraint_:= for each x in pConstraint__ join if(not freeof(x, value_)) then {x} else {};\n"
<< "      debugWrite(\"valueConstraint_: \", valueConstraint_);\n"
<< "      lb_:=-INFINITY ; ub_:= INFINITY;\n"
<< "      isLbOpen_:= nil; isUbOpen:= nil;\n"
<< "      for each x in valueConstraint_ do <<\n"
<< "        op_:= head(x);\n"
<< "        rhs_:= getRhs(x, value_);\n"
<< "        debugWrite(\"{x, op_, rhs}: \", {x, op_, rhs_});\n"
<< "\n"
<< "        if((op_ = geq) or (op_ = greaterp)) then lb_:= getLb(convertValueToInterval(rhs_));\n"
<< "        if((op_ = leq) or (op_ = lessp)) then    ub_:= getLb(convertValueToInterval(rhs_));\n"
<< "\n"
<< "        if(op_ = greaterp) then isLbOpen_:= t;\n"
<< "        if(op_ = lessp) then    isUbOpen_:= t;\n"
<< "      >>;\n"
<< "      if(isLbOpen_) then\n"
<< "          if(isUbOpen_) then closure_:= open__\n"
<< "            else closure_:= open_closed__\n"
<< "        else if(isUbOpen_) then closure_:= closed_open__\n"
<< "          else closure_:= closed__;\n"
<< "\n"
<< "      retInterval_:= interval(lb_, ub_, closure_);\n"
<< "    >> else retInterval_:= interval(unknown, unknown, closed__);\n"
<< "  >>;\n"
<< "\n"
<< "  return ansWrite(\"convertValueToInterval\", retInterval_);\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure getRhs(inequality_, value_)$\n"
<< "begin;\n"
<< "  scalar equality_, ans_;\n"
<< "  equality_:= myApply(equal, inequality_);\n"
<< "  ans_:= rhs first solve(equality_, value_);\n"
<< "  return ansWrite(\"getRhs\", ans_);\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure hasImaginaryNum(value_)$\n"
<< "  if(not freeof(value_, i)) then t else nil;\n"
<< "\n"
<< "procedure hasIndefinableNum(value_)$\n"
<< "begin;\n"
<< "  scalar retFlag_, head_, flagList_, insideInvTrigonometricFunc_;\n"
<< "\n"
<< "  if(arglength(value_)=-1) then <<\n"
<< "    return nil;\n"
<< "  >>;\n"
<< "\n"
<< "  head_:= head(value_);\n"
<< "  if(hasMinusHead(value_)) then <<\n"
<< "    \n"
<< "    retFlag_:= hasIndefinableNum(part(value_, 1));\n"
<< "  >> else if((head_=plus) or (head_=times)) then <<\n"
<< "    flagList_:= union(for each x in getArgsList(value_) join\n"
<< "      if(hasIndefinableNum(x)) then {t} else {});\n"
<< "    retFlag_:= if(flagList_={}) then nil else t;\n"
<< "  >> else if(isInvTrigonometricFunc(head_)) then <<\n"
<< "    insideInvTrigonometricFunc_:= part(value_, 1);\n"
<< "    retFlag_:= if(checkOrderingFormula(insideInvTrigonometricFunc_>=-1) and checkOrderingFormula(insideInvTrigonometricFunc_<=1)) then nil else t;\n"
<< "  >> else <<\n"
<< "    retFlag_:= nil;\n"
<< "  >>;\n"
<< "  return retFlag_;\n"
<< "end;\n"
<< "\n"
<< "procedure putIrrationalNumberInterval(value_, interval_)$\n"
<< "  irrationalNumberIntervalList__:= cons({value_, interval_}, irrationalNumberIntervalList__);\n"
<< "\n"
<< "procedure getIrrationalNumberInterval(value_)$\n"
<< "  for each x in irrationalNumberIntervalList__ join \n"
<< "    if(first(x)=value_) then {second(x)} else {};\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure isEmpty(lst_)$\n"
<< "  if(lst_ = {}) then true else false;\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure hasParameter(expr_)$\n"
<< "  if(collectParameters(expr_) neq {}) then t else nil;\n"
<< "\n"
<< "\n"
<< "procedure collectParameters(expr_)$\n"
<< "begin;\n"
<< "  scalar collectedParameters_;\n"
<< "\n"
<< "  collectedParameters_:= union({}, for each x in parameters__ join if(not freeof(expr_, x)) then {x} else {});\n"
<< "\n"
<< "  return collectedParameters_;\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "checkOrderingFormulaCount__:= 0;\n"
<< "checkOrderingFormulaIrrationalNumberCount_:= 0;\n"
<< "\n"
<< "procedure checkOrderingFormula(orderingFormula_)$\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "begin;\n"
<< "  scalar head_, x, op, y, bak_precision, ans, margin, xInterval_, yInterval_;\n"
<< "\n"
<< "  debugWrite(\"=== in checkOrderingFormula: \", orderingFormula_);\n"
<< "  checkOrderingFormulaCount__:= checkOrderingFormulaCount__+1;\n"
<< "  debugWrite(\"checkOrderingFormulaCount__: \", checkOrderingFormulaCount__);\n"
<< "\n"
<< "  head_:= head(orderingFormula_);\n"
<< "  \n"
<< "  if(hasLogicalOp(head_)) then <<\n"
<< "    return ERROR;\n"
<< "  >>;\n"
<< "\n"
<< "  x:= lhs(orderingFormula_);\n"
<< "  op:= head_;\n"
<< "  y:= rhs(orderingFormula_);\n"
<< "\n"
<< "  debugWrite(\"{x, op, y}: \", {x, op, y});\n"
<< "\n"
<< "  if(x=y) then <<\n"
<< "    ans:= if((op = geq) or (op = leq)) then t else nil;\n"
<< "    return ansWrite(\"checkOrderingFormula\", ans);\n"
<< "  >>;\n"
<< "\n"
<< "  if(not freeof({x,y}, INFINITY)) then <<\n"
<< "    ans:= infinityIf(x, op, y);\n"
<< "    debugWrite(\"ans after infinityIf in checkOrderingFormula: \", ans);\n"
<< "    return ansWrite(\"checkOrderingFormula\", ans);\n"
<< "  >>;\n"
<< "\n"
<< "  if(not numberp(x) or not(numberp(y))) then <<\n"
<< "    checkOrderingFormulaIrrationalNumberCount_:= checkOrderingFormulaIrrationalNumberCount_+1;\n"
<< "    debugWrite(\"checkOrderingFormulaIrrationalNumberCount_: \", checkOrderingFormulaIrrationalNumberCount_);\n"
<< "    \n"
<< "    if(optUseApproximateCompare__) then <<\n"
<< "      \n"
<< "      bak_precision := precision 0;\n"
<< "      on rounded$ precision approxPrecision__$\n"
<< "\n"
<< "      \n"
<< "      \n"
<< "      if(min(x,y)=0) then\n"
<< "        margin:=10 ^ (3 + floor log10 max(x, y) - approxPrecision__)\n"
<< "      else if(min(x,y)>0) then \n"
<< "        margin:=10 ^ (3 + floor log10 min(x, y) - approxPrecision__)\n"
<< "      else\n"
<< "        margin:=10 ^ (3 - floor log10 abs min(x, y) - approxPrecision__);\n"
<< "\n"
<< "      debugWrite(\"{margin, x, y, abs(x-y)}: \", {margin, x, y, abs(x-y)});\n"
<< "      \n"
<< "      if(abs(x-y)<margin) then <<\n"
<< "        off rounded$ precision bak_precision$\n"
<< "        write(-1);\n"
<< "        return ansWrite(\"checkOrderingFormula\", -1);\n"
<< "      >>;\n"
<< "\n"
<< "      if (op = geq) then\n"
<< "        (if (x >= y) then ans:=t else ans:=nil)\n"
<< "      else if (op = greaterp) then\n"
<< "        (if (x > y) then ans:=t else ans:=nil)\n"
<< "      else if (op = leq) then\n"
<< "        (if (x <= y) then ans:=t else ans:=nil)\n"
<< "      else if (op = lessp) then\n"
<< "        (if (x < y) then ans:=t else ans:=nil);\n"
<< "\n"
<< "      off rounded$ precision bak_precision$\n"
<< "    >> else <<\n"
<< "      \n"
<< "      xInterval_:= convertValueToInterval(x);\n"
<< "      yInterval_:= convertValueToInterval(y);\n"
<< "      debugWrite(\"{xInterval_, yInterval_}: \", {xInterval_, yInterval_});\n"
<< "      ans:= compareInterval(xInterval_, op, yInterval_);\n"
<< "    >>;\n"
<< "  >> else <<\n"
<< "    if ((op = geq) or (op = greaterp)) then\n"
<< "      (if (x > y) then ans:=t else ans:=nil)\n"
<< "    else\n"
<< "      (if (x < y) then ans:=t else ans:=nil);\n"
<< "  >>;\n"
<< "\n"
<< "  if(ans=unknown) then <<\n"
<< "    if(not hasParameter(orderingFormula_)) then <<\n"
<< "      \n"
<< "      intervalPrecision__:= intervalPrecision__+4;\n"
<< "      ans:= checkOrderingFormula(orderingFormula_);\n"
<< "      intervalPrecision__:= intervalPrecision__-4;\n"
<< "    >> else ans_:= unknown;\n"
<< "  >>;\n"
<< "\n"
<< "  debugWrite(\"checkOrderingFormula arg:\", orderingFormula_);\n"
<< "\n"
<< "  return ansWrite(\"checkOrderingFormula\", ans);\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "procedure infinityIf(x, op, y)$\n"
<< "begin;\n"
<< "  scalar ans_, infinityTupleDNF_, retTuple_, i_, j_, andAns_;\n"
<< "\n"
<< "  debugWrite(\"in infinityIf\", \"\");\n"
<< "  debugWrite(\"{x, op, y}: \", {x, op, y});\n"
<< "  \n"
<< "  \n"
<< "  if(x=INFINITY or y=-INFINITY) then \n"
<< "    if((op = geq) or (op = greaterp)) then ans_:=t else ans_:=nil\n"
<< "  else if(x=-INFINITY or y=INFINITY) then\n"
<< "    if((op = leq) or (op = lessp)) then ans_:=t else ans_:=nil\n"
<< "  else <<\n"
<< "    \n"
<< "    infinityTupleDNF_:= exIneqSolve(op(x, y));\n"
<< "    debugWrite(\"infinityTupleDNF_: \", infinityTupleDNF_);\n"
<< "    if(isFalseDNF(infinityTupleDNF_)) then return ansWrite(\"checkOrderingFormula\", nil);\n"
<< "    i_:= 1;\n"
<< "    ans_:= nil;\n"
<< "    while (i_<=length(infinityTupleDNF_) and (ans_ neq t)) do <<\n"
<< "      j_:= 1;\n"
<< "      andAns_:= t;\n"
<< "      while (j_<=length(part(infinityTupleDNF_, i_)) and (andAns_ = t)) do <<\n"
<< "        retTuple_:= part(part(infinityTupleDNF_, i_), j_);\n"
<< "        andAns_:= infinityIf(getVarNameFromTuple(retTuple_), getRelopFromTuple(retTuple_), getValueFromTuple(retTuple_));\n"
<< "        j_:= j_+1;\n"
<< "      >>;\n"
<< "      ans_:= andAns_;\n"
<< "      i_:= i_+1;\n"
<< "    >>;\n"
<< "  >>;\n"
<< "\n"
<< "  return ansWrite(\"infinityIf\", ans_);\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "procedure mymin(x,y)$\n"
<< "\n"
<< "begin;\n"
<< "  scalar ans_;\n"
<< "  debugWrite(\"in mymin: \", {x,y});\n"
<< "  ans_:= checkOrderingFormula(x<y);\n"
<< "  ans_:= if(ans_ = t) then x\n"
<< "         else if(ans_ = nil) then y\n"
<< "         else if(ans_ = unknown) then unknown;\n"
<< "  return ansWrite(\"mymin\", ans_);\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "procedure mymax(x,y)$\n"
<< "\n"
<< "begin;\n"
<< "  scalar ans_;\n"
<< "  debugWrite(\"in mymax: \", {x,y});\n"
<< "  ans_:= checkOrderingFormula(x>y);\n"
<< "  ans_:= if(ans_ = t) then x\n"
<< "         else if(ans_ = nil) then y\n"
<< "         else if(ans_ = unknown) then unknown;\n"
<< "  return ansWrite(\"mymax\", ans_);\n"
<< "end;\n"
<< "\n"
<< "procedure findMinimumValue(x,lst)$\n"
<< "\n"
<< "\n"
<< "  if(lst={}) then x\n"
<< "  else if(mymin(x, first(lst)) = x) then findMinimumValue(x,rest(lst))\n"
<< "  else findMinimumValue(first(lst),rest(lst));\n"
<< "\n"
<< "procedure findMaximumValue(x,lst)$\n"
<< "\n"
<< "\n"
<< "  if(lst={}) then x\n"
<< "  else if(mymax(x, first(lst)) = x) then findMaximumValue(x,rest(lst))\n"
<< "  else findMaximumValue(first(lst),rest(lst));\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure getTimeFromTC(TC_)$\n"
<< "  part(TC_, 1);\n"
<< "procedure getCondDNFFromTC(TC_)$\n"
<< "  part(TC_, 2);\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure compareValueAndParameter(val_, paramExpr_, condDNF_)$\n"
<< "\n"
<< "\n"
<< "\n"
<< "begin;\n"
<< "  scalar valueLeqParamCondSol_, valueGreaterParamCondSol_, \n"
<< "         ret_;\n"
<< "\n"
<< "  debugWrite(\"=== in compareValueAndParameter\", \" \");\n"
<< "  debugWrite(\"val_: \", val_);\n"
<< "  debugWrite(\"paramExpr_: \", paramExpr_);\n"
<< "  debugWrite(\"condDNF_: \", condDNF_);\n"
<< "\n"
<< "\n"
<< "  \n"
<< "  valueLeqParamCondSol_:= addCondTupleToCondDNF({val_, leq, paramExpr_}, condDNF_);\n"
<< "  debugWrite(\"valueLeqParamCondSol_: \", valueLeqParamCondSol_);\n"
<< "\n"
<< "  \n"
<< "  valueGreaterParamCondSol_:= addCondTupleToCondDNF({val_, greaterp, paramExpr_}, condDNF_);\n"
<< "  debugWrite(\"valueGreaterParamCondSol_: \", valueGreaterParamCondSol_);\n"
<< "\n"
<< "  return {valueLeqParamCondSol_, valueGreaterParamCondSol_};\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure isLbTuple(tuple_)$\n"
<< "  if((getRelopFromTuple(tuple_)=geq) or (getRelopFromTuple(tuple_)=greaterp)) then t else nil;\n"
<< "\n"
<< "procedure isUbTuple(tuple_)$\n"
<< "  if((getRelopFromTuple(tuple_)=leq) or (getRelopFromTuple(tuple_)=lessp)) then t else nil;\n"
<< "\n"
<< "procedure getLbTupleListFromConj(conj_)$\n"
<< "  for each x in conj_ join if(isLbTuple(x)) then {x} else {};\n"
<< "\n"
<< "procedure getUbTupleListFromConj(conj_)$\n"
<< "  for each x in conj_ join if(isUbTuple(x)) then {x} else {};\n"
<< "\n"
<< "\n"
<< "procedure makeExprFromTuple(tuple_)$\n"
<< "  myApply(getRelopFromTuple(tuple_), {getVarNameFromTuple(tuple_), getValueFromTuple(tuple_)});\n"
<< "\n"
<< "procedure getVarNameFromTuple(tuple_)$\n"
<< "  part(tuple_, 1);\n"
<< "\n"
<< "procedure getRelopFromTuple(tuple_)$\n"
<< "  part(tuple_, 2);\n"
<< "\n"
<< "procedure getValueFromTuple(tuple_)$\n"
<< "  part(tuple_, 3);\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure getNotConjDNF(conj_)$\n"
<< "  map({{getVarNameFromTuple(~term), getInverseRelop(getRelopFromTuple(~term)), getValueFromTuple(~term)}}, conj_);\n"
<< "\n"
<< "\n"
<< "procedure isEqualConj(conj_)$\n"
<< "begin;\n"
<< "  scalar value1_, value2_, relop1_, relop2_;\n"
<< "\n"
<< "  if(length(conj_) neq 2) then return nil;\n"
<< "\n"
<< "  value1_:= getValueFromTuple(first(conj_));\n"
<< "  value2_:= getValueFromTuple(second(conj_));\n"
<< "  if(value1_ neq value2_) then return nil;\n"
<< "\n"
<< "  relop1_:= getRelopFromTuple(first(conj_));\n"
<< "  relop2_:= getRelopFromTuple(second(conj_));\n"
<< "  if(((relop1_=geq) and (relop2_=leq)) or ((relop1_=leq) and (relop2_=geq))) then return t\n"
<< "  else return nil;\n"
<< "end;\n"
<< "\n"
<< "procedure isSameConj(conj1_, conj2_)$\n"
<< "begin;\n"
<< "  scalar flag_;\n"
<< "\n"
<< "  debugWrite(\"in isSameConj\", \" \");\n"
<< "  debugWrite(\"{conj1_, conj2_}: \", {conj1_, conj2_});\n"
<< "\n"
<< "  if(length(conj1_) neq length(conj2_)) then return nil;\n"
<< "\n"
<< "  flag_:= t;\n"
<< "  for each x in conj1_ do \n"
<< "    if(freeof(conj2_, x)) then flag_:= nil;\n"
<< "  return flag_;\n"
<< "end;\n"
<< "\n"
<< "procedure isFalseConj(conj_)$\n"
<< "  if(conj_={}) then t else nil;\n"
<< "\n"
<< "procedure isTrueConj(conj_)$\n"
<< "  if(conj_={true}) then t else nil;\n"
<< "\n"
<< "procedure getNotDNF(DNF_)$\n"
<< "begin;\n"
<< "  scalar retDNF_, i_;\n"
<< "\n"
<< "  debugWrite(\"in getNotDNF\", DNF_);\n"
<< "\n"
<< "  retDNF_:= {{true}};\n"
<< "  i_:= 1;\n"
<< "  while (not isFalseDNF(retDNF_) and i_<=length(DNF_)) do <<\n"
<< "    retDNF_:= addCondDNFToCondDNF(getNotConjDNF(part(DNF_, i_)), retDNF_);\n"
<< "    i_:= i_+1;\n"
<< "  >>;\n"
<< "\n"
<< "  debugWrite(\"ans in getNotDNF: \", retDNF_);\n"
<< "  return retDNF_;\n"
<< "end;\n"
<< "\n"
<< "procedure isSameDNF(DNF1_, DNF2_)$\n"
<< "begin;\n"
<< "  scalar flag_, i_, conj1, flagList_;\n"
<< "\n"
<< "  debugWrite(\"in isSameDNF\", \" \");\n"
<< "  debugWrite(\"{DNF1_, DNF2_}: \", {DNF1_, DNF2_});\n"
<< "\n"
<< "  if(length(DNF1_) neq length(DNF2_)) then return nil;\n"
<< "\n"
<< "  flag_:= t;\n"
<< "  i_:= 1;\n"
<< "  while (flag_=t and i_<=length(DNF1_)) do <<\n"
<< "    conj1:= part(DNF1_, i_);\n"
<< "    flagList_:= for each conj2 in DNF2_ join\n"
<< "      if(isSameConj(conj1, conj2)) then {true} else {};\n"
<< "    if(flagList_={}) then flag_:= nil;\n"
<< "    i_:= i_+1;\n"
<< "  >>;\n"
<< "  return flag_;\n"
<< "end;\n"
<< "\n"
<< "procedure isFalseDNF(DNF_)$\n"
<< "  if(DNF_={{}}) then t else nil;\n"
<< "\n"
<< "procedure isTrueDNF(DNF_)$\n"
<< "  if(DNF_={{true}}) then t else nil;\n"
<< "\n"
<< "\n"
<< "procedure makeTupleDNFFromEq(var_, value_)$\n"
<< "  {{ {var_, geq, value_}, {var_, leq, value_} }};\n"
<< "\n"
<< "procedure makeTupleDNFFromNeq(var_, value_)$\n"
<< "  {{ {var_, lessp, value_}, {var_, greaterp, value_} }};\n"
<< "\n"
<< "\n"
<< "procedure simplifyDNF(DNF_)$\n"
<< "begin;\n"
<< "  scalar tmpRetDNF_, simplifiedDNF_;\n"
<< "\n"
<< "  \n"
<< "  tmpRetDNF_:= {first(DNF_)};\n"
<< "  for i:=1 : length(rest(DNF_)) do <<\n"
<< "    tmpRetDNF_:= if(isSameConj(first(tmpRetDNF_), part(rest(DNF_), i))) then tmpRetDNF_\n"
<< "                 else cons(part(rest(DNF_), i), tmpRetDNF_);\n"
<< "  >>;\n"
<< "  simplifiedDNF_:= tmpRetDNF_;\n"
<< "\n"
<< "  debugWrite(\"ans in simplifyDNF: \", simplifiedDNF_);\n"
<< "  return simplifiedDNF_;\n"
<< "end;\n"
<< "\n"
<< "procedure addCondDNFToCondDNF(newCondDNF_, condDNF_)$\n"
<< "begin;\n"
<< "  scalar addedCondDNF_, tmpAddedCondDNF_, i_;\n"
<< "\n"
<< "  debugWrite(\"=== in addCondDNFToCondDNF\", \" \");\n"
<< "  debugWrite(\"{newCondDNF_, condDNF_}: \", {newCondDNF_, condDNF_});\n"
<< "\n"
<< "  \n"
<< "  if(isFalseDNF(newCondDNF_)) then return {{}};\n"
<< "\n"
<< "  addedCondDNF_:= for each conj in newCondDNF_ join <<\n"
<< "    i_:= 1;\n"
<< "    tmpAddedCondDNF_:= condDNF_;\n"
<< "    while (i_<=length(conj) and not isFalseDNF(tmpAddedCondDNF_)) do <<\n"
<< "      tmpAddedCondDNF_:= addCondTupleToCondDNF(part(conj, i_), tmpAddedCondDNF_);\n"
<< "      i_:= i_+1;\n"
<< "    >>;\n"
<< "    if(not isFalseDNF(tmpAddedCondDNF_)) then simplifyDNF(tmpAddedCondDNF_) else {}\n"
<< "  >>;\n"
<< "\n"
<< "  \n"
<< "  if(addedCondDNF_={})then addedCondDNF_:= {{}};\n"
<< "\n"
<< "  debugWrite(\"=== ans in addCondDNFToCondDNF: \", addedCondDNF_);\n"
<< "  return addedCondDNF_;\n"
<< "end;\n"
<< "\n"
<< "procedure addCondTupleToCondDNF(newCondTuple_, condDNF_)$\n"
<< "\n"
<< "\n"
<< "\n"
<< "begin;\n"
<< "  scalar addedCondDNF_, addedCondConj_;\n"
<< "\n"
<< "  debugWrite(\"=== in addCondTupleToCondDNF\", \" \");\n"
<< "  debugWrite(\"{newCondTuple_, condDNF_}: \", {newCondTuple_, condDNF_});\n"
<< "\n"
<< "  addedCondDNF_:= union(for each x in condDNF_ join <<\n"
<< "    addedCondConj_:= addCondTupleToCondConj(newCondTuple_, x);\n"
<< "    if(not isFalseConj(addedCondConj_)) then {addedCondConj_} else {}\n"
<< "  >>);\n"
<< "\n"
<< "  if(addedCondDNF_={}) then addedCondDNF_:= {{}};\n"
<< "  return ansWrite(\"addCondTupleToCondDNF\", addedCondDNF_);\n"
<< "end;\n"
<< "\n"
<< "procedure addCondTupleToCondConj(newCondTuple_, condConj_)$\n"
<< "begin;\n"
<< "  scalar addedCondConj_, varName_, relop_, value_,\n"
<< "         varTerms_, ubTuple_, lbTuple_, ub_, lb_,\n"
<< "         ubTupleList_, lbTupleList_, ineqSolDNF_;\n"
<< "\n"
<< "  debugWrite(\"in addCondTupleToCondConj\", \" \");\n"
<< "  debugWrite(\"{newCondTuple_, condConj_}: \", {newCondTuple_, condConj_});\n"
<< "\n"
<< "  \n"
<< "  if(newCondTuple_=true) then return ansWrite(\"addCondTupleToCondConj\", condConj_);\n"
<< "  \n"
<< "  \n"
<< "  if(not hasParameter(makeExprFromTuple(newCondTuple_)) and freeof(makeExprFromTuple(newCondTuple_), t)) then \n"
<< "    if(checkOrderingFormula(makeExprFromTuple(newCondTuple_))) then return ansWrite(\"addCondTupleToCondConj\", condConj_)\n"
<< "    else return ansWrite(\"addCondTupleToCondConj\", {});\n"
<< "  \n"
<< "  if(isFalseConj(condConj_)) then return ansWrite(\"addCondTupleToCondConj\", {});\n"
<< "  \n"
<< "  if(isTrueConj(condConj_)) then return ansWrite(\"addCondTupleToCondConj\", {newCondTuple_});\n"
<< "\n"
<< "\n"
<< "  \n"
<< "  \n"
<< "  if((arglength(getVarNameFromTuple(newCondTuple_)) neq -1) or not numberp(getValueFromTuple(newCondTuple_))) then <<\n"
<< "    \n"
<< "    ineqSolDNF_:= exIneqSolve(makeExprFromTuple(newCondTuple_));\n"
<< "    debugWrite(\"{ineqSolDNF_, (newCondTuple_), (condConj_)}: \", {ineqSolDNF_, newCondTuple_, condConj_});\n"
<< "    if(isFalseDNF(ineqSolDNF_)) then <<\n"
<< "      \n"
<< "      return ansWrite(\"addCondTupleToCondConj\", {});\n"
<< "    >> else if(isTrueDNF(ineqSolDNF_)) then <<\n"
<< "      \n"
<< "      addedCondConj_:= condConj_;\n"
<< "      return ansWrite(\"addCondTupleToCondConj\", addedCondConj_);\n"
<< "    >>;\n"
<< "    \n"
<< "    if(length(first(ineqSolDNF_))>1) then <<\n"
<< "      \n"
<< "      tmpConj_:= condConj_;\n"
<< "      for i:=1 : length(first(ineqSolDNF_)) do <<\n"
<< "        tmpConj_:= addCondTupleToCondConj(part(first(ineqSolDNF_), i), tmpConj_);\n"
<< "      >>;\n"
<< "      return ansWrite(\"addCondTupleToCondConj\", tmpConj_);\n"
<< "    >> else <<\n"
<< "      newCondTuple_:= first(first(ineqSolDNF_));\n"
<< "    >>\n"
<< "  >>;\n"
<< "\n"
<< "\n"
<< "  varName_:= getVarNameFromTuple(newCondTuple_);\n"
<< "  relop_:= getRelopFromTuple(newCondTuple_);\n"
<< "  value_:= getValueFromTuple(newCondTuple_);\n"
<< "  debugWrite(\"{varName_, relop_, value_}: \", {varName_, relop_, value_});\n"
<< "\n"
<< "  \n"
<< "  varTerms_:= union(for each term in condConj_ join\n"
<< "    if(not freeof(term, varName_)) then {term} else {});\n"
<< "  debugWrite(\"varTerms_: \", varTerms_);\n"
<< "\n"
<< "\n"
<< "  \n"
<< "  ubTupleList_:= getUbTupleListFromConj(varTerms_);\n"
<< "  lbTupleList_:= getLbTupleListFromConj(varTerms_);\n"
<< "  \n"
<< "  ubTupleList_:= for each x in ubTupleList_ join if(not hasParameter(getValueFromTuple(x))) then {x} else {};\n"
<< "  lbTupleList_:= for each x in lbTupleList_ join if(not hasParameter(getValueFromTuple(x))) then {x} else {};\n"
<< "  debugWrite(\"{ubTupleList_, lbTupleList_}: \", {ubTupleList_, lbTupleList_});\n"
<< "  if(ubTupleList_={}) then ubTupleList_:= {{varName_, leq, INFINITY}};\n"
<< "  if(lbTupleList_={}) then lbTupleList_:= {{varName_, geq, -INFINITY}};\n"
<< "  ubTuple_:= first(ubTupleList_);\n"
<< "  lbTuple_:= first(lbTupleList_);\n"
<< "\n"
<< "  \n"
<< "  ub_:= getValueFromTuple(ubTuple_);\n"
<< "  lb_:= getValueFromTuple(lbTuple_);\n"
<< "  debugWrite(\"{ub_, lb_}: \", {ub_, lb_});\n"
<< "  if((relop_=leq) or (relop_=lessp)) then <<\n"
<< "    \n"
<< "    if(mymin(value_, ub_)=value_) then <<\n"
<< "      \n"
<< "      if((value_ neq ub_) or freeof(ubTupleList_, lessp)) then\n"
<< "        addedCondConj_:= cons(newCondTuple_, condConj_ \\ ubTupleList_)\n"
<< "      else addedCondConj_:= condConj_;\n"
<< "      ub_:= value_;\n"
<< "      ubTuple_:= newCondTuple_;\n"
<< "    >> else <<\n"
<< "      addedCondConj_:= condConj_;\n"
<< "    >>;\n"
<< "  >> else <<\n"
<< "    \n"
<< "    if(mymin(value_, lb_)=lb_) then <<\n"
<< "      \n"
<< "      if((value_ neq lb_) or freeof(lbTupleList_, greaterp)) then\n"
<< "        addedCondConj_:= cons(newCondTuple_, condConj_ \\ lbTupleList_)\n"
<< "      else addedCondConj_:= condConj_;\n"
<< "      lb_:= value_;\n"
<< "      lbTuple_:= newCondTuple_;\n"
<< "    >> else <<\n"
<< "      addedCondConj_:= condConj_;\n"
<< "    >>;\n"
<< "  >>;\n"
<< "  debugWrite(\"addedCondConj_: \", addedCondConj_);\n"
<< "  debugWrite(\"lb_: \", lb_);\n"
<< "  debugWrite(\"lbTuple_: \", lbTuple_);\n"
<< "\n"
<< "  \n"
<< "  \n"
<< "  if(ub_ neq INFINITY) then << \n"
<< "    if(mymin(lb_, ub_)=lb_) then <<\n"
<< "      \n"
<< "      if((lb_=ub_) and not isEqualConj({ubTuple_, lbTuple_})) then addedCondConj_:= {};\n"
<< "    >> else <<\n"
<< "      addedCondConj_:= {};\n"
<< "    >>;\n"
<< "  >>;\n"
<< "\n"
<< "  debugWrite(\"{(newCondTuple_), (condConj_)}: \", {newCondTuple_, condConj_});\n"
<< "  return ansWrite(\"addCondTupleToCondConj\", addedCondConj_);\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure mymkand(lst)$\n"
<< "for i:=1:length(lst) mkand part(lst,i);\n"
<< "\n"
<< "\n"
<< "procedure mymkor(lst)$\n"
<< "for i:=1:length(lst) mkor part(lst, i);\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure exSolve(exprs_, vars_)$\n"
<< "begin;\n"
<< "  scalar tmpSol_, retSol_;\n"
<< "\n"
<< "  debugWrite(\"=== in exSolve: \", {exprs_, vars_});\n"
<< "  \n"
<< "  off allbranch;\n"
<< "  tmpSol_:= solve(exprs_, vars_);\n"
<< "  on allbranch;\n"
<< "\n"
<< "  \n"
<< "  tmpSol_:= for each x in tmpSol_ join\n"
<< "    if(head(x)=list) then <<\n"
<< "      {for each y in x join \n"
<< "        if(hasImaginaryNum(rhs(y))) then {} else {y}\n"
<< "      }\n"
<< "    >> else <<\n"
<< "      if(hasImaginaryNum(rhs(x))) then {} else {x}\n"
<< "    >>;\n"
<< "  debugWrite(\"tmpSol_ after removing imaginary number: \", tmpSol_);\n"
<< "\n"
<< "  \n"
<< "  tmpSol_:= for each x in tmpSol_ join\n"
<< "    if(head(x)=list) then <<\n"
<< "      {for each y in x join \n"
<< "        if(hasIndefinableNum(rhs(y))) then {} else {y}\n"
<< "      }\n"
<< "    >> else <<\n"
<< "      if(hasIndefinableNum(rhs(x))) then {} else {x}\n"
<< "    >>;\n"
<< "  debugWrite(\"tmpSol_ after removing indefinable value: \", tmpSol_);\n"
<< "\n"
<< "  \n"
<< "  retSol_:= for each x in tmpSol_ collect\n"
<< "    if(head(x)=list) then map(rationalise, x)\n"
<< "    else rationalise(x);\n"
<< "  debugWrite(\"=== ans in exSolve: \", retSol_);\n"
<< "  return retSol_;\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure exIneqSolve(ineqExpr_)$\n"
<< "begin;\n"
<< "  scalar lhs_, relop_, rhs_, adjustedLhs_, adjustedRelop_, \n"
<< "         reverseRelop_, adjustedIneqExpr_, sol_, adjustedEqExpr_,\n"
<< "         retTuple_, exprVarList_, exprVar_, retTupleDNF_,\n"
<< "         boundList_, ub_, lb_, eqSol_, eqSolValue_, sqrtCondTuple_, lcofRet_, sqrtCoeffList_,\n"
<< "         sqrtCoeff_, insideSqrtExprs_;\n"
<< "\n"
<< "  debugWrite(\"=== in exIneqSolve: \", ineqExpr_);\n"
<< "\n"
<< "  lhs_:= lhs(ineqExpr_);\n"
<< "  relop_:= head(ineqExpr_);\n"
<< "  rhs_:= rhs(ineqExpr_);\n"
<< "\n"
<< "  \n"
<< "  exprVarList_:= union(for each x in union(variables__, {t}) join\n"
<< "    if(not freeof(ineqExpr_, x)) then {x} else {});\n"
<< "  if(exprVarList_={}) then <<\n"
<< "    exprVarList_:= union(for each x in parameters__ join\n"
<< "      if(not freeof(ineqExpr_, x)) then {x} else {});\n"
<< "  exprVarList_:= if(exprVarList_ neq {}) then exprVarList_ else {INFINITY}\n"
<< "  >>;\n"
<< "  exprVar_:= first(exprVarList_);\n"
<< "  debugWrite(\"{exprVarList_, exprVar_}: \", {exprVarList_, exprVar_});\n"
<< "\n"
<< "  \n"
<< "  adjustedIneqExpr_:= myApply(relop_, {lhs_+(-1)*rhs_, 0});\n"
<< "  adjustedLhs_:= lhs(adjustedIneqExpr_);\n"
<< "  adjustedRelop_:= head(adjustedIneqExpr_);\n"
<< "  debugWrite(\"{adjusted IneqExpr, Lhs_, Relop_}: \", \n"
<< "    {adjustedIneqExpr_, adjustedLhs_, adjustedRelop_});\n"
<< "\n"
<< "  \n"
<< "  if(hasTrigonometricFunc(adjustedLhs_)) then <<\n"
<< "    compareIntervalRet_:= compareInterval(convertValueToInterval(adjustedLhs_), adjustedRelop_, makePointInterval(0));\n"
<< "    debugWrite(\"compareIntervalRet_: \", compareIntervalRet_);\n"
<< "    if(compareIntervalRet_=t) then <<\n"
<< "      retTupleDNF_:= {{true}};\n"
<< "      debugWrite(\"exIneqSolve arg: \", ineqExpr_);\n"
<< "      debugWrite(\"=== ans in exIneqSolve: \", retTupleDNF_);\n"
<< "      return retTupleDNF_;\n"
<< "    >> else if(compareIntervalRet_=nil) then <<\n"
<< "      retTupleDNF_:= {{}};\n"
<< "      debugWrite(\"exIneqSolve arg: \", ineqExpr_);\n"
<< "      debugWrite(\"=== ans in exIneqSolve: \", retTupleDNF_);\n"
<< "      return retTupleDNF_;\n"
<< "    >> else <<\n"
<< "      \n"
<< "      retTupleDNF_:= {{unknown}};\n"
<< "      debugWrite(\"exIneqSolve arg: \", ineqExpr_);\n"
<< "      debugWrite(\"=== ans in exIneqSolve: \", retTupleDNF_);\n"
<< "      return retTupleDNF_;\n"
<< "    >>;\n"
<< "  >>;\n"
<< "\n"
<< "  \n"
<< "  \n"
<< "  \n"
<< "  \n"
<< "  lcofRet_:= lcof(adjustedLhs_, exprVar_);\n"
<< "  if(not numberp(lcofRet_)) then lcofRet_:= 0;\n"
<< "  sqrtCoeffList_:= getSqrtList(adjustedLhs_, exprVar_, COEFF);\n"
<< "  \n"
<< "  if(sqrtCoeffList_={}) then sqrtCoeff_:= 0\n"
<< "  else if(length(sqrtCoeffList_)=1) then sqrtCoeff_:= first(sqrtCoeffList_);\n"
<< "  \n"
<< "  if(checkOrderingFormula(lcofRet_<0) or checkOrderingFormula(sqrtCoeff_<0)) then <<\n"
<< "    adjustedRelop_:= getReverseRelop(adjustedRelop_);\n"
<< "  >>;\n"
<< "  debugWrite(\"adjustedRelop_: \", adjustedRelop_);\n"
<< "\n"
<< "  \n"
<< "  \n"
<< "  insideSqrtExprs_:= getSqrtList(adjustedLhs_, exprVar_, INSIDE);\n"
<< "  debugWrite(\"insideSqrtExprs_: \", insideSqrtExprs_);\n"
<< "  sqrtCondTupleList_:= map(first(first(exIneqSolve(myApply(geq, {~w, 0})))), insideSqrtExprs_);\n"
<< "  debugWrite(\"sqrtCondTupleList_: \", sqrtCondTupleList_);\n"
<< "  if(sqrtCondTupleList_={}) then sqrtCondTupleList_:= {true};\n"
<< "\n"
<< "  \n"
<< "  \n"
<< "  off arbvars;\n"
<< "  on multiplicities;\n"
<< "  sol_:= exSolve(equal(adjustedLhs_, 0), exprVar_);\n"
<< "  debugWrite(\"sol_ from exSolve: \", sol_);\n"
<< "  on arbvars;\n"
<< "  off multiplicities;\n"
<< "\n"
<< "  \n"
<< "  \n"
<< "\n"
<< "  if(sol_={}) then <<\n"
<< "    \n"
<< "    \n"
<< "    if((adjustedRelop_=geq) or (adjustedRelop_=greaterp) or (adjustedRelop_=neq)) then retTupleDNF_:= {{true}}\n"
<< "    else retTupleDNF_:= {{}};\n"
<< "  >> else if(length(sol_)>1) then <<\n"
<< "    \n"
<< "    \n"
<< "\n"
<< "    boundList_:= {rhs(part(sol_, 1)), rhs(part(sol_, 2))};\n"
<< "    debugWrite(\"boundList_: \", boundList_);\n"
<< "    if(not hasParameter(boundList_)) then <<\n"
<< "      if(length(union(boundList_))=1) then <<\n"
<< "        \n"
<< "        lb_:= first(union(boundList_));\n"
<< "        ub_:= first(union(boundList_));\n"
<< "      >> else <<\n"
<< "        lb_:= findMinimumValue(INFINITY, boundList_);\n"
<< "        ub_:= first(boundList_ \\ {lb_});\n"
<< "      >>;\n"
<< "      debugWrite(\"lb_ in exIneqSolve: \", lb_);\n"
<< "      debugWrite(\"ub_ in exIneqSolve: \", ub_);\n"
<< "    \n"
<< "      \n"
<< "      if((adjustedRelop_ = geq) or (adjustedRelop_ = greaterp)) then <<\n"
<< "        \n"
<< "        retTupleDNF_:= {{ {exprVar_, getReverseRelop(adjustedRelop_), lb_} }, { {exprVar_, adjustedRelop_, ub_} }};\n"
<< "      >> else if((adjustedRelop_ = geq) or (adjustedRelop_ = greaterp)) then <<\n"
<< "        \n"
<< "        retTupleDNF_:= {{ {exprVar_, getReverseRelop(adjustedRelop_), lb_},     {exprVar_, adjustedRelop_, ub_} }};\n"
<< "      >> else <<\n"
<< "        \n"
<< "        retTupleDNF_:= {{ {exprVar_, lessp, lb_} }, { {exprVar_, greaterp, lb_}, {exprVar_, lessp, ub_} }, { {exprVar_, greaterp, ub_} }};\n"
<< "      >>;\n"
<< "    >> else <<\n"
<< "      \n"
<< "      \n"
<< "      \n"
<< "\n"
<< "\n"
<< "      retTupleDNF_:= hogehogegege;\n"
<< "    >>;\n"
<< "  >> else <<\n"
<< "    adjustedEqExpr_:= first(sol_);\n"
<< "    retTuple_:= {lhs(adjustedEqExpr_), adjustedRelop_, rhs(adjustedEqExpr_)};\n"
<< "    retTupleDNF_:= {{retTuple_}};\n"
<< "  >>;\n"
<< "\n"
<< "  debugWrite(\"retTupleDNF_ before adding sqrtCondTuple_: \", retTupleDNF_);\n"
<< "\n"
<< "  if(not isFalseDNF(retTupleDNF_)) then <<\n"
<< "    debugWrite(\"sqrtCondTupleList_ add loop: \", sqrtCondTupleList_);\n"
<< "    for i:=1 : length(sqrtCondTupleList_) do <<\n"
<< "      debugWrite(\"add : \", part(sqrtCondTupleList_, i));\n"
<< "      retTupleDNF_:= addCondTupleToCondDNF(part(sqrtCondTupleList_, i), retTupleDNF_);\n"
<< "      debugWrite(\"retTupleDNF_ in loop of adding sqrtCondTuple: \", retTupleDNF_);\n"
<< "    >>;\n"
<< "  >>;\n"
<< "  debugWrite(\"exIneqSolve arg: \", ineqExpr_);\n"
<< "  debugWrite(\"=== ans in exIneqSolve: \", retTupleDNF_);\n"
<< "\n"
<< "  return retTupleDNF_;\n"
<< "end;\n"
<< "\n"
<< "procedure exRlqe(formula_)$\n"
<< "begin;\n"
<< "  scalar appliedFormula_, header_, argsCount_, appliedArgsList_;\n"
<< "  debugWrite(\"formula_: \", formula_);\n"
<< "\n"
<< "  \n"
<< "  if(arglength(formula_)=-1) then <<\n"
<< "    appliedFormula_:= rlqe(formula_);\n"
<< "    return appliedFormula_;\n"
<< "  >>;\n"
<< "\n"
<< "  header_:= head(formula_);\n"
<< "  debugWrite(\"header_: \", header_);\n"
<< "  argsCount_:= arglength(formula_);\n"
<< "\n"
<< "  if((header_=and) or (header_=or)) then <<\n"
<< "    argsList_:= for i:=1 : argsCount_ collect part(formula_, i);\n"
<< "    appliedArgsList_:= map(exRlqe(~w), argsList_);\n"
<< "    if(header_= and) then appliedFormula_:= rlqe(mymkand(appliedArgsList_));\n"
<< "    if(header_= or) then appliedFormula_:= rlqe(mymkor(appliedArgsList_));\n"
<< "  >> else if(not freeof(formula_, sqrt)) then <<\n"
<< "    \n"
<< "    \n"
<< "    if(checkOrderingFormula(myApply(getInverseRelop(header_), {lhs(formula_), rhs(formula_)}))) then \n"
<< "      appliedFormula_:= false \n"
<< "    else appliedFormula_:= rlqe(formula_);\n"
<< "  >> else <<\n"
<< "    appliedFormula_:= rlqe(formula_);\n"
<< "  >>;\n"
<< "\n"
<< "  debugWrite(\"appliedFormula_: \", appliedFormula_);\n"
<< "  return appliedFormula_;\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure makeInitId(f,i)$\n"
<< "  if(i=0) then\n"
<< "    mkid(mkid(INIT,f),lhs)\n"
<< "  else\n"
<< "    mkid(mkid(mkid(mkid(INIT,f),_),i),lhs);\n"
<< "\n"
<< "\n"
<< "procedure setMkidOperator(f,x)$\n"
<< "  f(x);\n"
<< "\n"
<< "\n"
<< "operator !~f$\n"
<< "\n"
<< "\n"
<< "let {\n"
<< "  laplace(df(~f(~x),x),x) => il!&*laplace(f(x),x) - makeInitId(f,0),\n"
<< "  laplace(df(~f(~x),x,~n),x) => il!&**n*laplace(f(x),x) -\n"
<< "    for i:=n-1 step -1 until 0 sum\n"
<< "      makeInitId(f,n-1-i) * il!&**i,\n"
<< "  laplace(~f(~x),x) => setMkidOperator(mkid(lap,f),il!&)\n"
<< "}$\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure laplaceLetUnit(lapList_)$\n"
<< "begin;\n"
<< "  scalar arg_, LAParg_;\n"
<< "\n"
<< "  arg_:= first lapList_;\n"
<< "  LAParg_:= second lapList_;\n"
<< "\n"
<< "  \n"
<< "  if(freeof(loadedOperator__,arg_)) then \n"
<< "    << \n"
<< "     operator arg_, LAParg_;\n"
<< "     loadedOperator__:= arg_ . loadedOperator__;\n"
<< "    >>;\n"
<< "\n"
<< "  return {arg_, arg_(t), LAParg_(s)};\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "procedure removedf(vars_)$\n"
<< "begin;\n"
<< "  scalar exceptDfVars_;\n"
<< "  exceptDfVars_:= {};\n"
<< "  for each x in vars_ collect\n"
<< "    if(freeof(x,df)) then exceptDfVars_:= x . exceptDfVars_;\n"
<< "  return exceptDfVars_;\n"
<< "end;\n"
<< "\n"
<< "retsolvererror___ := 0;\n"
<< "retoverconstraint___ := 2;\n"
<< "retunderconstraint___ := 3;\n"
<< "\n"
<< "\n"
<< "procedure getf(x,lst)$\n"
<< "  if(lst={}) then nil else\n"
<< "    if(x=lhs(first(lst))) then rhs(first(lst)) else\n"
<< "      getf(x,rest(lst));\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure lgetf(x,llst)$\n"
<< "  if(llst={}) then {} else\n"
<< "    if(rest(llst)={}) then getf(x,first(llst)) else\n"
<< "      getf(x,first(llst)) . {lgetf(x,rest(llst))};\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure dSolveByLaplace(expr_, initCons_, vars_)$\n"
<< "begin;\n"
<< "  scalar ans_, lapList_, lapTable_, lapPattern_;\n"
<< "  scalar exceptDfVars_, subedExpr_, diffExpr_, lapExpr_, solveVars_, solveAns_, isUnderConstraint_;\n"
<< "\n"
<< "  debugWrite(\"in dSolveByLaplace\", \" \");\n"
<< "  debugWrite(\"{expr_, initCons_, vars_}: \", {expr_, initCons_, vars_});\n"
<< "\n"
<< "  exceptDfVars_:= removedf(vars_);\n"
<< "  lapList_:= map({~w, mkid(lap, ~w)}, exceptDfVars_);\n"
<< "\n"
<< "  \n"
<< "  lapTable_:= map(laplaceLetUnit, lapList_);\n"
<< "  debugWrite(\"lapTable_: \", lapTable_);\n"
<< "\n"
<< "  \n"
<< "  lapPattern_:= map(first(~w)=second(~w), lapTable_);\n"
<< "  subedExpr_:= sub(lapPattern_, expr_);\n"
<< "\n"
<< "  \n"
<< "  diffExpr_:= {};\n"
<< "  for each x in subedExpr_ do\n"
<< "    if(not freeof(x, equal)) then\n"
<< "      diffExpr_:= append(diffExpr_, {lhs(x) - rhs(x)})\n"
<< "    else diffExpr_:= append(diffExpr_, {lhs(x) - rhs(x)});\n"
<< "\n"
<< "  \n"
<< "  if(not freeof(lapExpr_, laplace)) then return ansWrite(\"dSolveByLaplace\", retsolvererror___);\n"
<< "\n"
<< "  \n"
<< "  lapExpr_:=map(laplace(~w,t,s), diffExpr_);\n"
<< "  debugWrite(\"lapExpr_: \", lapExpr_);\n"
<< "\n"
<< "  \n"
<< "  solveVars_:= union(map(third, lapTable_), map(lhs, initCons_), {s});\n"
<< "  debugWrite(\"solveVars_:\", solveVars_);\n"
<< "\n"
<< "  \n"
<< "  solveAns_:= solve(union(lapExpr_, initCons_), solveVars_);\n"
<< "  debugWrite(\"solveAns_: \", solveAns_);\n"
<< "\n"
<< "  \n"
<< "  if(length(solveAns_) >= 2) then\n"
<< "    for each x in solveAns_ do\n"
<< "      if(hasSEqualArbComplex(x) or notHaveSExpr(x)) then solveAns_:= {x};\n"
<< "  debugWrite(\"solveAns_: \", solveAns_);\n"
<< "\n"
<< "  \n"
<< "  isUnderConstraint_:= false;\n"
<< "  for each x in lapTable_ do\n"
<< "    if(freeof(solveAns_, third(x))) then isUnderConstraint_:= true;\n"
<< "  if(isUnderConstraint_=true) then\n"
<< "    return ansWrite(\"dSolveByLaplace\", retunderconstraint___);\n"
<< "\n"
<< "  \n"
<< "  ans_:= for each x in lapTable_ collect\n"
<< "           first(x) = invlap(lgetf(third(x), solveAns_), s, t);\n"
<< "  return ansWrite(\"dSolveByLaplace\", ans_);\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure exDSolve(cons_, guardCons_, initCons_, vars_)$\n"
<< "begin;\n"
<< "  scalar noDifferentialVars_, tmpExpr_, resultCons_, resultRule_, rules_, loopAns_;\n"
<< "\n"
<< "  debugWrite(\"in exDSolve\", \" \");\n"
<< "  debugWrite(\"{cons_, guardCons_, initCons_, vars_}: \", {cons_, guardCons_, initCons_, vars_});\n"
<< "\n"
<< "  noDifferentialVars_:=\n"
<< "    for each x in removePrevCons(vars_) collect\n"
<< "      if(isDifferentialVar(x)) then part(x, 1) else x;\n"
<< "  noDifferentialVars_:= myUniq(noDifferentialVars_);\n"
<< "  debugWrite(\"noDifferentialVars_: \", noDifferentialVars_);\n"
<< "\n"
<< "  tmpExpr_:= union(removePrevCons(cons_), guardCons_);\n"
<< "  resultCons_:= filter(hasIneqRelop, tmpExpr_);\n"
<< "  debugWrite(\"resultCons_: \", resultCons_);\n"
<< "\n"
<< "  \n"
<< "  debugWrite(\"old tmpExpr_: \", union(part(splitExprs(removePrevCons(cons_), vars_), 3), guardCons_));\n"
<< "  tmpExpr_:= filter(hasEqual, tmpExpr_);\n"
<< "  debugWrite(\"tmpExpr_: \",tmpExpr_);\n"
<< "\n"
<< "  loopAns_:= exDSolveLoop(tmpExpr_, noDifferentialVars_, vars_, initCons_, {}, resultCons_);\n"
<< "\n"
<< "  if(loopAns_ = retoverconstraint___) then  return ansWrite(\"exDSolve\", retoverconstraint___);\n"
<< "  if(loopAns_ = retsolvererror___) then     return ansWrite(\"exDSolve\", retsolvererror___);\n"
<< "  if(loopAns_ = retunderconstraint___) then return ansWrite(\"exDSolve\", retunderconstraint___);\n"
<< "\n"
<< "  resultRule_:= first loopAns_;\n"
<< "  resultCons_:= second loopAns_;\n"
<< "  tmpExpr_:= third loopAns_;\n"
<< "\n"
<< "  subedGuard_:= rlqe mymkand exSub(resultRule_, guardCons_);\n"
<< "  debugWrite(\"subedGuard_ :\", subedGuard_);\n"
<< "\n"
<< "  if(subedGuard_ = false) then return ansWrite(\"exDSolve\", retoverconstraint___);\n"
<< "  if((not hasVariable(subedGuard_, vars_)) and not freeof(subedGuard_, t)) then\n"
<< "    return ansWrite(\"exDSolve\", retoverconstraint___);\n"
<< "\n"
<< "  return ansWrite(\"exDSolve\", {union(resultCons_, tmpExpr_), resultRule_});\n"
<< "end;\n"
<< "\n"
<< "procedure exDSolveLoop(tmpExpr_, noDifferentialVars_, vars_, initCons_, resultRule_, resultCons_)$\n"
<< "begin;\n"
<< "  scalar searchResult_, rules_;\n"
<< "  debugWrite(\"in exDSolveLoop: \", \" \");\n"
<< "  debugWrite(\"{tmpExpr_, noDifferentialVars_, vars_, resultRule_, resultCons_}: \",\n"
<< "    {tmpExpr_, noDifferentialVars_, vars_, resultRule_, resultCons_});\n"
<< "\n"
<< "  searchResult_:= searchExprsAndVars(tmpExpr_, noDifferentialVars_);\n"
<< "  if(searchResult_ = unExpandable) then return ansWrite(\"exDSolveLoop\", {resultRule_, resultCons_, tmpExpr_});\n"
<< "\n"
<< "  rules_:= dSolveByLaplace(first(searchResult_), initCons_, third(searchResult_));\n"
<< "  if(rules_ = retsolvererror___) then return ansWrite(\"exDSolveLoop\", retsolvererror___);\n"
<< "  if(rules_ = retunderconstraint___) then return ansWrite(\"exDSolveLoop\", retunderconstraint___);\n"
<< "\n"
<< "  resultRule_:= union(resultRule_, rules_);\n"
<< "  debugWrite(\"resultRule_: \", resultRule_);\n"
<< "\n"
<< "  tmpExpr_:= exSub(rules_, second(searchResult_));\n"
<< "  debugWrite(\"tmpExpr_: \", tmpExpr_);\n"
<< "  if((not hasVariable(tmpExpr_, vars_)) and not freeof(tmpExpr_, t)) then\n"
<< "    return ansWrite(\"exDSolveLoop\", retoverconstraint___);\n"
<< "  if(rlqe(mymkand(tmpExpr_)) = false) then return ansWrite(\"exDSolveLoop\", retoverconstraint___);\n"
<< "\n"
<< "  tmpExpr_:= filter(isNotTrue, tmpExpr_);\n"
<< "  debugWrite(\"tmpExpr_: \", tmpExpr_);\n"
<< "\n"
<< "  resultCons_:= exSub(rules_, resultCons_);\n"
<< "  if(rlqe(mymkand(resultCons_)) = false) then return ansWrite(\"exDSolveLoop\", retoverconstraint___);\n"
<< "  resultCons_:= filter(isNotTrue, resultCons_);\n"
<< "\n"
<< "  return exDSolveLoop(tmpExpr_, noDifferentialVars_, vars_, initCons_, resultRule_, resultCons_);\n"
<< "end;\n"
<< "\n"
<< "procedure searchExprsAndVars(exprs_, vars_)$\n"
<< "begin;\n"
<< "  debugWrite(\"searchExprsAndVars: \", {exprs_, vars_});\n"
<< "  searchResult_:= searchExprsAndVarsLoop(exprs_, vars_, 1);\n"
<< "  return ansWrite(\"searchExprsAndVars\", searchResult_);\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure searchExprsAndVarsLoop(exprs_, vars_, idx_)$\n"
<< "begin;\n"
<< "  debugWrite(\"searchExprsAndVarsLoop: \", {exprs_, vars_, idx_});\n"
<< "\n"
<< "  if(idx_ > length(exprs_)) then return unExpandable;\n"
<< "  tmpVars_:= for each var in vars_ join if(not freeof(part(exprs_, idx_) , var)) then {var} else {};\n"
<< "  debugWrite(\"tmpVars_: \", tmpVars_);\n"
<< "  if(length(tmpVars_) = 1) then\n"
<< "    return {{part(exprs_, idx_)}, drop(exprs_, idx_), tmpVars_};\n"
<< "\n"
<< "  return searchExprsAndVarsLoop(exprs_, vars_, idx_ + 1);\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure getFrontTwoElemList(lst_)$\n"
<< "  if(length(lst_)<2) then {} else\n"
<< "    for i:=1 : 2 collect part(lst_, i);\n"
<< "\n"
<< "procedure removeTrueList(patternList_)$\n"
<< "  for each x in patternList_ join if(rlqe(x)=true) then {} else {x};\n"
<< "\n"
<< "procedure isNotTrue(formula_)$\n"
<< "  if(rlqe(formula_) <> true) then t else nil;\n"
<< "\n"
<< "\n"
<< "procedure removeTrueFormula(formula_)$\n"
<< "  if(formula_=true) then true else\n"
<< "    myApply(and, for each x in getArgsList(formula_) join \n"
<< "      if(rlqe(x)=true) then {} else {x});\n"
<< "\n"
<< "\n"
<< "procedure getOtherExpr(exprs_)$\n"
<< "  for each x in exprs_ join if(hasIneqRelop(x) or hasLogicalOp(x)) then {x} else {};\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure isNDExpr(expr_)$\n"
<< "  if(freeof(expr_, sin) and freeof(expr_, cos)) then nil else t;\n"
<< "\n"
<< "\n"
<< "procedure splitExprs(exprs_, vars_)$\n"
<< "begin;\n"
<< "  scalar otherExprs_, NDExprs_, NDExprVars_, DExprs_, DExprVars_;\n"
<< "\n"
<< "  otherExprs_:= union(for each x in exprs_ join \n"
<< "                  if(hasIneqRelop(x) or hasLogicalOp(x)) then {x} else {});\n"
<< "  NDExprs_ := union(for each x in (exprs_ \\ otherExprs_) join \n"
<< "                if(isNDExpr(x)) then {x} else {});\n"
<< "  NDExprVars_ := union(for each x in vars_ join if(not freeof(NDExprs_, x)) then {x} else {});\n"
<< "  DExprs_ := (exprs_ \\ otherExprs_) \\ NDExprs_;\n"
<< "  DExprVars_:= union(for each x in vars_ join if(not freeof(DExprs_, x)) then {x} else {});\n"
<< "  return {NDExprs_, NDExprVars_, DExprs_, DExprVars_, otherExprs_};\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "procedure getInitVars(rcont_)$\n"
<< "  lhs(rcont_);\n"
<< "\n"
<< "procedure getIneqBoundTCLists(ineqTCList_)$\n"
<< "begin;\n"
<< "  scalar lbTCList_, ubTCList_, timeExpr_, condExpr_, relop_, exprLhs_, lcofRet_, solveAns_;\n"
<< "\n"
<< "  lbTCList_:= {};\n"
<< "  ubTCList_:= {};\n"
<< "  for each x in ineqTCList_ do <<\n"
<< "    timeExpr_:= getTimeFromTC(x);\n"
<< "    condExpr_:= getCondDNFFromTC(x);\n"
<< "\n"
<< "    \n"
<< "    relop_:= head(timeExpr_);\n"
<< "    exprLhs_:= lhs(timeExpr_);\n"
<< "    lcofRet_:= lcof(exprLhs_, t);\n"
<< "    if(checkOrderingFormula(lcofRet_<0)) then relop_:= getReverseRelop(relop_);\n"
<< "    solveAns_:= first(solve(exprLhs_=0, t));\n"
<< "\n"
<< "    if((relop_ = geq) or (relop_ = greaterp)) then\n"
<< "      lbTCList_:= cons({rhs(solveAns_), condExpr_}, lbTCList_)\n"
<< "    else ubTCList_:= cons({rhs(solveAns_), condExpr_}, ubTCList_);\n"
<< "  >>;\n"
<< "  debugWrite(\"lbTCList_: \", lbTCList_);\n"
<< "  debugWrite(\"ubTCList_: \", ubTCList_);\n"
<< "  return {lbTCList_, ubTCList_};\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure hasVariable(exprs_, vars_)$\n"
<< "begin;\n"
<< "  scalar check_;\n"
<< "  check_:=\n"
<< "    for each x in vars_ join if(freeof(exprs_, x)) then {} else {x};\n"
<< "  if(check_ <> {}) then return t\n"
<< "  else return nil;\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "procedure getLhsQuantified(exprs_)$\n"
<< "  union(for each x in exprs_ join\n"
<< "    if(freeof(lhs x, df) and freeof(lhs x, prev)) then {x} else {}\n"
<< "  );\n"
<< "\n"
<< "\n"
<< "procedure getQuantifiedVars(vars_)$\n"
<< "  union(for each x in vars_ join\n"
<< "    if(freeof(x, prev) and freeof(x, df)) then {x} else {}\n"
<< "  );\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure isDifferentialVar(var_)$\n"
<< "  if(arglength(var_)=-1) then nil\n"
<< "  else if(head(var_)=df) then t\n"
<< "  else nil;\n"
<< "\n"
<< "\n"
<< "procedure removeDfCons(consList_)$\n"
<< "  union(for each x in consList_ join if(freeof(x, df)) then {x} else {});\n"
<< "\n"
<< "\n"
<< "procedure getDfVars(vars_)$\n"
<< "  union(for each x in vars_ join\n"
<< "    if(freeof(x, prev) and not freeof(x, df)) then {x} else {}\n"
<< "  );\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure isPrevVariable(expr_)$\n"
<< "  if(arglength(expr_)=-1) then nil\n"
<< "  else if(head(expr_)=prev) then t\n"
<< "  else nil;\n"
<< "\n"
<< "\n"
<< "procedure removePrev(var_)$\n"
<< "  if(head(var_)=prev) then part(var_, 1) else var_;\n"
<< "\n"
<< "\n"
<< "procedure removePrevCons(consList_)$\n"
<< "  union(for each x in consList_ join if(freeof(x, prev)) then {x} else {});\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure addInitVariables(vars_)$\n"
<< "begin;\n"
<< "\n"
<< "  initVariables__:= union(initVariables__, vars_);\n"
<< "  debugWrite(\"initVariables__: \", initVariables__);\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "procedure isInitVariable(var_)$\n"
<< "begin;\n"
<< "  scalar ret_;\n"
<< "\n"
<< "  if(arglength(var_) neq -1) then return nil;\n"
<< "  ret_ := nil;\n"
<< "  for each x in initVariables__ do if x = var_ then ret_ := t;\n"
<< "  return ret_;\n"
<< "end;\n"
<< "\n"
<< "procedure removeInitCons(consList_)$\n"
<< "begin;\n"
<< "\n"
<< "  return union(consList_ \\\n"
<< "    for each initVariable in initVariables__ join\n"
<< "      for each x in consList_ join \n"
<< "        if(freeof(x, initVariable)) then {} else {x}\n"
<< "  );\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "rettrue___    := 1;\n"
<< "retfalse___   := 2;\n"
<< "\n"
<< "\n"
<< "procedure resetConstraint()$\n"
<< "begin;\n"
<< "\n"
<< "  constraint__ := {};\n"
<< "  variables__ := {};\n"
<< "  pConstraint__:= {};\n"
<< "  prevConstraint__:= {};\n"
<< "  parameters__:= {};\n"
<< "  isTemporary__:= nil;\n"
<< "  initConstraint__ := {};\n"
<< "  initTmpConstraint__:= {};\n"
<< "  tmpConstraint__:= {};\n"
<< "  tmpVariables__:= {};\n"
<< "  prevVariables__:= {};\n"
<< "  guard__:= {};\n"
<< "  guardVars__:= {};\n"
<< "  initVariables__:= {};\n"
<< "  debugWrite(\"constraint__: \", constraint__);\n"
<< "  debugWrite(\"variables__: \", variables__);\n"
<< "  debugWrite(\"pConstraint__: \", pConstraint__);\n"
<< "  debugWrite(\"prevConstraint__: \", prevConstraint__);\n"
<< "  debugWrite(\"prevVariables__: \", prevVariables__);\n"
<< "  debugWrite(\"parameters__: \", parameters__);\n"
<< "  debugWrite(\"isTemporary__\", isTemporary__);\n"
<< "  debugWrite(\"initConstraint__\", initConstraint__);\n"
<< "  debugWrite(\"initTmpConstraint__\", initTmpConstraint__);\n"
<< "  debugWrite(\"tmpVariables__\", tmpVariables__);\n"
<< "  debugWrite(\"initVariables__\", initVariables__);\n"
<< "end;\n"
<< "\n"
<< "procedure resetConstraintForVariable()$\n"
<< "begin;\n"
<< "\n"
<< "  constraint__ := {};\n"
<< "  variables__ := {};\n"
<< "  tmpVariables__:= {};\n"
<< "  prevVariables__:= {};\n"
<< "  debugWrite(\"constraint__: \", constraint__);\n"
<< "  debugWrite(\"variables__: \", variables__);\n"
<< "  debugWrite(\"tmpVariables__\", tmpVariables__);\n"
<< "  debugWrite(\"prevVariables__: \", prevVariables__);\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "procedure addInitConstraint(co_, va_)$\n"
<< "begin;\n"
<< "\n"
<< "  debugWrite(\"prevConstraint__: \", prevConstraint__);\n"
<< "  debugWrite(\"co_: \", co_);\n"
<< "  debugWrite(\"va_: \", va_);\n"
<< "\n"
<< "  if(isTemporary__) then\n"
<< "  <<\n"
<< "    tmpVariables__:= union(tmpVariables__, va_);\n"
<< "    initTmpConstraint__ := union(initTmpConstraint__, exSub(prevConstraint__, co_));\n"
<< "  >> else\n"
<< "  <<\n"
<< "    variables__ := union(variables__, va_);\n"
<< "    initConstraint__ := union(initConstraint__, exSub(prevConstraint__, co_));\n"
<< "  >>;\n"
<< "\n"
<< "  debugWrite(\"tmpVariables__: \", tmpVariables__);\n"
<< "  debugWrite(\"initTmpConstraint__: \", initTmpConstraint__);\n"
<< "  debugWrite(\"variables__: \", variables__);\n"
<< "  debugWrite(\"initConstraint__: \", initConstraint__);\n"
<< "end;\n"
<< "\n"
<< "procedure addPrevConstraint(cons_, vars_)$\n"
<< "begin;\n"
<< "\n"
<< "  prevConstraint__:= union(prevConstraint__, cons_);\n"
<< "  prevVariables__:= union(prevVariables__, vars_);\n"
<< "\n"
<< "  debugWrite(\"prevConstraint__: \", prevConstraint__);\n"
<< "  debugWrite(\"prevVariables__: \", prevVariables__);\n"
<< "end;\n"
<< "\n"
<< "procedure addGuard(gu_, vars_)$\n"
<< "begin;\n"
<< "  if(part(gu_,0)=list) then\n"
<< "  <<\n"
<< "    guard__:= union(guard__, gu_); \n"
<< "  >> else\n"
<< "  <<\n"
<< "    guard__:= union(guard__, {gu_}); \n"
<< "  >>;\n"
<< "\n"
<< "  guardVars__:= union(guardVars__, vars_);\n"
<< "  debugWrite(\"guard__: \", guard__);\n"
<< "  debugWrite(\"guardVars__: \", guardVars__);\n"
<< "end;\n"
<< "\n"
<< "procedure setGuard(gu_, vars_)$\n"
<< "begin;\n"
<< "  if(part(gu_,0)=list) then\n"
<< "  <<\n"
<< "    guard__:= gu_; \n"
<< "  >> else\n"
<< "  <<\n"
<< "    guard__:= {gu_};\n"
<< "  >>;\n"
<< "\n"
<< "  guardVars__:= vars_;\n"
<< "  debugWrite(\"guard__: \", guard__);\n"
<< "  debugWrite(\"guardVars__: \", guardVars__);\n"
<< "end;\n"
<< "\n"
<< "procedure startTemporary()$\n"
<< "begin;\n"
<< "  isTemporary__:= t;\n"
<< "end;\n"
<< "\n"
<< "procedure endTemporary()$\n"
<< "begin;\n"
<< "  isTemporary__:= nil;\n"
<< "  resetTemporaryConstraint();\n"
<< "end;\n"
<< "\n"
<< "procedure resetTemporaryConstraint()$\n"
<< "begin;\n"
<< "  tmpConstraint__:= {};\n"
<< "  initTmpConstraint__:= {};\n"
<< "  tmpVariables__:= {};\n"
<< "  guard__:= {};\n"
<< "  guardVars__:= {};\n"
<< "end;\n"
<< "\n"
<< "procedure resetConstraintForParameter(pcons_, pars_)$\n"
<< "begin;\n"
<< "  pConstraint__:= {};\n"
<< "  parameters__:= {};\n"
<< "  addParameterConstraint(pcons_, pars_);\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure addParameterConstraint(pcons_, pars_)$\n"
<< "begin;\n"
<< "  debugWrite(\"in addParameterConstraint\", \" \");\n"
<< "\n"
<< "  pConstraint__ := union(pConstraint__, pcons_);\n"
<< "  parameters__ := union(parameters__, pars_);\n"
<< "  debugWrite(\"new pConstraint__: \", pConstraint__);\n"
<< "  debugWrite(\"new parameters__: \", parameters__);\n"
<< "\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "procedure addConstraint(cons_, vars_)$\n"
<< "begin;\n"
<< "\n"
<< "  debugWrite(\"in addConstraint\", \" \");\n"
<< "  debugWrite(\"cons_: \", cons_);\n"
<< "  debugWrite(\"vars_: \", vars_);\n"
<< "  debugWrite(\"prevConstraint__: \", prevConstraint__);\n"
<< "\n"
<< "  if(isTemporary__) then\n"
<< "  <<\n"
<< "    tmpVariables__:= union(tmpVariables__, vars_);\n"
<< "    tmpConstraint__:= union(tmpConstraint__, exSub(prevConstraint__, cons_));\n"
<< "  >> else\n"
<< "  <<\n"
<< "    variables__:= union(variables__, vars_);\n"
<< "    constraint__:= union(constraint__, exSub(prevConstraint__, cons_));\n"
<< "  >>;\n"
<< "\n"
<< "  debugWrite(\"variables__: \", variables__);\n"
<< "  debugWrite(\"constraint__: \", constraint__);\n"
<< "  debugWrite(\"tmpVariables__: \", tmpVariables__);\n"
<< "  debugWrite(\"tmpConstraint__: \", tmpConstraint__);\n"
<< "\n"
<< "  debugWrite(\"exSub(prevConstraint__, cons_): \", exSub(prevConstraint__, cons_));\n"
<< "  return if(isTemporary__) then tmpConstraint__ else constraint__;\n"
<< "end;\n"
<< "\n"
<< "procedure getConstraintStore()$\n"
<< "begin;\n"
<< "\n"
<< "  debugWrite(\"constraint__:\", constraint__);\n"
<< "  if(constraint__={}) then return {{}, pConstraint__};\n"
<< "\n"
<< "  \n"
<< "  \n"
<< "  if(head(first(constraint__))=list) then return {first(constraint__), pConstraint__}\n"
<< "  else return {constraint__, pConstraint__};\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "procedure checkLessThan(lhs_, rhs_)$\n"
<< "begin;\n"
<< "  scalar ret_;\n"
<< "\n"
<< "  ret_:= if(mymin(lhs_, rhs_) = lhs_) then rettrue___ else retfalse___;\n"
<< "  debugWrite(\"ans in checkLessThan: \", ret_);\n"
<< "\n"
<< "  return ret_;\n"
<< "end;\n"
<< "\n"
<< "procedure simplifyExpr(expr_)$\n"
<< "begin;\n"
<< "  scalar simplifiedExpr_;\n"
<< "\n"
<< "  \n"
<< "\n"
<< "  simplifiedExpr_:= expr_;\n"
<< "  debugWrite(\"simplifiedExpr_:\", simplifiedExpr_);\n"
<< "\n"
<< "  return simplifiedExpr_;\n"
<< "end;\n"
<< "\n"
<< "procedure exprTimeShift(expr_, time_)$\n"
<< "begin;\n"
<< "  scalar shiftedExpr_;\n"
<< "\n"
<< "  shiftedExpr_:= sub(t=t-time_, expr_);\n"
<< "  debugWrite(\"shiftedExpr_:\", shiftedExpr_);\n"
<< "\n"
<< "  return shiftedExpr_;\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure checkConsistencyPoint()$\n"
<< "  ansWrite(\"checkConsistencyPoint\",\n"
<< "           checkConsistencyPointMain(union(constraint__, tmpConstraint__, guard__, initConstraint__, initTmpConstraint__), \n"
<< "                                     pConstraint__, union(variables__, tmpVariables__, guardVars__)));\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure checkConsistencyPointMain(cons_, pCons_, vars_)$\n"
<< "begin;\n"
<< "  scalar eqExprs_, otherExprs_, modeFlagList_, mode_, tmpSol_,\n"
<< "         solvedExprs_, solvedExprsQE_, sol_, ans_;\n"
<< "\n"
<< "  debugWrite(\"checkConsistencyPointMain: \", \" \");\n"
<< "  debugWrite(\"{cons_, pCons_, vars_}: \", {cons_, pCons_, vars_});\n"
<< "\n"
<< "  \n"
<< "  if(cons_={}) then\n"
<< "    return ansWrite(\"checkConsistencyPointMain\", makeCCAnsMap(true, pCons_));\n"
<< "\n"
<< "  otherExprs_:= getOtherExpr(cons_);\n"
<< "  eqExprs_:= cons_ \\ otherExprs_;\n"
<< "\n"
<< "  \n"
<< "  off arbvars;\n"
<< "  tmpSol_:= exSolve(eqExprs_, vars_);\n"
<< "  on arbvars;\n"
<< "  debugWrite(\"tmpSol_: \", tmpSol_);\n"
<< "\n"
<< "  if(tmpSol_={}) then\n"
<< "    return ansWrite(\"checkConsistencyPointMain\", makeCCAnsMap(false, pCons_));\n"
<< "\n"
<< "  \n"
<< "  if(head(first(tmpSol_))=list) then tmpSol_:= first(tmpSol_);\n"
<< "\n"
<< "  \n"
<< "  if(otherExprs_={}) then\n"
<< "    return ansWrite(\"checkConsistencyPointMain\", makeCCAnsMap(rlqe(not isEmpty(tmpSol_)), pCons_));\n"
<< "\n"
<< "  \n"
<< "  solvedExprs_:= union(for each x in otherExprs_ join {exSub(tmpSol_, x)});\n"
<< "  debugWrite(\"solvedExprs_:\", solvedExprs_);\n"
<< "  solvedExprsQE_:= exRlqe(mymkand(solvedExprs_));\n"
<< "\n"
<< "  debugWrite(\"solvedExprsQE_:\", solvedExprsQE_);\n"
<< "  debugWrite(\"union(tmpSol_, solvedExprsQE_):\", union(tmpSol_, {solvedExprsQE_}));\n"
<< "\n"
<< "  sol_:= rlqe(mymkand(union(tmpSol_, {solvedExprsQE_})));\n"
<< "  ans_:= if(sol_ <> false) then return makeCCAnsMap(true, pCons_) else return makeCCAnsMap(false, pCons_);\n"
<< "\n"
<< "  return ansWrite(\"checkConsistencyPointMain\", ans_);\n"
<< "end;\n"
<< "\n"
<< "procedure applyPrevCons(csList_, retList_)$\n"
<< "begin;\n"
<< "  scalar firstCons_, newCsList_, ret_;\n"
<< "  if(csList_={}) then return retList_;\n"
<< "\n"
<< "  firstCons_:= first(csList_);\n"
<< "  if(not freeof(lhs(firstCons_), prev)) then <<\n"
<< "    newCsList_:= union(for each x in rest(csList_) join {exSub({firstCons_}, x)});\n"
<< "    ret_:= applyPrevCons(rest(csList_), retList_);\n"
<< "  >> else if(not freeof(rhs(firstCons_), prev)) then <<\n"
<< "    ret_:= applyPrevCons(cons(getReverseCons(firstCons_), rest(csList_)), retList_);\n"
<< "  >> else <<\n"
<< "    ret_:= applyPrevCons(rest(csList_), cons(firstCons_, retList_));\n"
<< "  >>;\n"
<< "  return ret_;\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure makeConsTuple(cons_)$\n"
<< "begin;\n"
<< "  scalar varName_, relopCode_, value_, tupleDNF_, retTuple_, adjustedCons_, sol_;\n"
<< "  debugWrite(\"in makeConsTuple: \", cons_);\n"
<< "  \n"
<< "  \n"
<< "  \n"
<< "  if(not hasIneqRelop(cons_)) then <<\n"
<< "    varName_:= lhs(cons_);\n"
<< "    relopCode_:= getExprCode(cons_);\n"
<< "    value_:= rhs(cons_);\n"
<< "  >> else <<\n"
<< "    tupleDNF_:= exIneqSolve(cons_);\n"
<< "    debugWrite(\"tupleDNF_: \", tupleDNF_);\n"
<< "    \n"
<< "    retTuple_:= first(first(tupleDNF_));\n"
<< "    \n"
<< "    varName_:= getVarNameFromTuple(retTuple_);\n"
<< "    relopCode_:= getExprCode(getRelopFromTuple(retTuple_));\n"
<< "    value_:= getValueFromTuple(retTuple_);\n"
<< "  >>;\n"
<< "  debugWrite(\"ans in makeConsTuple: \", {varName_, relopCode_, value_});\n"
<< "  return {varName_, relopCode_, value_};\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure makeDNFTuple(tDNF)$\n"
<< "begin;\n"
<< "  scalar tuple_;\n"
<< "  tuple_:= first(first(tDNF));\n"
<< "  return {getVarNameFromTuple(tuple_), getExprCode(getRelopFromTuple(tuple_)), getValueFromTuple(tuple_)};\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure hyroseRlStruct(cons_, vars_)$\n"
<< "begin;\n"
<< "  scalar ansFormula_, ansMap_, formulaList_, varsMap1_;\n"
<< "  debugWrite(\"{cons_, vars_}: \", {cons_, vars_});\n"
<< "  varsMap1_:= for i:= 1:length(vars_) collect part(vars_, i) = mkid(v,i);\n"
<< "  formulaList_:= map(exSub(varsMap1_, ~w), cons_);\n"
<< "\n"
<< "  ansFormula_:= mymkand formulaList_;\n"
<< "  ansMap_:= for i:= 1:length(vars_) collect mkid(v,i) = part(vars_, i);\n"
<< "  debugWrite(\"ans in hyroseRlStruct: \", {ansFormula_, ansMap_});\n"
<< "\n"
<< "  return {ansFormula_, ansMap_};\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure solveCS(cons_, vars_)$\n"
<< "begin;\n"
<< "  scalar ans_, structAns_, rationalisedCons_, equalities_, equalityVars_;\n"
<< "  scalar vAns_, formula, vVarsMap_, vVars_, varsExecptOne_;\n"
<< "  debugWrite(\"in solveCS\", \" \");\n"
<< "\n"
<< "  rationalisedCons_:= map(rationalise, cons_);\n"
<< "\n"
<< "  structAns_:= hyroseRlStruct(rationalisedCons_, removePrevCons vars_);\n"
<< "  formula:= first structAns_;\n"
<< "  vVarsMap_:= second structAns_;\n"
<< "\n"
<< "  \n"
<< "  vVars_:= map(lhs(~w), vVarsMap_);\n"
<< "  vAns_:= {};\n"
<< "  for each x in vVars_ do <<\n"
<< "    varsExecptOne_:= vVars_ \\ {x};\n"
<< "    vAns_:= vAns_ union {rlqe(ex(varsExecptOne_, formula))};\n"
<< "  >>;\n"
<< "\n"
<< "  \n"
<< "  vAns_:= expandAndToList(vAns_);\n"
<< "\n"
<< "  vAns_:= sub(vVarsMap_, vAns_);\n"
<< "  debugWrite(\"vAns_: \", vAns_);\n"
<< "\n"
<< "  \n"
<< "  equalities_:= for each x in vAns_ join if(head(x) = equal) then {x} else {};\n"
<< "  equalityVars_:= for each x in vars_ join if(not freeof(equalities_, x)) then {x} else {};\n"
<< "  ans_:= first solve(equalities_, equalityVars_);\n"
<< "  if(head ans_ <> list) then ans_:= {ans_};\n"
<< "  ans_:= for each x in ans_ join if(freeof(x, arbcomplex)) then {x} else {};\n"
<< "\n"
<< "  ans_:= ans_ union\n"
<< "    for each x in vAns_ join if(head(x) <> equal) then {x} else {};\n"
<< "\n"
<< "  debugWrite(\"ans in solveCS: \", ans_);\n"
<< "  return ans_;\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "procedure expandAndToList(expr_)$\n"
<< "begin;\n"
<< "  scalar expandExpr_;\n"
<< "  expandExpr_:= for each x in expr_ join if(head(x) = and) then getArgsList(x) else {x};\n"
<< "  if(expandExpr_ = expr_) then return expr_;\n"
<< "  return expandAndToList(expandExpr_);\n"
<< "end;\n"
<< "\n"
<< "procedure createVariableMap()$\n"
<< "begin;\n"
<< "  debugWrite(\"constraint__: \", constraint__);\n"
<< "\n"
<< "  return createVariableMapMain(union(constraint__, removePrevCons(initConstraint__)), variables__, pConstraint__);\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "procedure createVariableMapMain(cons_, vars_, pars_)$\n"
<< "begin;\n"
<< "  scalar removedVars_, solvedCons_, consTmpRet_, consRet_, paramDNFList_, paramRet_, tuple_, ret_;\n"
<< "\n"
<< "  debugWrite(\"=== in createVariableMapMain\", \" \");\n"
<< "  debugWrite(\"{cons_, vars_, pars_}: \", {cons_, vars_, pars_});\n"
<< "\n"
<< "  solvedCons_ := solveCS(cons_, vars_);\n"
<< "  consTmpRet_:= applyPrevCons(solvedCons_, {});\n"
<< "  debugWrite(\"consTmpRet_: \", consTmpRet_);\n"
<< "\n"
<< "  \n"
<< "  consRet_:= map(makeConsTuple, consTmpRet_);\n"
<< "  paramDNFList_:= map(exIneqSolve, pars_);\n"
<< "  paramRet_:= map(makeDNFTuple, paramDNFList_);\n"
<< "  ret_:= union(consRet_, paramRet_);\n"
<< "\n"
<< "  ret_:= getUsrVars(ret_, removePrevCons(vars_));\n"
<< "\n"
<< "  debugWrite(\"=== ans in createVariableMapMain: \", ret_);\n"
<< "  return ret_;\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure isInfZero(cons_, vars_)$\n"
<< "begin;\n"
<< "  scalar rationalisedCons_, structAns_, formula_, vVarsMap_, vAns_,\n"
<< "         equalities_, equalityVars_, ans_;\n"
<< "  debugWrite(\"in isInfZero\", \" \");\n"
<< "  debugWrite(\"{cons_, vars_}: \", {cons_, vars_});\n"
<< "  debugWrite(\"parameters__: \", parameters__);\n"
<< "\n"
<< "  rationalisedCons_:= map(rationalise, cons_);\n"
<< "\n"
<< "  structAns_:= hyroseRlStruct(union(rationalisedCons_, {t>0}), union(removePrevCons(vars_), parameters__));\n"
<< "  formula_:= first structAns_;\n"
<< "  debugWrite(\"formula_: \", formula_);\n"
<< "  vVarsMap_:= second structAns_;\n"
<< "  debugWrite(\"vVarsMap_: \", vVarsMap_);\n"
<< "\n"
<< "  \n"
<< "  vVars_:= map(lhs(~w), vVarsMap_);\n"
<< "  vAns_:= rlqe(ex(vVars_, formula_));\n"
<< "  debugWrite(\"vAns_: \", vAns_);\n"
<< "\n"
<< "  ans_:=\n"
<< "    if(vAns_ = false) then nil else\n"
<< "    if(filter(isTGreaterZero, expandAndToList({vAns_})) <> {}) then t else nil;\n"
<< "  return ansWrite(\"isInfZero\", ans_);\n"
<< "end;\n"
<< "\n"
<< "procedure isTGreaterZero(expr_)$\n"
<< "  if(expr_ = (t>0)) then t else nil;\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure makeCCAnsMap(expr_, pCons_)$\n"
<< "begin;\n"
<< "  scalar trueAns_, falseAns_, trueMap_, falseMap_;\n"
<< "  if(pCons_ = {}) then\n"
<< "    if(expr_ = true) then return {true, false}\n"
<< "    else return {false, true};\n"
<< "\n"
<< "  trueAns_:= rlqe(expr_ and mymkand(pCons_));\n"
<< "  falseAns_:= rlqe(not expr_ and mymkand(pCons_));\n"
<< "\n"
<< "  trueMap_:= if(head(trueAns_) = and) then map(makeConsTuple, getArgsList(trueAns_)) else trueAns_;\n"
<< "  falseMap_:= if(head(falseAns_) = and) then map(makeConsTuple, getArgsList(falseAns_)) else falseAns_;\n"
<< "\n"
<< "  return {trueMap_, falseMap_};\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "procedure checkConsistencyInterval()$\n"
<< "  ansWrite(\"checkConsistencyInterval\",\n"
<< "           checkConsistencyIntervalMain(union(constraint__, tmpConstraint__), guard__,\n"
<< "                                        union(initConstraint__, initTmpConstraint__), pConstraint__, \n"
<< "                                        union(variables__, tmpVariables__, guardVars__)));\n"
<< "\n"
<< "ICI_INCONSISTENT___:= 2;\n"
<< "\n"
<< "\n"
<< "procedure checkConsistencyIntervalMain(cons_, guardCons_, initCons_, pCons_, vars_)$\n"
<< "begin;\n"
<< "  scalar NDExprs_, otherExprs_, expandedGuard_,\n"
<< "         integratedSol_, exDSolveAns_, dfAnsExprs_, splitExprsResult_,\n"
<< "         initVars_, integratedVariableMap_, dfVariableMap_,\n"
<< "         cpTrue_, cpFalse_, trueMap_, falseMap_,\n"
<< "         subedGuardQE_, subedGuardEqualList_, ineqSolDNFList_, ineqSolDNF_, isInf_, ans_, testRet_;\n"
<< "\n"
<< "  debugWrite(\"{variables__, parameters__, initVariables__}: \", {variables__, parameters__, initVariables__});\n"
<< "  debugWrite(\"{cons_, guardCons_, initCons_, pCons_, vars_}: \", {cons_, guardCons_, initCons_, pCons_, vars_});\n"
<< "\n"
<< "  expandedGuard_:= expandAndToList(guardCons_);\n"
<< "  debugWrite(\"expandedGuard_: \", expandedGuard_);\n"
<< "\n"
<< "  \n"
<< "\n"
<< "  exDSolveAns_:= exDSolve(cons_, expandedGuard_, initCons_, vars_);\n"
<< "  \n"
<< "  if(exDSolveAns_ = retsolvererror___) then return ansWrite(\"checkConsistencyIntervalMain\", SOLVER_ERROR___);\n"
<< "  if(exDSolveAns_ = retoverconstraint___ or exDSolveAns_ = retunderconstraint___ or exDSolveAns_ = {}) then\n"
<< "    return ansWrite(\"checkConsistencyIntervalMain\", makeCCAnsMap(false, pCons_));\n"
<< "  \n"
<< "\n"
<< "  \n"
<< "\n"
<< "  initVars_:= map(getInitVars, initCons_);\n"
<< "  debugWrite(\"initVars_: \", initVars_);\n"
<< "\n"
<< "  dfVariableMap_:= first(foldLeft(createIntegratedValue, {{},second(exDSolveAns_)}, (vars_ \\ initVars_)));\n"
<< "\n"
<< "  debugWrite(\"dfVariableMap_:\", dfVariableMap_);\n"
<< "  dfAnsExprs_:= map((part(~w, 1)=part(~w, 2)), dfVariableMap_);\n"
<< "  debugWrite(\"dfAnsExprs_ from exDSolve: \", dfAnsExprs_);\n"
<< "\n"
<< "  \n"
<< "  splitExprsResult_ := splitExprs(removePrevCons(cons_), vars_);\n"
<< "  debugWrite(\"{NDExprs_, NDExprVars_, DExprs_, DExprVars_, otherExprs_}: \", splitExprsResult_);\n"
<< "  \n"
<< "\n"
<< "  \n"
<< "  NDExprs_ := part(splitExprsResult_, 1);\n"
<< "\n"
<< "  \n"
<< "  if(union(dfAnsExprs_, NDExprs_) neq {}) then <<\n"
<< "    solveAns_:= solve(union(dfAnsExprs_, NDExprs_), (vars_ \\ initVars_));\n"
<< "    debugWrite(\"solveAns_ after solve with NDExpr_: \", solveAns_);\n"
<< "    if(solveAns_ = {}) then return ansWrite(\"checkConsistencyIntervalMain\", makeCCAnsMap(false, pCons_));\n"
<< "  >>;\n"
<< "\n"
<< "  \n"
<< "  if(expandedGuard_ = {}) then return ansWrite(\"checkConsistencyIntervalMain\", makeCCAnsMap(true, pCons_));\n"
<< "\n"
<< "  \n"
<< "\n"
<< "  integratedVariableMap_:= first(foldLeft(createIntegratedValue, {{},solveAns_}, removePrevCons(vars_ \\ initVars_)));\n"
<< "  integratedSol_:= map((first(~w)=second(~w)), integratedVariableMap_);\n"
<< "  debugWrite(\"integratedSol_:\", integratedSol_);\n"
<< "\n"
<< "  tCons_:= first(exDSolveAns_);\n"
<< "  if(tCons_ = {}) then tCons_:= {true};\n"
<< "  tCons_:= exSub(integratedSol_, tCons_);\n"
<< "  debugWrite(\"tCons_: \", tCons_);\n"
<< "\n"
<< "  if(isInfZero(union(tCons_, pCons_), vars_)) then\n"
<< "    return ansWrite(\"checkConsistencyIntervalMain\", makeCCAnsMap(true, pCons_))\n"
<< "  else return ansWrite(\"checkConsistencyIntervalMain\", makeCCAnsMap(false, pCons_));\n"
<< "\n"
<< "  \n"
<< "\n"
<< "  \n"
<< "  trueMap_:= makeDNFList(cpTrue_);\n"
<< "\n"
<< "  \n"
<< "  ans_:=\n"
<< "    if(not hasParameter(trueMap_)) then\n"
<< "      if(isTrueDNF(trueMap_)) then       makeCCAnsMap(true, pCons_)\n"
<< "      else if(isFalseDNF(trueMap_)) then makeCCAnsMap(false, pCons_)\n"
<< "      else <<\n"
<< "        isInf_:= checkInfUnitDNF(trueMap_);\n"
<< "        if(isInf_=true) then                    makeCCAnsMap(true, pCons_)\n"
<< "        else                                    makeCCAnsMap(false, pCons_)\n"
<< "      >>\n"
<< "    else {map(makeDNFTuple, trueMap_), false};\n"
<< "    \n"
<< "\n"
<< "  return ansWrite(\"checkConsistencyIntervalMain\", ans_);\n"
<< "end;\n"
<< "\n"
<< "procedure makeDNFList(formula_)$\n"
<< "begin;\n"
<< "  scalar ans_, ineqSolDNF_;\n"
<< "  debugWrite(\"makeDNFList_: \", formula_);\n"
<< "  ans_:=\n"
<< "    union(for each x in formula_ collect <<\n"
<< "      ineqSolDNF_:= exIneqSolve(x);\n"
<< "      if(isFalseDNF(ineqSolDNF_)) then {{}}\n"
<< "      else if(isTrueDNF(ineqSolDNF_)) then {{true}}\n"
<< "      else ineqSolDNF_\n"
<< "    >>);\n"
<< "\n"
<< "  ans_:= simplifyDNFList(ans_);\n"
<< "  return ansWrite(\"makeDNFList_\", ans_);\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure simplifyDNFList(formula_)$\n"
<< "begin;\n"
<< "  scalar ans_;\n"
<< "  debugWrite(\"simplifyDNFList: \", formula_);\n"
<< "\n"
<< "  ans_:= filterNot(isTrueDNF, formula_);\n"
<< "  if(ans_ = {}) then ans:= {{{true}}};\n"
<< "\n"
<< "  return ansWrite(\"simplifyDNFList\", ans_);\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure checkInfUnitDNF(tDNF_)$\n"
<< "begin;\n"
<< "  scalar conj_, infCheckAns_, orArgsAnsList_, lbTupleList_, lbTuple_;\n"
<< "  debugWrite(\"in checkInfUnitDNF: \", tDNF_);\n"
<< "\n"
<< "  conj_:= first(tDNF_);\n"
<< "  if(length(tDNF_)>1) then <<\n"
<< "    orArgsAnsList_:= union(for i:=1 : length(tDNF_) collect\n"
<< "      checkInfUnitDNF({part(tDNF_, 1)}));\n"
<< "    debugWrite(\"orArgsAnsList_: \", orArgsAnsList_);\n"
<< "    infCheckAns_:= if(orArgsAnsList_={false}) then false else true;\n"
<< "  >> else if(isEqualConj(conj_)) then <<\n"
<< "    \n"
<< "    infCheckAns_:= false;\n"
<< "  >> else <<\n"
<< "    lbTupleList_:= getLbTupleListFromConj(conj_);\n"
<< "    \n"
<< "    \n"
<< "    lbTuple_:= first(lbTupleList_);\n"
<< "    if((getRelopFromTuple(lbTuple_)=greaterp) and (getValueFromTuple(lbTuple_)=0)) then \n"
<< "      infCheckAns_:= true\n"
<< "    else infCheckAns_:= false;\n"
<< "  >>;\n"
<< "\n"
<< "  return ansWrite(\"checkInfUnitDNF\", infCheckAns_);\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "procedure checkInfMinTimeDNF(tDNF_, condDNF_)$\n"
<< "begin;\n"
<< "  scalar minTCList_, conj_, argsAnsTCListList_, minValue_, compareTCListList_, lbTupleList_, ubTupleList_,\n"
<< "         lbParamTupleList_, ubParamTupleList_, lbValueTupleList_, ubValueTupleList_, lbValue_, ubValue_, \n"
<< "         paramLeqValueCondDNF_, paramGreaterValueCondDNF_, checkDNF_, diffCondDNF_;\n"
<< "  debugWrite(\"=== in checkInfMinTimeDNF\", \" \");\n"
<< "  debugWrite(\"{tDNF_, condDNF_}\", {tDNF_, condDNF_});\n"
<< "\n"
<< "  conj_:= first(tDNF_);\n"
<< "  if(length(tDNF_)>1) then <<\n"
<< "    argsAnsTCListList_:= union(for i:=1 : length(tDNF_) collect\n"
<< "      checkInfMinTimeDNF({part(tDNF_, i)}, condDNF_));\n"
<< "    debugWrite(\"argsAnsTCListList_: \", argsAnsTCListList_);\n"
<< "    minTCList_:= foldLeft(compareMinTimeList, first(argsAnsTCListList_), rest(argsAnsTCListList_));\n"
<< "  >> else if(isEqualConj(conj_)) then <<\n"
<< "    \n"
<< "    if(not hasParameter(conj_)) then minTCList_:= {{getValueFromTuple(first(conj_)), condDNF_}}\n"
<< "    else <<\n"
<< "      \n"
<< "      minValue_:= getValueFromTuple(first(conj_));\n"
<< "      checkDNF_:= addCondTupleToCondDNF({minValue_, greaterp, 0}, condDNF_);\n"
<< "      debugWrite(\"checkDNF_: \", checkDNF_);\n"
<< "      if(not isFalseDNF(checkDNF_)) then << \n"
<< "        if(isSameDNF(checkDNF_, condDNF_)) then <<\n"
<< "          minTCList_:= {{minValue_, checkDNF_}};\n"
<< "        >> else <<\n"
<< "          diffCondDNF_:= addCondDNFToCondDNF(getNotDNF(checkDNF_), condDNF_);\n"
<< "          debugWrite(\"diffCondDNF_: \", diffCondDNF_);\n"
<< "          minTCList_:= {{minValue_, checkDNF_}, {INFINITY, diffCondDNF_}};\n"
<< "        >>;\n"
<< "      >> else <<\n"
<< "        minTCList_:= {{INFINITY, condDNF_}};\n"
<< "      >>;\n"
<< "    >>;\n"
<< "  >> else <<\n"
<< "    if(not hasParameter(conj_)) then minTCList_:= {{getValueFromTuple(first(getLbTupleListFromConj(conj_))), condDNF_}}\n"
<< "    else << \n"
<< "      \n"
<< "      \n"
<< "      lbTupleList_:= getLbTupleListFromConj(conj_);\n"
<< "      ubTupleList_:= conj_ \\ lbTupleList_;\n"
<< "      lbParamTupleList_:= filter(hasParameter, lbTupleList_);\n"
<< "      ubParamTupleList_:= filter(hasParameter, ubTupleList_);\n"
<< "      lbValueTupleList_:= lbTupleList_ \\ lbParamTupleList_;\n"
<< "      ubValueTupleList_:= ubTupleList_ \\ ubParamTupleList_;\n"
<< "      if(lbValueTupleList_={}) then lbValueTupleList_:= {{t, geq, -INFINITY}};\n"
<< "      if(ubValueTupleList_={}) then ubValueTupleList_:= {{t, leq,  INFINITY}};\n"
<< "      lbValue_:= getValueFromTuple(first(lbValueTupleList_));\n"
<< "      ubValue_:= getValueFromTuple(first(ubValueTupleList_));\n"
<< "\n"
<< "\n"
<< "      minTCList_:= {};\n"
<< "      \n"
<< "      \n"
<< "      debugWrite(\"lbParamTupleList_: \", lbParamTupleList_);\n"
<< "      debugWrite(\"lbValue_: \", lbValue_);\n"
<< "\n"
<< "      debugWrite(\"========== check param-lb ==========\", \" \");\n"
<< "      for each x in lbParamTupleList_ do <<\n"
<< "        debugWrite(\"x (lbParamTuple): \", x);\n"
<< "        checkDNF_:= addCondTupleToCondDNF({getValueFromTuple(x), greaterp, lbValue_}, condDNF_);\n"
<< "        debugWrite(\"checkDNF_: \", checkDNF_);\n"
<< "        if(not isFalseDNF(checkDNF_)) then <<\n"
<< "          if(isSameDNF(checkDNF_, condDNF_)) then <<\n"
<< "            minTCList_:= cons({getValueFromTuple(x), checkDNF_}, minTCList_);\n"
<< "          >> else <<\n"
<< "            diffCondDNF_:= addCondDNFToCondDNF(getNotDNF(checkDNF_), condDNF_);\n"
<< "            debugWrite(\"diffCondDNF_: \", diffCondDNF_);\n"
<< "            if(checkOrderingFormula(lbValue_ >0)) then <<\n"
<< "              minTCList_:= cons({getValueFromTuple(x), checkDNF_}, cons({lbValue_, diffCondDNF_}, minTCList_));\n"
<< "            >> else <<\n"
<< "              minTCList_:= cons({getValueFromTuple(x), checkDNF_}, cons({INFINITY, diffCondDNF_}, minTCList_));\n"
<< "            >>;\n"
<< "          >>;\n"
<< "          debugWrite(\"minTCList_: \", minTCList_);\n"
<< "        >>;\n"
<< "      >>;\n"
<< "      debugWrite(\"minTCList_ after add: \", minTCList_);\n"
<< "\n"
<< "\n"
<< "      debugWrite(\"========== check param-ub ==========\", \" \");\n"
<< "      \n"
<< "      debugWrite(\"ubParamTupleList_: \", ubParamTupleList_);\n"
<< "      if(minTCList_ neq {}) then <<\n"
<< "        for each x in ubParamTupleList_ do <<\n"
<< "          minTCList_:= union(for each y in minTCList_ join <<\n"
<< "            if(getTimeFromTC(y) neq INFINITY) then <<\n"
<< "              checkDNF_:= addCondTupleToCondDNF({getValueFromTuple(x), geq, getTimeFromTC(y)}, getCondDNFFromTC(y));\n"
<< "              debugWrite(\"checkDNF_: \", checkDNF_);\n"
<< "              if(not isFalseDNF(checkDNF_)) then {y} else {}\n"
<< "            >> else <<\n"
<< "              \n"
<< "              {y}\n"
<< "            >>\n"
<< "          >>);\n"
<< "        >>;\n"
<< "        if(minTCList_={}) then minTCList_:= {{INFINITY, condDNF_}};\n"
<< "      >> else <<\n"
<< "        \n"
<< "        for each x in ubParamTupleList_ do <<\n"
<< "          checkDNF_:= addCondTupleToCondDNF({getValueFromTuple(x), geq, lbValue_}, condDNF_);\n"
<< "          if(not isFalseDNF(checkDNF_) and checkOrderingFormula(lbValue_ >0)) then minTCList_:= {{lbValue_, condDNF_}}\n"
<< "          else minTCList_:= {{INFINITY, condDNF_}};\n"
<< "        >>;\n"
<< "      >>;\n"
<< "    >>;\n"
<< "  >>;\n"
<< "\n"
<< "  debugWrite(\"{(tDNF_), (condDNF_)}: \", {tDNF_, condDNF_});\n"
<< "  debugWrite(\"ans in checkInfMinTimeDNF: \", minTCList_);\n"
<< "  return minTCList_;\n"
<< "end;\n"
<< "\n"
<< "IC_SOLVER_ERROR___:= 0;\n"
<< "IC_NORMAL_END___:= 1;\n"
<< "\n"
<< "\n"
<< "procedure createIntegratedValue(pairInfo_, variable_)$\n"
<< "begin;\n"
<< "  scalar retList_, integRule_, integExpr_, newRetList_;\n"
<< "\n"
<< "  retList_:= first(pairInfo_);\n"
<< "  integRule_:= second(pairInfo_);\n"
<< "\n"
<< "  integExpr_:= {variable_, sub(integRule_, variable_)};\n"
<< "\n"
<< "  newRetList_:= cons(integExpr_, retList_);\n"
<< "\n"
<< "  return {newRetList_, integRule_};\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "procedure calculateNextPointPhaseTime(maxTime_, discCause_);\n"
<< "begin;\n"
<< "  scalar ans_;\n"
<< "\n"
<< "  ans_:= calculateNextPointPhaseTimeMain(maxTime_, discCause_, constraint__, initConstraint__, pConstraint__, variables__);\n"
<< "  debugWrite(\"ans_ in calculateNextPointPhaseTime:\", ans_);\n"
<< "  return ans_;\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure calculateNextPointPhaseTimeMain(maxTime_, discCause_, cons_, initCons_, pCons_, vars_);\n"
<< "begin;\n"
<< "  scalar splitExprsResult_, NDExprs_, NDExprVars_, DExprs_, DExprVars_, otherExprs_,\n"
<< "         discCauseList_, condDNF_, minTCondListList_, comparedMinTCondList_, \n"
<< "         tmpMinTList_, tmpIneqSolDNF_, minTTime_, minTCondDNF_, maxTimeFlag_;\n"
<< "\n"
<< "  debugWrite(\"=== in calculateNextPointPhaseTimeMain\", \" \");\n"
<< "\n"
<< "  \n"
<< "  debugWrite(\"{maxTime_ ,discCause_, cons_, initCons_, pCons_, vars_}: \", {maxTime_ ,discCause_, cons_, initCons_, pCons_, vars_});\n"
<< "  debugWrite(\"{variables__, parameters__}: \", {variables__, parameters__});\n"
<< "\n"
<< "  splitExprsResult_ := splitExprs(removePrevCons(cons_), vars_);\n"
<< "  NDExprs_ := part(splitExprsResult_, 1);\n"
<< "  NDExprVars_ := part(splitExprsResult_, 2);\n"
<< "  DExprs_ := part(splitExprsResult_, 3);\n"
<< "  DExprVars_ := part(splitExprsResult_, 4);\n"
<< "  otherExprs_:= union(part(splitExprsResult_, 5), pCons_);\n"
<< "  \n"
<< "  \n"
<< "  if(otherExprs_={}) then condDNF_:= {{true}}\n"
<< "  else <<\n"
<< "    \n"
<< "    tmpIneqSolDNF_:= {{true}};\n"
<< "    for i:=1 : length(otherExprs_) do <<\n"
<< "      tmpIneqSolDNF_:= addCondDNFToCondDNF(tmpIneqSolDNF_, exIneqSolve(part(otherExprs_, i)));\n"
<< "    >>;\n"
<< "    condDNF_:= tmpIneqSolDNF_;\n"
<< "  >>;\n"
<< "\n"
<< "  \n"
<< "  discCauseList_:= union(sub(cons_, discCause_));\n"
<< "\n"
<< "  \n"
<< "  debugWrite(\"discCauseList_:\", discCauseList_);\n"
<< "  debugWrite(\"condDNF_: \", condDNF_);\n"
<< "\n"
<< "  minTCondListList_:= map(findMinTime(~w, condDNF_), discCauseList_);\n"
<< "  debugWrite(\"minTCondListList_ in calcNextPointPhaseTime: \", minTCondListList_);\n"
<< "\n"
<< "  if(not freeof(minTCondListList_, error)) then return {error};\n"
<< "\n"
<< "  comparedMinTCondList_:= foldLeft(compareMinTimeList, {{maxTime_, condDNF_}}, minTCondListList_);\n"
<< "  debugWrite(\"comparedMinTCondList_ in calcNextPointPhaseTime: \", comparedMinTCondList_);\n"
<< "\n"
<< "  tmpMinTList_:= union(\n"
<< "    for each x in comparedMinTCondList_ collect <<\n"
<< "      minTTime_:= getTimeFromTC(x);\n"
<< "      minTCondDNF_:= getCondDNFFromTC(x);\n"
<< "      \n"
<< "      if(isTrueDNF(minTCondDNF_)) then minTCondDNF_:= {{}};\n"
<< "      \n"
<< "      \n"
<< "      minTCondDNF_:= for each conj in minTCondDNF_ collect\n"
<< "        map({getVarNameFromTuple(~w), getExprCode(getRelopFromTuple(~w)), getValueFromTuple(~w)}, conj);\n"
<< "      maxTimeFlag_:= if(minTTime_ neq maxTime_) then 0 else 1;\n"
<< "      {minTTime_, minTCondDNF_, maxTimeFlag_}\n"
<< "    >>\n"
<< "  );\n"
<< "  debugWrite(\"=== ans in calculateNextPointPhaseTimeMain: \", tmpMinTList_);\n"
<< "\n"
<< "  return tmpMinTList_;\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure FixAndFormula(formula_)$\n"
<< "begin;\n"
<< "  scalar ans_, ansList_;\n"
<< "  if(head(formula_)=and) then <<\n"
<< "    ans_:= true;\n"
<< "    for each x in getArgsList(formula_) do <<\n"
<< "      ans_:= mymkand({ans_, FixAndFormula(x)});\n"
<< "    >>;\n"
<< "  >> else <<\n"
<< "    ans_:= formula_;\n"
<< "  >>;\n"
<< "\n"
<< "  if(head(ans_) = and) then <<\n"
<< "    ansList_:= for each x in getArgsList(ans_) join\n"
<< "      if(x <> true) then {x} else {};\n"
<< "    ans_:= myApply(and, ansList_);\n"
<< "  >>;\n"
<< "\n"
<< "  debugWrite(\"ans in FixAndFormula: \", ans_);\n"
<< "  return ans_;\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure findMinTime(integAsk_, condDNF_)$\n"
<< "begin;\n"
<< "  scalar integAskQE_, integAskList_, integAskIneqSolDNFList_, integAskIneqSolDNF_,\n"
<< "         minTCList_, tmpSol_, ineqSolDNF_;\n"
<< "\n"
<< "  debugWrite(\"=== in findMinTime\", \" \");\n"
<< "  debugWrite(\"integAsk_: \", integAsk_);\n"
<< "  debugWrite(\"condDNF_: \", condDNF_);\n"
<< "\n"
<< "  \n"
<< "  if(rlqe(integAsk_ and t>0) = false) then return ansWrite(\"findMinTime\", {{INFINITY, condDNF_}});\n"
<< "\n"
<< "  \n"
<< "  integAsk_ := FixAndFormula(integAsk_);\n"
<< "\n"
<< "  \n"
<< "  \n"
<< "  integAskList_:= if(head(integAsk_)=and) then <<\n"
<< "    union(for each x in getArgsList(integAsk_) join <<\n"
<< "      integAskQE_:= rlqe(x);\n"
<< "      if(integAskQE_=true) then {error}\n"
<< "      else if(integAskQE_=false) then {false}\n"
<< "      else {x}\n"
<< "    >>)\n"
<< "  >> else <<\n"
<< "    integAskQE_:= rlqe(integAsk_);\n"
<< "    if(integAskQE_=true) then {error}\n"
<< "    else if(integAskQE_=false) then {false}\n"
<< "    else {integAsk_}\n"
<< "  >>;\n"
<< "  debugWrite(\"integAskList_: \", integAskList_);\n"
<< "\n"
<< "  \n"
<< "  if(integAskList_={error} or not freeof(integAskList_, false)) then return ansWrite(\"findMinTime\", {error});\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "  integAskIneqSolDNFList_:= union(for each x in integAskList_ collect\n"
<< "                              if(not isIneqRelop(head(x))) then <<\n"
<< "                                tmpSol_:= exSolve(x, t);\n"
<< "                                if(length(tmpSol_)>1) then for each y in tmpSol_ join makeTupleDNFFromEq(lhs(y), rhs(y))\n"
<< "                                else if(length(tmpSol_)=0) then {}\n"
<< "                                else makeTupleDNFFromEq(lhs(first(tmpSol_)), rhs(first(tmpSol_)))\n"
<< "                              >> else <<\n"
<< "                                ineqSolDNF_:= exIneqSolve(x);\n"
<< "                                debugWrite(\"ineqSolDNF_: \", ineqSolDNF_);\n"
<< "                                if(isFalseDNF(ineqSolDNF_)) then {{}}\n"
<< "                                else if(isTrueDNF(ineqSolDNF_)) then {{error}} \n"
<< "                                else ineqSolDNF_\n"
<< "                              >>\n"
<< "                            );\n"
<< "  debugWrite(\"integAskIneqSolDNFList_:\", integAskIneqSolDNFList_);\n"
<< "  \n"
<< "  \n"
<< "  if(not freeof(integAskIneqSolDNFList_, unknown)) then return ansWrite(\"findMinTime\", {error})\n"
<< "  \n"
<< "  else if(not freeof(integAskIneqSolDNFList_, error)) then return ansWrite(\"findMinTime\", {error});\n"
<< "\n"
<< "\n"
<< "  debugWrite(\"findMinTime: add t>0\", \" \");\n"
<< "  integAskIneqSolDNF_:= foldLeft(addCondDNFToCondDNF, {{{t, greaterp, 0}}}, integAskIneqSolDNFList_);\n"
<< "  debugWrite(\"findMinTime: end add t>0\", \" \");\n"
<< "  debugWrite(\"integAskIneqSolDNF_:\", integAskIneqSolDNF_);\n"
<< "\n"
<< "  \n"
<< "  if(isFalseDNF(integAskIneqSolDNF_)) then return ansWrite(\"findMinTime\", {{INFINITY, condDNF_}});\n"
<< "\n"
<< "  \n"
<< "\n"
<< "\n"
<< "  minTCList_:= checkInfMinTimeDNF(integAskIneqSolDNF_, condDNF_);\n"
<< "  debugWrite(\"minTCList_ in findMinTime: \", minTCList_);\n"
<< "  debugWrite(\"=================== end of findMinTime ====================\", \" \");\n"
<< "\n"
<< "  \n"
<< "  if(not freeof(minTCList_, ERROR)) then return ansWrite(\"findMinTime\", {error});\n"
<< "  return ansWrite(\"findMinTime\", minTCList_);\n"
<< "end;\n"
<< "\n"
<< "procedure compareMinTimeList(candidateTCList_, newTCList_)$\n"
<< "begin;\n"
<< "  scalar tmpRet_, arg2_, arg3_, ret_;\n"
<< "\n"
<< "  debugWrite(\"=== in compareMinTimeList\", \" \");\n"
<< "  debugWrite(\"{candidateTCList_, newTCList_}: \", {candidateTCList_, newTCList_});\n"
<< "\n"
<< "  \n"
<< "  tmpRet_:= {};\n"
<< "  for i:=1 : length(newTCList_) do <<\n"
<< "    debugWrite(\"loop count: \", i);\n"
<< "    debugWrite(\"tmpRet_: \", tmpRet_);\n"
<< "    arg2_:= tmpRet_;\n"
<< "    arg3_:= part(newTCList_, i);\n"
<< "    tmpRet_:= makeMapAndUnion(candidateTCList_, arg2_, arg3_);\n"
<< "    debugWrite(\"{i, arg2_, arg3_}: \", {i, arg2_, arg3_});\n"
<< "    debugWrite(\"tmpRet_ after makeMapAndUnion: \", tmpRet_);\n"
<< "  >>;\n"
<< "  ret_:= tmpRet_;\n"
<< "\n"
<< "  debugWrite(\"ans in compareMinTimeList: \", ret_);\n"
<< "  return ret_;\n"
<< "end;\n"
<< "\n"
<< "procedure makeMapAndUnion(candidateTCList_, retTCList_, newTC_)$\n"
<< "begin;\n"
<< "  scalar comparedList_, ret_;\n"
<< "\n"
<< "  debugWrite(\"in makeMapAndUnion\", \" \");\n"
<< "  debugWrite(\"{candidateTCList_, retTCList_, newTC_}: \", {candidateTCList_, retTCList_, newTC_});\n"
<< "\n"
<< "  \n"
<< "  comparedList_:= for each x in candidateTCList_ join compareParamTime(newTC_, x, MIN);\n"
<< "  debugWrite(\"comparedList_ in makeMapAndUnion: \", comparedList_);\n"
<< "  ret_:= union(comparedList_, retTCList_);\n"
<< "\n"
<< "  debugWrite(\"ans in makeMapAndUnion: \", ret_);\n"
<< "  return ret_;\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "procedure compareParamTime(TC1_, TC2_, mode_)$\n"
<< "begin;\n"
<< "  scalar TC1Time_, TC1Cond_, TC2Time_, TC2Cond_,\n"
<< "         intersectionCondDNF_, TC1LessTC2CondDNF_, TC1GeqTC2CondDNF_,\n"
<< "         retTCList_;\n"
<< "\n"
<< "  debugWrite(\"in compareParamTime\", \" \");\n"
<< "  debugWrite(\"{TC1_, TC2_, mode_}: \", {TC1_, TC2_, mode_});\n"
<< "\n"
<< "  TC1Time_:= getTimeFromTC(TC1_);\n"
<< "  TC1Cond_:= getCondDNFFromTC(TC1_);\n"
<< "  TC2Time_:= getTimeFromTC(TC2_);\n"
<< "  TC2Cond_:= getCondDNFFromTC(TC2_);\n"
<< "\n"
<< "\n"
<< "  \n"
<< "  intersectionCondDNF_:= addCondDNFToCondDNF(TC1Cond_, TC2Cond_);\n"
<< "  debugWrite(\"intersectionCondDNF_: \", intersectionCondDNF_);\n"
<< "  if(isFalseDNF(intersectionCondDNF_)) then return {};\n"
<< "\n"
<< "  if(TC1Time_ = infinity) then return {{TC2Time_, intersectionCondDNF_}};\n"
<< "  if(TC2Time_ = infinity) then return {{TC1Time_, intersectionCondDNF_}};\n"
<< "\n"
<< "  \n"
<< "  \n"
<< "  debugWrite(\"========== make TC1LessTC2CondDNF_ ==========\", \" \");\n"
<< "  TC1LessTC2CondDNF_:= addCondTupleToCondDNF({TC1Time_, lessp, TC2Time_}, intersectionCondDNF_);\n"
<< "  debugWrite(\"TC1LessTC2CondDNF_: \", TC1LessTC2CondDNF_);\n"
<< "  \n"
<< "  debugWrite(\"========== make TC1GeqTC2CondDNF_ ==========\", \" \");\n"
<< "  TC1GeqTC2CondDNF_:= addCondTupleToCondDNF({TC1Time_, geq, TC2Time_}, intersectionCondDNF_);\n"
<< "  debugWrite(\"TC1GeqTC2CondDNF_: \", TC1GeqTC2CondDNF_);\n"
<< "\n"
<< "\n"
<< "  retTCList_:= {};\n"
<< "  \n"
<< "  if(not isFalseDNF(TC1LessTC2CondDNF_)) then \n"
<< "    if(mode_=MIN) then retTCList_:= cons({TC1Time_, TC1LessTC2CondDNF_}, retTCList_)\n"
<< "    else if(mode_=MAX) then retTCList_:= cons({TC2Time_, TC1LessTC2CondDNF_}, retTCList_);\n"
<< "  if(not isFalseDNF(TC1GeqTC2CondDNF_)) then \n"
<< "    if(mode_=MIN) then retTCList_:= cons({TC2Time_, TC1GeqTC2CondDNF_}, retTCList_)\n"
<< "    else if(mode_=MAX) then retTCList_:= cons({TC1Time_, TC1GeqTC2CondDNF_}, retTCList_);\n"
<< "\n"
<< "  debugWrite(\"ans in compareParamTime: \", retTCList_);\n"
<< "  return retTCList_;\n"
<< "end;\n"
<< "\n"
<< "defaultPrec_ := 0;\n"
<< "\n"
<< "\n"
<< "procedure applyTime2Expr(expr_, time_)$\n"
<< "  ansWrite(\"applyTime2Expr\", {1, sub(t=time_, expr_)});\n"
<< "\n"
<< "procedure createVariableMapInterval()$\n"
<< "  createVariableMapIntervalMain(constraint__, initConstraint__, variables__, parameters__);\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure createVariableMapIntervalMain(cons_, initCons_, vars_, pars_)$\n"
<< "begin;\n"
<< "  scalar solvedRet_, consTmpRet_, consRet_, paramDNFList_, paramRet_, tuple_, ret_;\n"
<< "  scalar tmpCons_, rconts_;\n"
<< "  scalar exDSolveAns_, tmpVarSol_,\n"
<< "         subedInitCons_, initVars_, prevVars_, noPrevVars_, tmpVarMap_,\n"
<< "         DExprRconts_;\n"
<< "\n"
<< "  debugWrite(\"=== in createVariableMapIntervalMain\", \" \");\n"
<< "  debugWrite(\"{cons_, initCons_, vars_, pars_}: \", {cons_, initCons_, vars_, pars_});\n"
<< "\n"
<< "  tmpCons_ := for each x in initCons_ join if(isInitVariable(lhs x)) then {} else {x};\n"
<< "  if(tmpCons_ neq {}) then return {SOLVER_ERROR___};\n"
<< "  rconts_ := for each x in initCons_ join if(isInitVariable(lhs x)) then {x} else {};\n"
<< "  \n"
<< "  DExprRconts_:= removeInitCons(rconts_);\n"
<< "  if(DExprRconts_ neq {}) then <<\n"
<< "    prevVars_:= for each x in vars_ join if(isPrevVariable(x)) then {x} else {};\n"
<< "    noPrevVars_:= map(first(~w), prevVars_);\n"
<< "  >>;\n"
<< "\n"
<< "  subedInitCons_:= map(exSub(cons_, ~w), (rconts_ \\ DExprRconts_));\n"
<< "  initVars_:= map(getInitVars, subedInitCons_);\n"
<< "\n"
<< "  exDSolveAns_:= exDSolve(cons_, {}, subedInitCons_, vars_);\n"
<< "  debugWrite(\"exDSolveAns_ solved with exDSolve: \", exDSolveAns_);\n"
<< " \n"
<< "  if(exDSolveAns_ = retsolvererror___) then return {SOLVER_ERROR___}\n"
<< "  else if(exDSolveAns_ = retoverconstraint___) then return {ICI_INCONSISTENT___};\n"
<< "\n"
<< "  tmpVarMap_:= first(foldLeft(createIntegratedValue, {{},second(exDSolveAns_)}, (vars_ \\ initVars_)));\n"
<< "  tmpVarSol_:= map((first(~w)=second(~w)), tmpVarMap_);\n"
<< "  consTmpRet_:= applyPrevCons(union(cons_, tmpVarSol_), {});\n"
<< "  debugWrite(\"consTmpRet_: \", consTmpRet_);\n"
<< "\n"
<< "  \n"
<< "  solvedRet_:= solveCS(consTmpRet_, vars_);\n"
<< "\n"
<< "  \n"
<< "  consRet_:= map(makeConsTuple, solvedRet_);\n"
<< "  paramDNFList_:= map(exIneqSolve, pConstraint__);\n"
<< "  paramRet_:= map(makeDNFTuple, paramDNFList_);\n"
<< "  ret_:= union(consRet_, paramRet_);\n"
<< "\n"
<< "  ret_:= getUsrVars(ret_, removePrevCons(vars_ \\ initVars_));\n"
<< "\n"
<< "  debugWrite(\"=== ans in createVariableMapIntervalMain: \", ret_);\n"
<< "  return ret_;\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure getUsrVars(ret_, vars_);\n"
<< "  for each x in ret_ join if(contains(vars_, first x)) then {x} else {}; \n"
<< "\n"
<< "procedure contains(vars_, var_);\n"
<< "  if((for each x in vars_ sum if(x = var_) then 1 else 0) > 0) then t else nil;\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure debugWrite(arg1_, arg2_)$\n"
<< "  if(optUseDebugPrint__) then write(arg1_, arg2_);\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure ansWrite(funcName_, ans_)$\n"
<< "  if(optUseDebugPrint__) then <<\n"
<< "    write(\"ans in \", funcName_, \": \", ans_);\n"
<< "    ans_\n"
<< "  >> else ans_;\n"
<< "\n"
<< "\n"
<< "\n"
<< "symbolic procedure redeval(foo_)$\n"
<< "begin scalar ans_;\n"
<< "\n"
<< "  debugWrite(\"<redeval> reval :\", (car foo_));\n"
<< "  ans_:= (reval foo_);\n"
<< "  putLineFeed();\n"
<< "  write(\"<redeval> end:\");\n"
<< "\n"
<< "  return ans_;\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "procedure putLineFeed()$\n"
<< "begin;\n"
<< "  write(\"\");\n"
<< "end;\n"
<< "\n"
<< "\n"
<< "\n"
<< "symbolic redeval '(resetConstraint);\n"
<< "\n"
<< "\n"
<< ";end;";

  return s.str(); 
}