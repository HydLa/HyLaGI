#include "math_source.h"

namespace hydla{
namespace backend{
namespace mathematica{
const char* math_source() {
  return 
"\n"
"\n"
"$RecursionLimit = 1000;\n"
"$MaxExtraPrecision = 1000;\n"
"\n"
"\n"
"\n"
"\n"
"variables = {};\n"
"prevVariables = {};\n"
"timeVariables = {};\n"
"initVariables = {};\n"
"parameters = {};\n"
"dList = {};\n"
"profileList = {};\n"
"createMapList = {};\n"
"\n"
"\n"
"If[optIgnoreWarnings,\n"
"  checkMessage := (If[Length[Select[$MessageList, (FreeQ[{HoldForm[Minimize::ztest1], HoldForm[Reduce::ztest1], HoldForm[DSolve::bvnul], HoldForm[General::stop]}, #])&] ] > 0, Abort[]]),\n"
"  checkMessage := (If[Length[$MessageList] > 0, Abort[] ])\n"
"];\n"
"\n"
"publicMethod::timeout = \"Calculation has reached to timeout\";\n"
"\n"
"$MessagePrePrint = InputForm;\n"
"\n"
"\n"
"timeFuncStart[] := (\n"
"  If[Length[startTimes]>0,\n"
"    startTimes = Append[startTimes,SessionTime[]];\n"
"  ,\n"
"    startTimes = {SessionTime[]};\n"
"  ];\n"
");\n"
"\n"
"timeFuncEnd[funcname_] := (\n"
"Module[{endTime,startTime,funcidx,i},\n"
"  endTime = SessionTime[];\n"
"  startTime = Last[startTimes];\n"
"  startTimes = Drop[startTimes,-1];\n"
"  If[Position[profileList, funcname] =!= {},\n"
"    funcidx = Flatten[Position[profileList,funcname]][[1]];\n"
"    profileList[[funcidx,2]] = profileList[[funcidx,2]] + 1;\n"
"    profileList[[funcidx,3]] = profileList[[funcidx,3]] + (endTime-startTime);\n"
"    profileList[[funcidx,4]] = profileList[[funcidx,3]] / profileList[[funcidx,2]];\n"
"    profileList[[funcidx,5]] = If[profileList[[funcidx,5]]<(endTime-startTime), endTime-startTime, profileList[[funcidx,5]]];\n"
"  ,\n"
"    profileList = Append[profileList, {funcname, 1, endTime-startTime, endTime-startTime, endTime-startTime}];\n"
"  ];\n"
"  profilePrint[funcname,\" took \",endTime-startTime,\", elapsed time:\",endTime];\n"
"  For[i=1,i<=Length[profileList],i=i+1,\n"
"    profilePrint[\"    function:\",profileList[[i,1]],\"  calls:\",profileList[[i,2]],\"  total time of this function:\",profileList[[i,3]],\"  average time:\",profileList[[i,4]],\"  max time:\",profileList[[i,5]]];\n"
"  ];\n"
"];\n"
");\n"
"\n"
"\n"
" \n"
"SetAttributes[simplePrint, HoldAll];\n"
"\n"
"symbolToString := (StringJoin[ToString[Unevaluated[#] ], \": \", ToString[InputForm[Evaluate[#] ] ] ])&;\n"
"\n"
"SetAttributes[symbolToString, HoldAll];\n"
"\n"
"SetAttributes[prev, Constant];\n"
"SetAttributes[parameter, Constant];\n"
"\n"
"SetAttributes[prev, NHoldAll];\n"
"SetAttributes[parameter, NHoldAll];\n"
"\n"
"\n"
"If[optUseDebugPrint || True,  \n"
"  debugPrint[arg___] := Print[InputForm[{arg}]];\n"
"  simplePrint[arg___] := Print[delimiterAddedString[\", \",\n"
"    List@@Map[symbolToString, Map[Unevaluated, Hold[arg]] ]\n"
"     ] ],\n"
"  \n"
"  debugPrint[arg___] := Null;\n"
"  simplePrint[arg___] := Null\n"
"];\n"
"\n"
"profilePrint[arg___] := If[optUseProfilePrint, Print[InputForm[arg]], Null];\n"
"\n"
"\n"
"\n"
"inputPrint[name_] := Print[StringJoin[name, \"[]\"]];\n"
" \n"
"inputPrint[name_, arg__] := Print[StringJoin[name, \"[\", delimiterAddedString[\",\\n\\t\", Map[(ToString[InputForm[#] ])&,{arg}] ], \"]\" ] ];\n"
"\n"
"delimiterAddedString[del_, {h_}] := h;\n"
"\n"
"delimiterAddedString[del_, {h_, t__}] := StringJoin[h, del, delimiterAddedString[del, {t}] ];\n"
"\n"
"SetAttributes[publicMethod, HoldAll];\n"
"\n"
"\n"
"\n"
"derivative[cnt_, var_] := Derivative[cnt][var];\n"
"derivative[cnt_, var_, suc_] := Derivative[cnt][var][suc];\n"
"\n"
"\n"
"\n"
"\n"
"publicMethod[name_, args___, define_] := (\n"
"  name[Sequence@@Map[(Pattern[#, Blank[]])&, {args}]] := (\n"
"    inputPrint[ToString[name], args];\n"
"    CheckAbort[\n"
"      TimeConstrained[\n"
"        timeFuncStart[];\n"
"        Module[{publicRet},\n"
"          publicRet = define;\n"
"          simplePrint[publicRet];\n"
"          timeFuncEnd[name];\n"
"          checkMessage;\n"
"          {1, publicRet}\n"
"        ],\n"
"        Evaluate[timeOutS],\n"
"        {-1}\n"
"      ],\n"
"      simplePrint[$MessageList];{0}\n"
"    ]\n"
"  )\n"
");\n"
"\n"
"publicMethod[\n"
"  simplify,\n"
"  arg,\n"
"  toReturnForm[Simplify[arg]]\n"
"];\n"
"\n"
"\n"
"\n"
"toReturnForm[expr_] := \n"
"Module[\n"
"  {ret},\n"
"  If[expr === Infinity, Return[inf]];\n"
"  \n"
"  If[MatchQ[expr, Derivative[_][_]], Return[Derivative[expr[[0, 1]], expr[[1]] ] ] ];\n"
"  If[MatchQ[expr, Derivative[_][_][t_]], Return[Derivative[expr[[0, 0, 1]], expr[[0, 1]] ] ] ];\n"
"  If[MatchQ[expr, _[t]] && isVariable[Head[expr] ], Return[Head[expr] ] ];\n"
"  If[Head[expr] === Real, Return[ToString[expr] ] ];\n"
"  If[Head[expr] === p || Head[expr] === Root, Return[expr] ];\n"
"\n"
"  ret = Map[toReturnForm, expr];\n"
"  ret = Replace[ret, (x_ :> ToString[InputForm[x]] /; Head[x] === Root )];\n"
"  ret = Replace[ret, (x_Rational :> Rational[replaceIntegerToString[Numerator[x] ], replaceIntegerToString[Denominator[x] ] ] )];\n"
"  ret = Replace[ret, (x_Integer :> replaceIntegerToString[x])];\n"
"  ret\n"
"];\n"
"\n"
"toRational[float_] := SetPrecision[float, Infinity];\n"
"\n"
"replaceIntegerToString[num_] := (If[num < 0, minus[IntegerString[num]], IntegerString[num] ]);\n"
"\n"
"\n"
"\n"
"\n"
"convertExprs[list_] := Map[({removeDash[ #[[1]] ], getExprCode[#], toReturnForm[#[[2]] ] } )&, list];\n"
"\n"
"\n"
"\n"
"getExprCode[expr_] := Switch[Head[expr],\n"
"  Equal, 0,\n"
"  Less, 1,\n"
"  Greater, 2,\n"
"  LessEqual, 3,\n"
"  GreaterEqual, 4\n"
"];\n"
"\n"
"\n"
"\n"
"\n"
"applyList[reduceSol_] :=\n"
"  If[reduceSol === True, {}, If[Head[reduceSol] === And, List @@ reduceSol, List[reduceSol]]];\n"
"\n"
"\n"
"applyListToOr[reduceSol_] :=\n"
"  If[Head[reduceSol] === Or, List @@ reduceSol, List[reduceSol]];\n"
"\n"
"\n"
"\n"
"And2and[reduceSol_] :=\n"
"  If[reduceSol === True, and[], If[Head[reduceSol] === And, and @@ reduceSol, and[reduceSol]] ];\n"
"\n"
"\n"
"Or2or[reduceSol_] :=\n"
"  If[Head[reduceSol] === Or, or @@ reduceSol, or[reduceSol]];\n"
"\n"
"\n"
"\n"
"\n"
"getReverseRelop[relop_] := Switch[relop,\n"
"                                  Equal, Equal,\n"
"                                  Less, Greater,\n"
"                                  Greater, Less,\n"
"                                  LessEqual, GreaterEqual,\n"
"                                  GreaterEqual, LessEqual];\n"
"\n"
"variablePrefix = \"u\";\n"
"publicMethod[\n"
"  calculateConsistentValue,\n"
"  equation, variable, variableMap, parameterMap,\n"
"  Module[\n"
"    {rules, sol, originalValue},\n"
"    \n"
"    rules = Select[variableMap, (#[[1]] =!= variable)&];\n"
"    rules = Map[(Rule@@#)&, rules];\n"
"    \n"
"    originalValue = Select[variableMap, (#[[1]] === variable)&];\n"
"    originalValue = originalValue[[1]][[2]];\n"
"    simplePrint[rules, originalValue];\n"
"\n"
"    sol = Solve[equation //. rules, {variable}];\n"
"    simplePrint[sol];\n"
"    sol = Select[sol, (Reduce[variable == #[[1]][[2]] && variable == originalValue && And@@parameterMap] =!= False)&];    \n"
"    simplePrint[sol];\n"
"    toReturnForm[sol[[1]][[1]][[2]] ]\n"
"  ]\n"
"];\n"
"   \n"
"\n"
"publicMethod[\n"
"  intervalToMidpointRadius,\n"
"  lb, ub,\n"
"  toReturnForm[midpointRadius[Simplify[(lb + ub)/2], Simplify[(ub - lb) / 2] ] ]\n"
"];\n"
"\n"
"publicMethod[\n"
"  transformToRational,\n"
"  float,\n"
"  toReturnForm[toRational[float]]\n"
"];\n"
"\n"
"publicMethod[\n"
"  numericalOutput,\n"
"  expr,\n"
"  toReturnForm[N[Expand[expr]]]\n"
"];isOverZero[expr_] := isOverZero[expr, pConstraint];\n"
"\n"
"publicMethod[\n"
"             isOverZero,\n"
"             expr, pCons,\n"
"             Module[\n"
"                    {isOverZeroTrue,ret},\n"
"                    debugPrint[\"is > 0 ?\",expr];\n"
"                    isOverZeroTrue = Refine[expr > 0, Assumptions -> pCons];\n"
"                    simplePrint[isOverZeroTrue];\n"
"                    ret = isOverZeroTrue === True;\n"
"                    simplePrint[ret];\n"
"                    ret\n"
"                    ]\n"
"             ];\n"
"\n"
"publicMethod[\n"
"             cutHighOrderVariable,\n"
"             expr, var, dcount,\n"
"             Module[\n"
"                    {sTmp,sCond,dTimes,dExpr,ret},\n"
"                    dTimes = 0;\n"
"                    dExpr = expr;\n"
"                    sTmp = Quiet[Check[dExpr /. var -> 0, False, {Power::infy, Power::indet}]];\n"
"                    sCond = sTmp =!= False;\n"
"                    If[sCond, ret = sTmp, ret = expr]\n"
"                    While[sCond && dTimes++ < dcount,\n"
"                          dExpr = D[dExpr, var];\n"
"                          sTmp = Quiet[Check[dExpr /. var -> 0, False, {Power::infy, Power::indet}]];\n"
"                          sCond = sTmp =!= False;\n"
"                          If[sCond, ret = ret + sTmp*var^dTimes, ret = expr]\n"
"                          ];\n"
"                    toReturnForm[ret]\n"
"                    ]\n"
"             ];\n"
"\n"
"publicMethod[\n"
"             limitEpsilon,\n"
"             arg,\n"
"             debugPrint[\"limitEpsilon arg\",arg];\n"
"             toReturnForm[Limit[arg, p[eps, 0, 1] -> 0]]\n"
"             ];\n"
"\n"
"publicMethod[\n"
"             reduceEpsilon,\n"
"             arg,\n"
"             Module[\n"
"                    {one,two,ret},\n"
"                    one = Quiet[Check[arg /. p[eps, 0, 1] -> 0, False, {Power::infy, Power::indet}]];\n"
"                    two = Quiet[Check[D[arg, p[eps, 0, 1]] /. p[eps, 0, 1] -> 0, False, {Power::infy, Power::indet}]];\n"
"                    If[one =!= False && two =!= False, ret = one + two * p[eps, 0, 1], ret = arg];\n"
"                    toReturnForm[ret]\n"
"                    ]\n"
"             ];\n"
"\n"
"publicMethod[\n"
"             checkEpsilon,\n"
"             arg,\n"
"             Module[\n"
"                    {direplus,direminus,flag,ret},\n"
"                    debugPrint[\"checkEpsilon arg\",arg];\n"
"                    direplus = Limit[arg, p[eps, 0, 1] -> 0,Direction->-1];\n"
"                    direminus = Limit[arg, p[eps, 0, 1] -> 0,Direction->1];\n"
"                    flag = FullSimplify[direplus - direminus];\n"
"                    If[flag === 0,\n"
"                       ret = 1,\n"
"                       ret = 0\n"
"                       ];\n"
"                    ret\n"
"                    ]\n"
"             ];\n"
"\n"
"publicMethod[\n"
"             limitEpsilonP,\n"
"             arg,\n"
"             debugPrint[\"limitEpsilonP arg\",arg];\n"
"             toReturnForm[Limit[arg, p[eps, 0, 1] -> 0,Direction->-1]]\n"
"             ];\n"
"\n"
"publicMethod[\n"
"             limitEpsilonM,\n"
"             arg,\n"
"             debugPrint[\"limitEpsilonM arg\",arg];\n"
"             toReturnForm[Limit[arg, p[eps, 0, 1] -> 0,Direction->1]]\n"
"             ];\n"
"\n"
"\n"
"publicMethod[checkIncludeBound, v1, v2, pConstraintPast, pConstraintNow,\n"
"  Module[{minPast, maxPast, minNow, maxNow, tmp, reduceExprPast, \n"
"    reduceExprNow},\n"
"   minPast = \n"
"    Quiet[Minimize[{v2, And@@pConstraintPast && t > 0}, \n"
"      If[Union[getParameters[v2 && pConstraintPast]] =!= {}, \n"
"       Union[getParameters[v2 && pConstraintPast]], {tmp}], \n"
"      Reals], {Minimize::wksol, Minimize::infeas}];\n"
"   simplePrint[minPast];\n"
"   maxPast = \n"
"    Quiet[Maximize[{v2, And@@pConstraintPast && t > 0}, \n"
"      If[Union[getParameters[v2 && pConstraintPast]] =!= {}, \n"
"       Union[getParameters[v2 && pConstraintPast]], {tmp}], \n"
"      Reals], {Maximize::wksol, Maximize::infeas}];\n"
"   simplePrint[maxPast];\n"
"   minNow = \n"
"    Quiet[Minimize[{v1, And@@pConstraintNow && t > 0}, \n"
"      If[Union[getParameters[v1 && pConstraintNow]] =!= {}, \n"
"       Union[getParameters[v1 && pConstraintNow]], {tmp}], \n"
"      Reals], {Minimize::wksol, Minimize::infeas}];\n"
"   simplePrint[minNow];\n"
"   maxNow = \n"
"    Quiet[Maximize[{v1, And@@pConstraintNow && t > 0}, \n"
"      If[Union[getParameters[v1 && pConstraintNow]] =!= {}, \n"
"       Union[getParameters[v1 && pConstraintNow]], {tmp}], \n"
"      Reals], {Maximize::wksol, Maximize::infeas}];\n"
"   simplePrint[maxNow];\n"
"   \n"
"   minPast = checkInclude[minPast][[2]];\n"
"   maxPast = checkInclude[maxPast][[2]];\n"
"   minNow = checkInclude[minNow][[2]];\n"
"   maxNow = checkInclude[maxNow][[2]];\n"
"   If[minPast[[1]] == maxPast[[1]], \n"
"    reduceExprPast = tmp == minPast[[1]];,\n"
"    If[minPast[[2]] == 0, reduceExprPast = minPast[[1]] < tmp;, \n"
"     reduceExprPast = minPast[[1]] <= tmp;];\n"
"    If[maxPast[[2]] == 0, \n"
"     reduceExprPast = reduceExprPast && tmp < maxPast[[1]];, \n"
"     reduceExprPast = reduceExprPast && tmp <= maxPast[[1]];];\n"
"    ];\n"
"   If[minNow[[1]] == maxNow[[1]], reduceExprNow = tmp == minNow[[1]];,\n"
"    If[minNow[[2]] == 0, reduceExprNow = minNow[[1]] < tmp;, \n"
"     reduceExprNow = minNow[[1]] <= tmp;];\n"
"    If[maxNow[[2]] == 0, \n"
"     reduceExprNow = reduceExprNow && tmp < maxNow[[1]];, \n"
"     reduceExprNow = reduceExprNow && tmp <= maxNow[[1]];];\n"
"    ];\n"
"   simplePrint[reduceExprPast && reduceExprNow];\n"
"   If[Reduce[\n"
"      Not[reduceExprPast] && reduceExprNow] === False, True, \n"
"    False]]\n"
"];\n"
"\n"
"publicMethod[checkInclude, includeBound, \n"
" Module[{flg, flgInclude, res, tmpT0}, flg = True; flgInclude = True;\n"
"   If[Cases[includeBound[[1]], {_, _}] === {}, res = {includeBound[[1]], 1};,\n"
"     For[i = 1, i <= Length[includeBound[[1, 1]]], i = i + 1,\n"
"       If[Reduce[Not[includeBound[[1, 1, i, 2]]] && t == 0] === False,\n"
"         \n"
"         flgInclude = False;\n"
"       ];\n"
"       If[Reduce[Not[includeBound[[1, 1, i, 2]]] && t > 0] === False,\n"
"         flg = False;\n"
"         res = {includeBound[[1, 1, i, 1]], 0};\n"
"       ];\n"
"     ];\n"
"     If[flg === True,\n"
"       If[flgInclude === True,\n"
"         res = {includeBound[[1, 2]], 1};,\n"
"         res = {includeBound[[1, 2]], 0};\n"
"       ];\n"
"     ];\n"
"   ];\n"
"   Limit[res, t -> 0, Direction -> -1]\n"
" ]\n"
"];\n"
"\n"
"\n"
"publicMethod[\n"
"  substituteParameterCondition,\n"
"  expr, pCond,\n"
"  Module[\n"
"    {substitutedVal, pRules},\n"
"    pRules = Map[(#[[1]] -> #[[2]])&, pCond];\n"
"    substitutedVal = Simplify[expr /. pRules];\n"
"    If[Element[substitutedVal, Reals] =!= False,\n"
"      toReturnForm[substitutedVal],\n"
"      Message[substitute_value::nrls, substitutedVal]\n"
"    ]\n"
"  ]\n"
"];\n"
"\n"
"\n"
"\n"
"publicMethod[\n"
"  SubstituteValue,\n"
"  expr, value,\n"
"  Module[\n"
"    {appliedExpr},\n"
"    appliedExpr = Reduce[{expr, value}, expr[[1]], Reals];\n"
"    simplePrint[appliedExpr];\n"
"    appliedExpr = appliedExpr[[Length[appliedExpr],2]];    \n"
"    If[Element[appliedExpr, Reals] =!= False,\n"
"      toReturnForm[appliedExpr],\n"
"      Message[substitute_value::nrls, appliedExpr]\n"
"    ]\n"
"  ]\n"
"];\n"
"\n"
"publicMethod[\n"
"  SubstituteTime,\n"
"  expr, value,\n"
"  Module[\n"
"    {appliedExpr},\n"
"    appliedExpr = Reduce[{t == expr, t>=0, value}, t, Reals];\n"
"    simplePrint[appliedExpr];\n"
"    appliedExpr = appliedExpr[[Length[appliedExpr],2]];    \n"
"    If[Element[appliedExpr, Reals] =!= False,\n"
"      integerString[appliedExpr],\n"
"      Message[substitute_value::nrls, appliedExpr]\n"
"    ]\n"
"  ]\n"
"];\n"
"\n"
"publicMethod[\n"
"  timeAdd,\n"
"  expr, time,\n"
"  integerString[expr + time]\n"
"];\n"
"\n"
"\n"
"\n"
"checkConsistencyPoint[] := (\n"
"  checkConsistencyPoint[constraint && tmpConstraint && initConstraint && initTmpConstraint && prevIneqs, pConstraint, Union[variables, prevVariables], parameters ]\n"
");\n"
"\n"
"publicMethod[\n"
"  checkConsistencyPoint,\n"
"  cons, pcons, vars, pars,\n"
"  Module[\n"
"    {cpTrue, cpFalse},\n"
"    \n"
"    Quiet[\n"
"      cpTrue = Reduce[Exists[vars, cons && pcons], pars, Reals], {Reduce::useq}\n"
"    ];\n"
"    simplePrint[cpTrue];\n"
"    \n"
"    cpTrue = cpTrue /. {NotElement[_, _] -> True, Element[_, _] -> True};\n"
"    checkMessage;\n"
"    Quiet[\n"
"      cpFalse = Reduce[pcons && !cpTrue, pars, Reals], {Reduce::useq}\n"
"    ];\n"
"    checkMessage;\n"
"    simplePrint[cpFalse];\n"
"    toReturnForm[{{LogicalExpand[cpTrue]}, {LogicalExpand[cpFalse]}}]\n"
"  ]\n"
"];\n"
"\n"
"\n"
"\n"
"checkConsistencyInterval[] :=  (\n"
"  checkConsistencyInterval[constraint && tmpConstraint, initConstraint && initTmpConstraint, prevIneqs, pConstraint, timeVariables, initVariables, prevVariables, parameters]\n"
");\n"
"\n"
"moveTermsToLeft[expr_] := Head[expr][expr[[1]] - expr[[2]], 0];\n"
"\n"
"ccIntervalForEach[cond_, initRules_, pCons_] :=\n"
"Module[\n"
"  {\n"
"    operator,\n"
"    lhs,\n"
"    eqSol,\n"
"    gtSol,\n"
"    ltSol,\n"
"    trueCond\n"
"  },\n"
"  inputPrint[\"ccIntervalForEach\", cond, initRules, pCons];\n"
"  If[cond === True || cond === False, Return[cond]];\n"
"  operator = Head[cond];\n"
"  lhs = (cond[[1]] - cond[[2]] ) /. t -> 0 /. initRules;\n"
"  simplePrint[lhs];\n"
"  \n"
"  If[hasVariable[lhs], Return[pCons] ];\n"
"\n"
"  trueCond = False;\n"
"\n"
"  eqSol = Quiet[Reduce[lhs == 0 && pCons, Reals] ];\n"
"  If[eqSol =!= False,\n"
"    eqSol = ccIntervalForEach[operator[D[cond[[1]], t], D[cond[[2]], t]], initRules, eqSol];\n"
"    simplePrint[eqSol];\n"
"    trueCond = trueCond || eqSol\n"
"  ];\n"
"  If[MemberQ[{Unequal, Greater, GreaterEqual}, operator],\n"
"    gtSol = Quiet[Reduce[lhs > 0 && pCons, Reals] ];\n"
"    simplePrint[gtSol];\n"
"    trueCond = trueCond || gtSol\n"
"  ];\n"
"  If[MemberQ[{Unequal, Less, LessEqual}, operator],\n"
"    ltSol = Quiet[Reduce[lhs < 0 && pCons, Reals] ];\n"
"    simplePrint[ltSol];\n"
"    trueCond = trueCond || ltSol\n"
"  ];\n"
"  trueCond\n"
"];\n"
"\n"
"\n"
"publicMethod[\n"
"  checkConsistencyInterval,\n"
"  cons, initCons, prevCons, pCons, timeVars, initVars, prevVars, pars,\n"
"  Module[\n"
"    {sol, otherCons, tCons, i, j, conj, cpTrue, eachCpTrue, cpFalse},\n"
"    If[cons === True,\n"
"      {{LogicalExpand[pCons]}, {False}},\n"
"      sol = exDSolve[cons, initCons];\n"
"      debugPrint[\"sol after exDSolve\", sol];\n"
"      If[sol === overConstraint,\n"
"        {{False}, {LogicalExpand[pCons]}},\n"
"        tCons = Map[(Rule@@#)&, createDifferentiatedEquations[timeVars, sol[[3]] ] ];\n"
"        tCons = sol[[2]] /. tCons;\n"
"        simplePrint[tCons];\n"
"\n"
"        cpTrue = False;\n"
"        For[i = 1, i <= Length[tCons], i++,\n"
"          conj = tCons[[i]];\n"
"          eachCpTrue = prevCons && pCons;\n"
"          For[j = 1, j <= Length[conj], j++,\n"
"            eachCpTrue = eachCpTrue && ccIntervalForEach[conj[[j]], Map[(Rule@@#)&, applyList[initCons] ], eachCpTrue]\n"
"          ];\n"
"          cpTrue = cpTrue || eachCpTrue\n"
"        ];\n"
"        cpFalse = Reduce[!cpTrue && pCons && prevCons, Join[pars, prevVars], Reals];\n"
"        toReturnForm[{{LogicalExpand[cpTrue]}, {LogicalExpand[cpFalse]}}]\n"
"      ]\n"
"    ]\n"
"  ]\n"
"];\n"
"\n"
"\n"
"\n"
"\n"
"createVariableMap[cons_] := createVariableMap[And@@cons && pConstraint && initConstraint, variables];\n"
"\n"
"publicMethod[\n"
"  createVariableMap,\n"
"  cons, vars,\n"
"  Module[\n"
"    {ret},\n"
"    ret = createMap[cons, isVariable, hasVariable, vars];\n"
"    debugPrint[\"ret after CreateMap\", ret];\n"
"    ret = Map[(Cases[#, Except[{p[___], _, _}] ])&, ret];\n"
"    ret = ruleOutException[ret];\n"
"    simplePrint[ret];\n"
"    ret\n"
"  ]\n"
"];\n"
"\n"
"publicMethod[\n"
"  createVariableMapInterval,\n"
"  cons,\n"
"  Module[\n"
"    {sol, tStore, ret},\n"
"    tStore = Select[cons, (!hasVariable[ #[[2]] ])&];\n"
"    ret = {convertExprs[tStore]};\n"
"    ret = ruleOutException[ret];\n"
"    simplePrint[ret];\n"
"    ret\n"
"  ]\n"
"];\n"
"\n"
"\n"
"publicMethod[\n"
"  getConstraintStorePoint,\n"
"  {toReturnForm[LogicalExpand[constraint && pConstraint && initConstraint]]}\n"
"];\n"
"\n"
"\n"
"getConstraintStoreInterval[] := \n"
"getConstraintStoreInterval[constraint, initConstraint, timeVariables];\n"
"\n"
"publicMethod[\n"
"  getConstraintStoreInterval,\n"
"  cons, initCons, vars,\n"
"  Module[\n"
"    {sol, tStore},\n"
"    sol = exDSolve[cons, initCons];\n"
"    debugPrint[\"sol after exDSolve\", sol];\n"
"    If[sol === overConstraint || sol[[1]] === underConstraint,\n"
"      error,\n"
"      tStore = createDifferentiatedEquations[vars, sol[[3]] ];\n"
"      tStore = Select[tStore, (!hasVariable[ #[[2]] ])&];\n"
"      toReturnForm[tStore]\n"
"    ]\n"
"  ]\n"
"];\n"
"\n"
"\n"
"ruleOutException[list_] := Module[\n"
"  {ret},\n"
"  ret = Map[(Cases[#, {{_?isVariable, _}, _, _} ])&, list];\n"
"  ret = Map[(Cases[#, Except[{{t, 0}, _, _}] ])&, ret];\n"
"  ret = Map[(Cases[#, Except[{{prev[_, _], _}, _, _}] ])&, ret];\n"
"  ret\n"
"];\n"
"\n"
"createParameterMap[] := createParameterMap[pConstraint];\n"
"\n"
"publicMethod[\n"
"  createParameterMap,\n"
"  pCons,\n"
"  createMap[pCons, isParameter, hasParameter, {}];\n"
"];\n"
"\n"
"createMap[cons_, judge_, hasJudge_, vars_] := \n"
"createMap[cons, judge, hasJudge, vars] = \n"
"Module[\n"
"  {map},\n"
"  If[cons === True || cons === False, \n"
"    cons,\n"
"    \n"
"    map = cons /. (expr_ /; ( MemberQ[{Equal, LessEqual, Less, Greater, GreaterEqual, Unequal}, Head[expr] ] && (!hasJudge[expr] || hasPrevVariable[expr])) -> True);\n"
"    map = Reduce[map, vars, Reals];\n"
"\n"
"    \n"
"    map = map /. (expr_ /; ( MemberQ[{Equal, LessEqual, Less, Greater, GreaterEqual, Unequal}, Head[expr] ] && (!hasJudge[expr] || hasPrevVariable[expr])) -> True);\n"
"\n"
"    simplePrint[map];\n"
"    map = LogicalExpand[map];\n"
"    map = applyListToOr[map];\n"
"    map = Map[(applyList[#])&, map];\n"
"    map = Map[(adjustExprs[#, judge])&, map];\n"
"    debugPrint[\"@createMap map after adjustExprs\", map];\n"
"    map = Map[(convertExprs[#])&, map];\n"
"    map\n"
"  ]\n"
"];\n"
"\n"
"\n"
"\n"
"hasVariable[exprs_] := Length[StringCases[ToString[exprs], variablePrefix ~~ WordCharacter]] > 0;\n"
"\n"
"\n"
"\n"
"isVariable[exprs_] := MatchQ[exprs, _Symbol] && StringMatchQ[ToString[exprs], variablePrefix ~~ WordCharacter__] || MatchQ[exprs, Derivative[_][_][_] ] || MatchQ[exprs, Derivative[_][_] ] ;\n"
"\n"
"\n"
"\n"
"getVariables[exprs_] := ToExpression[StringCases[ToString[exprs], variablePrefix ~~ WordCharacter..]];\n"
"\n"
"\n"
"\n"
"getParameters[exprs_] := Cases[exprs, p[_, _, _], Infinity];\n"
"\n"
"\n"
"\n"
"hasParameter[exprs_] := Length[Cases[exprs, p[_, _, _], Infinity] ] > 0;\n"
" \n"
"hasParameterOrPrev[exprs_] := Length[Cases[{exprs}, p[_, _, _] | prev[_, _], Infinity] ] > 0;\n"
"\n"
"\n"
"\n"
"isParameter[exprs_] := Head[exprs] === p;\n"
"\n"
"isParameterOrPrev[exprs_] := Head[exprs] === p || Head[exprs] === prev;\n"
"\n"
"\n"
"hasSymbol[exprs_, syms_List] := MemberQ[{exprs}, ele_ /; (MemberQ[syms, ele] || (!AtomQ[ele] && hasSymbol[Head[ele], syms]) ), Infinity ];\n"
"\n"
"\n"
"isPrevVariable[exprs_] := Head[exprs] === prev;\n"
"\n"
"\n"
"hasPrevVariable[exprs_] := Length[Cases[exprs, prev[_, _], Infinity]] > 0;\n"
"\n"
"\n"
"adjustExprs[andExprs_, judgeFunction_] := \n"
"Fold[\n"
"  (\n"
"   If[#2 === True,\n"
"    #1,\n"
"    If[Not[judgeFunction[#2[[1]] ] ] && judgeFunction[#2[[2]] ],\n"
"     \n"
"     Append[#1, getReverseRelop[Head[#2] ][#2[[2]], #2[[1]] ] ],\n"
"     Append[#1, #2]]\n"
"   ]) &,\n"
"  {},\n"
"  andExprs\n"
"];\n"
"\n"
"publicMethod[\n"
"  resetConstraint,\n"
"  constraint = True;\n"
"  initConstraint = True;\n"
"  pConstraint = True;\n"
"  prevIneqs = True;\n"
"  prevRules = {};\n"
"  initTmpConstraint = True;\n"
"  tmpConstraint = True;\n"
"  isTemporary = False;\n"
"];\n"
"\n"
"publicMethod[\n"
"  resetConstraintForVariable,\n"
"  constraint = initConstraint = tmpConstraint = initTmpConstraint = True;\n"
"];\n"
"\n"
"publicMethod[\n"
"  addConstraint,\n"
"  co,\n"
"  Module[\n"
"    {cons},\n"
"    cons = If[Head[co] === List, And@@co, co] //. prevRules;\n"
"    If[isTemporary,\n"
"      tmpConstraint = tmpConstraint && cons,\n"
"      constraint = constraint && cons\n"
"    ];\n"
"    simplePrint[cons, constraint, tmpConstraint];\n"
"  ]\n"
"];\n"
"\n"
"addInitConstraint[co_] := Module[\n"
"  {cons, vars},\n"
"  cons = And@@co //. prevRules;\n"
"  If[isTemporary,\n"
"    initTmpConstraint = initTmpConstraint && cons,\n"
"    initConstraint = initConstraint && cons\n"
"  ];\n"
"  simplePrint[cons, initConstraint, initTmpConstraint, prevRules];\n"
"];\n"
"\n"
"publicMethod[\n"
"  addPrevConstraint,\n"
"  co,\n"
"  Module[\n"
"    {land, cnf, eqs, ineqs},\n"
"    land = And@@co;\n"
"    \n"
"    cnf = And2and[BooleanConvert[land, \"CNF\"] ];\n"
"    eqs = Select[cnf, (Head[#]===Equal)&];\n"
"    ineqs = Complement[cnf, eqs];\n"
"    prevRules = Join[prevRules, List@@Map[(Rule@@#)&, eqs] ];\n"
"    prevIneqs = prevIneqs && And@@ineqs;\n"
"    simplePrint[prevRules, prevIneqs];\n"
"  ]\n"
"];\n"
"\n"
"\n"
"makePrevVar[var_] := Module[\n"
"  {name, dcount},\n"
"  If[MatchQ[var, Derivative[_][_] ],\n"
"    name = var[[1]];\n"
"    dcount = var[[0]][[1]],\n"
"    name = var;\n"
"    dcount = 0\n"
"  ];\n"
"  \n"
"  name = ToString[name];\n"
"  name = StringDrop[name, 1];\n"
"  name = StringJoin[\"p\", name];\n"
"  name = ToExpression[name];\n"
"  prev[name, dcount]\n"
"];\n"
"\n"
"publicMethod[\n"
"  addVariable,\n"
"  name,\n"
"  diffCnt,\n"
"  Module[\n"
"    {var},\n"
"    var = If[diffCnt > 0, Derivative[diffCnt][name], name];\n"
"    Unprotect[variables, prevVariables, timeVariables, initVariables];\n"
"    variables = Union[variables, {var}];\n"
"    prevVariables = Union[prevVariables,\n"
"      {makePrevVar[var]} ];\n"
"    timeVariables = Union[timeVariables, {var[t] } ];\n"
"    initVariables = Union[initVariables, {var[t]} ];\n"
"    simplePrint[variables, prevVariables, timeVariables, initVariables];\n"
"    Protect[variables, prevVariables, timeVariables, initVariables];\n"
"  ]\n"
"];\n"
"\n"
"\n"
"setVariables[vars_] := (\n"
"  Unprotect[variables, prevVariables, timeVariables, initVariables];\n"
"  variables = vars;\n"
"  prevVariables = Map[makePrevVar, vars];\n"
"  timeVariables = Map[(#[t])&, vars];\n"
"  initVariables = Map[(#[0])&, vars];\n"
"  simplePrint[variables, prevVariables, timeVariables, initVariables];\n"
"  Protect[variables, prevVariables, timeVariables, initVariables];\n"
");\n"
"\n"
"\n"
"publicMethod[\n"
"  startTemporary,\n"
"  isTemporary = True;\n"
"];\n"
"\n"
"publicMethod[\n"
"  endTemporary,\n"
"  isTemporary = False;\n"
"  resetTemporaryConstraint[];\n"
"];\n"
"\n"
"resetTemporaryConstraint[] := (\n"
"  tmpConstraint = True;\n"
"  initTmpConstraint = True;\n"
");\n"
"\n"
"publicMethod[\n"
"  resetConstraintForParameter,\n"
"  pCons,\n"
"  pConstraint = True;\n"
"  pConstraint = Reduce[pConstraint && And@@pCons, Reals];\n"
"  simplePrint[pConstraint];\n"
"];\n"
"\n"
"\n"
"publicMethod[\n"
"  addInitEquation,\n"
"  lhs, rhs,\n"
"  addInitConstraint[{lhs == rhs}]\n"
"];\n"
"\n"
"publicMethod[\n"
"  addEquation,\n"
"  lhs, rhs,\n"
"  Module[\n"
"    {cons},\n"
"    cons = lhs == rhs;\n"
"    If[isTemporary,\n"
"      tmpConstraint = tmpConstraint && cons,\n"
"      constraint = constraint && cons\n"
"      ];\n"
"    simplePrint[cons, constraint, tmpConstraint];\n"
"  ]\n"
"];\n"
"\n"
"publicMethod[\n"
"  addParameterConstraint,\n"
"  pCons,\n"
"  pConstraint = Reduce[pConstraint && And@@pCons, Reals];\n"
"  simplePrint[pConstraint];\n"
"];\n"
"\n"
"\n"
"publicMethod[\n"
"  clearParameters,\n"
"  par,\n"
"  parameters = {}\n"
"];\n"
"\n"
"publicMethod[\n"
"  addParameter,\n"
"  par,\n"
"  parameters = Union[parameters, {par}]\n"
"];\n"
"\n"
"\n"
"removeDash[var_] := Module[\n"
"   {ret},\n"
"   If[Head[var] === p || Head[var] === prev, Return[var]];\n"
"   ret = var /. x_[t] -> x;\n"
"   If[MatchQ[Head[ret], Derivative[_]],\n"
"     ret /. Derivative[d_][x_] -> {x, d},\n"
"     {ret, 0}\n"
"   ]\n"
"];\n"
"\n"
"\n"
"\n"
"\n"
"makeListFromPiecewise[minT_, others_] := Module[\n"
"  {tmpCondition = False, retMinT},\n"
"  If[Head[minT] =!= Piecewise, Return[{{minT, others}}] ];\n"
"  retMinT = minT[[1]];\n"
"  tmpCondition = Or @@ Map[(#[[2]])&, minT[[1]]];\n"
"  tmpCondition = Reduce[And[others, Not[tmpCondition]], Reals];\n"
"  retMinT = Map[({#[[1]], Reduce[others && #[[2]] ]})&, retMinT];\n"
"  If[ tmpCondition === False,\n"
"    retMinT,\n"
"    Append[retMinT, {minT[[2]], tmpCondition}]\n"
"  ]\n"
"];\n"
"\n"
"\n"
"\n"
"calculateNextPointPhaseTime[maxTime_, discCauses_] := \n"
"  calculateNextPointPhaseTime[maxTime, discCauses, constraint, initConstraint, pConstraint, timeVariables];\n"
"\n"
"\n"
"\n"
"compareWithMaxTime[maxT_, timeCond_] := \n"
"Module[\n"
"  {sol, tmpCond},\n"
"  sol = Reduce[maxT <= timeCond[[1]] && timeCond[[2]], Reals];\n"
"  If[sol === False,\n"
"    {{timeCond[[1]], timeCond[[2]], 0}},\n"
"    tmpCond = Reduce[(!sol && timeCond[[2]]), Reals];\n"
"    If[tmpCond === False,  \n"
"      {{maxT, timeCond[[2]], 1}},\n"
"      {{maxT, sol, 1}, {timeCond[[1]], tmpCond, 0}}\n"
"    ]\n"
"  ]\n"
"];\n"
"\n"
"\n"
"\n"
"findMinTime[causeAndID_, condition_] := \n"
"Module[\n"
"  {\n"
"    id,\n"
"    cause,\n"
"    minT,\n"
"    ret\n"
"  },\n"
"  id = causeAndID[[2]];\n"
"  cause = causeAndID[[1]];\n"
"  sol = Reduce[cause && condition && t > 0, t, Reals];\n"
"  checkMessage[];\n"
"  If[sol === False, Return[{}] ];\n"
"  \n"
"  minT = First[Quiet[Minimize[{t, sol}, {t}], Minimize::wksol]];\n"
"  ret = makeListFromPiecewise[minT, condition];\n"
"  \n"
"  ret = Select[ret, (#[[1]] =!= 0)&];\n"
"  \n"
"  ret = Map[({timeAndIDs[#[[1]], ids[id] ], #[[2]]})&, ret];\n"
"  ret\n"
"];\n"
"\n"
"\n"
"\n"
"compareMinTime[timeCond1_, timeCond2_] := ( Block[\n"
"    {\n"
"      minTime1, minTime2,\n"
"      timeAndID1, timeAndID2,\n"
"      nonMinimum,\n"
"      caseEq,caseLe, caseGr,\n"
"      ret,\n"
"      andCond\n"
"    },\n"
"    \n"
"    andCond = Reduce[timeCond1[[3]] && timeCond2[[2]], Reals];\n"
"    If[andCond === False, Return[{}] ];\n"
"    timeAndID1 = timeCond1[[1]];\n"
"    timeAndID2 = timeCond2[[1]];\n"
"    minTime1 = timeAndID1[[1]];\n"
"    minTime2 = timeAndID2[[1]];\n"
"    nonMinimum = timeCond1[[2]];\n"
"    caseEq = Quiet[Reduce[And[andCond, minTime1 == minTime2], Reals]];\n"
"    caseLe = Quiet[Reduce[And[andCond, minTime1 < minTime2], Reals]];\n"
"    caseGr = Reduce[andCond && !caseLe && !caseEq];\n"
"    ret = {};\n"
"    If[ caseEq =!= False,\n"
"      ret = Append[ret,\n"
"        {timeAndIDs[minTime1, Join[timeAndID1[[2]], timeAndID2[[2]] ] ], nonMinimum, caseEq}]\n"
"    ];\n"
"    If[ caseLe =!= False,\n"
"      ret = Append[ret, \n"
"        {timeAndID1, Append[nonMinimum, timeCond2[[1]]], caseLe}]\n"
"    ];\n"
"    If[ caseGr =!= False, \n"
"      ret = Append[ret,\n"
"        {timeAndID2, Append[nonMinimum, timeCond1[[1]]], caseGr}]\n"
"    ];\n"
"    Return[ ret ];\n"
"  ]\n"
");\n"
"\n"
" \n"
"\n"
"compareMinTimeList[list1_, list2_] := ( Block[\n"
"    {resultList, i, j},\n"
"    If[list2 === {}, Return[list1] ];\n"
"    resultList = {};\n"
"    For[i = 1, i <= Length[list1], i++,\n"
"      For[j = 1, j <= Length[list2], j++,\n"
"        resultList = Join[resultList, compareMinTime[list1[[i]], list2[[j]] ] ]\n"
"      ]\n"
"    ];\n"
"    resultList\n"
"  ]\n"
");\n"
"\n"
"\n"
"calculateMinTimeList[causeAndIDList_, condition_, maxT_] := (\n"
"  Block[\n"
"    {findResult, i},\n"
"    \n"
"    timeCaseList = {{timeAndIDs[maxT, ids[-1]], {}, condition}};\n"
"    For[i = 1, i <= Length[causeAndIDList], i++,\n"
"      findResult = findMinTime[causeAndIDList[[i]], condition];\n"
"      timeCaseList = compareMinTimeList[timeCaseList, findResult]\n"
"    ];\n"
"    timeCaseList\n"
"  ]\n"
");\n"
"\n"
"\n"
"divideDisjunction[timeCond_] := Map[({timeCond[[1]], timeCond[[2]], #})&, List@@timeCond[[3]]];\n"
"\n"
" \n"
"publicMethod[\n"
"  calculateNextPointPhaseTime,\n"
"  maxTime, causeAndIDs, cons, initCons, pCons, vars,\n"
"  Module[\n"
"    {\n"
"      timeAppliedCauses,\n"
"      resultList,\n"
"      necessaryPCons,\n"
"      parameterList,\n"
"      originalOther,\n"
"      tmpMaxTime\n"
"    },\n"
"\n"
"    tStore = Map[(Rule@@#)&, createDifferentiatedEquations[vars, applyList[cons] ] ];\n"
"    timeAppliedCauses = causeAndIDs /. tStore;\n"
"    simplePrint[timeAppliedCauses];\n"
"    \n"
"    parameterList = getParameters[timeAppliedCauses];\n"
"    \n"
"    \n"
"    \n"
"    necessaryPCons = LogicalExpand[pCons] /. (expr_ /; (( Head[expr] === Equal || Head[expr] === LessEqual || Head[expr] === Less|| Head[expr] === GreaterEqual || Head[expr] === Greater) && (!hasSymbol[expr, parameterList])) -> True);\n"
"    \n"
"    simplePrint[necessaryPCons];\n"
"    \n"
"    resultList = calculateMinTimeList[timeAppliedCauses, necessaryPCons, maxTime];\n"
"    \n"
"    simplePrint[resultList];\n"
"    \n"
"    \n"
"    resultList = Map[({#[[1]], #[[2]], LogicalExpand[#[[3]] ]})&, resultList];\n"
"    resultList = Fold[(Join[#1, If[Head[#2[[3]]]===Or, divideDisjunction[#2], {#2}]])&,{}, resultList];\n"
"    resultList = Map[({#[[1]], #[[2]], Cases[applyList[#[[3]] ], Except[True]]})&, resultList];\n"
"    \n"
"    debugPrint[\"resultList after Format\", resultList];\n"
"    \n"
"    resultList = Map[\n"
"    ({timeAndIDsToReturn[#[[1]] ], Map[(timeAndIDsToReturn[#])&, #[[2]] ], convertExprs[adjustExprs[#[[3]], isParameter ] ] })&, resultList];\n"
"    simplePrint[resultList];\n"
"    resultList\n"
"  ]\n"
"];\n"
"\n"
"timeAndIDsToReturn[ti_] := timeAndIDs[toReturnForm[ti[[1]] ], ti[[2]] ];\n"
"\n"
"applyDSolveResult[exprs_, integRule_] := (\n"
"  exprs  /. integRule     \n"
"         /. Map[((#[[1]] /. x_[t]-> x) -> #[[2]] )&, integRule]\n"
"         /. (Derivative[n_][f_][t] /; !isVariable[f]) :> D[f, {t, n}] \n"
");\n"
"\n"
"createDifferentiatedEquations[vars_, integRules_] := (\n"
"  Module[\n"
"    {tRemovedRules, derivativeExpanded, ruleApplied, ruleVars, ret, tRemovedVars},\n"
"    ret = Fold[(Join[#1, createDifferentiatedEquation[#2, integRules] ])&, {}, vars];\n"
"    ret\n"
"  ]\n"
");\n"
"\n"
"removeDerivative[Derivative[_][var_][arg_]] := var[arg];\n"
"removeDerivative[var_] := var;\n"
"\n"
"createDifferentiatedEquation[var_, integRules_] := (\n"
"  Module[\n"
"    {rule, result, tVar, dCount},\n"
"    \n"
"    tVar = removeDerivative[var];\n"
"    rule = Select[integRules, (#[[1]] === tVar)&];\n"
"    If[Length[rule] == 0, Return[{}], rule = rule[[1]] ];\n"
"    If[MatchQ[var, Derivative[n_][x_][t]], \n"
"      dCount = Head[Head[var] ][[1]];\n"
"      result = Equal[var, D[rule[[2]], {t, dCount}] ],\n"
"      result = Equal[var, rule[[2]] ]\n"
"    ];\n"
"    {result}\n"
"  ]\n"
");\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"exDSolve[expr_, initExpr_] := \n"
"Module[\n"
"  {tmpExpr, reducedExpr, rules, tVars, tVar, resultCons, unsolvable = False, resultRule, searchResult, retCode, restCond},\n"
"  inputPrint[\"exDSolve\", expr, initExpr];\n"
"  tmpExpr = applyList[expr];\n"
"  sol = {};\n"
"  resultCons = Select[tmpExpr, (Head[#] =!= Equal)&];\n"
"  tmpExpr = Complement[tmpExpr, resultCons];\n"
"  reducedExpr = Quiet[Check[Reduce[tmpExpr, Reals], tmpExpr], {Reduce::nsmet, Reduce::useq}];\n"
"  \n"
"  If[Head[reducedExpr] === And && MemberQ[reducedExpr, Element, Infinity, Heads->True], tmpExpr = applyList[reducedExpr] ];\n"
"  tmpInitExpr = applyList[initExpr];\n"
"  resultRule = {};\n"
"  simplePrint[resultCons, tmpExpr];\n"
"  While[True, \n"
"    searchResult = searchExprsAndVars[tmpExpr];\n"
"    If[searchResult === unExpandable,\n"
"      Break[],\n"
"      rules = solveByDSolve[searchResult[[1]], tmpInitExpr, searchResult[[3]]];\n"
"      If[rules === overConstraint || Length[rules] == 0, Return[overConstraint] ];\n"
"      \n"
"      If[Head[rules] === DSolve,\n"
"        resultCons = Union[resultCons, searchResult[[1]] ];\n"
"        tmpExpr = Complement[tmpExpr, searchResult[[1]] ];\n"
"        unsolvable = True;\n"
"        Continue[]\n"
"      ];\n"
"      resultRule = Union[resultRule, rules[[1]] ];\n"
"      simplePrint[resultRule];\n"
"      tmpExpr = applyDSolveResult[searchResult[[2]], rules[[1]] ];\n"
"      tmpExpr = Map[(If[!hasVariable[#], Reduce[#], #])&, tmpExpr];\n"
"      If[MemberQ[tmpExpr, ele /; (ele === False || (!hasVariable[ele] && MemberQ[ele, t, Infinity]))], Return[overConstraint] ];\n"
"      tmpExpr = Select[tmpExpr, (#=!=True)&];\n"
"      simplePrint[tmpExpr];\n"
"      resultCons = applyDSolveResult[resultCons, rules[[1]] ];\n"
"      If[MemberQ[resultCons, False], Return[overConstraint] ];\n"
"      resultCons = Select[resultCons, (#=!=True)&]\n"
"    ]\n"
"  ];\n"
"  retCode = If[Length[tmpExpr] > 0 || unsolvable, underConstraint, solved];\n"
"  restCond = LogicalExpand[And@@tmpExpr && And@@resultCons];\n"
"  restCond = Or2or[restCond];\n"
"  restCond = Map[(And2and[#])&, restCond];    \n"
"  { retCode, restCond, resultRule}\n"
"];\n"
"\n"
"\n"
"\n"
"searchExprsAndVars[exprs_] :=\n"
"Module[\n"
"  {tmpExprs, droppedExprs, searchResult = unExpandable, tVarsMap, tVars},\n"
"  simplePrint[exprs];\n"
"  For[i=1, i<=Length[exprs], i++,\n"
"    tVarsMap[ exprs[[i]] ] = Union[getVariables[exprs[[i]] ] ];\n"
"    tVars = tVarsMap[ exprs[[i]] ];\n"
"    If[Length[tVars] == 1,\n"
"      searchResult = {{ exprs[[i]] }, Drop[exprs, {i}], tVars}\n"
"    ]\n"
"  ];\n"
"    simplePrint[searchResult];\n"
"  If[searchResult === unExpandable,\n"
"    tmpExprs = Sort[exprs, (Length[tVarsMap[#1] ] < Length[tVarsMap[#2] ])&];\n"
"    For[tmpExprs, Length[tmpExprs] > 0 && searchResult === unExpandable, tmpExprs = droppedExprs,\n"
"      droppedExprs = Drop[tmpExprs, 1];\n"
"      searchResult = searchExprsAndVars[{tmpExprs[[1]]}, tVarsMap[tmpExprs[[1]] ], droppedExprs, tVarsMap]\n"
"    ]\n"
"  ];\n"
"  simplePrint[searchResult];\n"
"  searchResult\n"
"];\n"
"\n"
"\n"
"searchExprsAndVars[searchedExprs_, searchedVars_, exprs_, tVarsMap_] :=\n"
"Module[\n"
"  {tVar, tVarsInExpr, unionVars, i, j, k, appendExprs, searchResult},\n"
"  inputPrint[\"searchExprsAndVars\", searchedExprs, searchedVars, exprs, tVarsMap];\n"
"  For[i=1, i<=Min[Length[searchedVars], 2], i++,\n"
"    \n"
"    tVar = searchedVars[[i]];\n"
"    simplePrint[tVar];\n"
"    For[j=1, j<=Length[exprs], j++,\n"
"      tVarsInExpr = tVarsMap[ exprs[[j]] ];\n"
"      If[MemberQ[tVarsInExpr, tVar],\n"
"        unionVars = Union[tVarsInExpr, searchedVars];\n"
"        appendExprs = Append[searchedExprs, exprs[[j]] ];\n"
"        If[Length[unionVars] == Length[appendExprs],\n"
"          Return[{appendExprs, Drop[exprs, {j}], unionVars}],\n"
"          searchResult = searchExprsAndVars[appendExprs, unionVars, Drop[exprs, {j}], tVarsMap];\n"
"          If[searchResult =!= unExpandable, Return[searchResult] ]\n"
"        ]\n"
"      ]\n"
"    ]\n"
"  ];\n"
"  unExpandable\n"
"];\n"
"\n"
"  \n"
"solveByDSolve[expr_, initExpr_, tVars_] :=\n"
"solveByDSolve[expr, initExpr, tVars] = \n"
"Module[\n"
"  {tmpExpr, ini, sol, idx, generalInitValue, swapValue, j},\n"
"  tmpExpr = expr;\n"
"  ini = Select[initExpr, (hasSymbol[#, tVars ])& ];\n"
"  simplePrint[tmpExpr, ini, tVars];\n"
"  \n"
"  sol = Quiet[\n"
"    Check[\n"
"      DSolve[Union[tmpExpr, ini], Map[(#[t])&, tVars], t],\n"
"          overConstraint,\n"
"      {DSolve::overdet, DSolve::bvimp}\n"
"    ],\n"
"   {DSolve::overdet, DSolve::bvimp}\n"
"  ];\n"
"  simplePrint[sol];\n"
"  sol\n"
"];\n"
"\n"
"exDSolve::unkn = \"unknown error occurred in exDSolve\";\n"
"\n"
"checkConditions[] := (\n"
"  checkConditions[prevIneqs && And@@Map[(Equal@@#)&, prevRules], falseConditions, pConstraint, prevVariables ]\n"
");\n"
"\n"
"publicMethod[\n"
"  checkConditions,\n"
"  pCons, fCond, paramCons, vars,\n"
"  Module[\n"
"  {prevCons, falseCond, trueMap, falseMap, cpTrue, cpFalse, cpTmp},\n"
"   debugPrint[\"fcond\",fCond];\n"
"   If[fCond === 1, \n"
"    {True,False},\n"
"    prevCons = pCons;\n"
"    prevCons = prevCons /. Rule->Equal;\n"
"    If[prevCons[[0]] == List, prevCons[[0]] = And;];\n"
"    Quiet[\n"
"      cpTrue = Reduce[Exists[vars, Simplify[prevCons&&fCond&&paramCons] ], Reals], {Reduce::useq}\n"
"    ];\n"
"    simplePrint[cpTrue];\n"
"    checkMessage;\n"
"    Quiet[\n"
"      cpFalse = Reduce[paramCons && !cpTrue, Reals], {Reduce::useq}\n"
"    ];\n"
"    checkMessage;\n"
"    simplePrint[cpFalse];\n"
"      \n"
"    {trueMap, falseMap} = Map[(createMap[#, isParameter, hasParameter, {}])&, {cpTrue, cpFalse}];\n"
"    simplePrint[trueMap, falseMap];\n"
"    {trueMap, falseMap}\n"
"   ]\n"
"  ]\n"
"];\n"
"\n"
"\n"
"setConditions[co_, va_] := Module[\n"
"  {cons, vars},\n"
"  cons = co;\n"
"  falseConditions = cons;\n"
"  simplePrint[cons, falseConditions];\n"
"];\n"
"\n"
"\n"
"\n"
"createPrevMap[cons_, vars_] := Module[\n"
"  {map},\n"
"  If[cons === True || cons === False, \n"
"    cons,\n"
"\n"
"    map = cons /. (expr_ /; (( Head[expr] === Inequality || Head[expr] === Equal || Head[expr] === LessEqual || Head[expr] === Less|| Head[expr] === GreaterEqual || Head[expr] === Greater) && (hasVariable[expr] || hasParameter[expr] || !hasPrevVariable[expr])) -> False);\n"
"    map = Reduce[map, vars, Reals];\n"
"    map = cons /. (expr_ /; (( Head[expr] === Inequality || Head[expr] === Equal || Head[expr] === LessEqual || Head[expr] === Less|| Head[expr] === GreaterEqual || Head[expr] === Greater) && (hasVariable[expr] || hasParameter[expr] || !hasPrevVariable[expr])) -> False);\n"
"\n"
"    simplePrint[map];\n"
"    If[map =!= False, \n"
"      map = LogicalExpand[map];\n"
"      map = applyListToOr[map];\n"
"      map = Map[(applyList[#])&, map];\n"
"      debugPrint[\"@createMap map after applyList\", map];\n"
" \n"
"      map = Map[(convertExprs[ adjustExprs[#, isPrevVariable] ])&, map];\n"
"    ];\n"
"    map\n"
"  ]\n"
"];\n"
"\n"
"\n"
"findConditions[] := (\n"
"  findConditions[constraint && tmpConstraint && initConstraint && initTmpConstraint, variables ]\n"
");\n"
"\n"
"publicMethod[\n"
"  findConditions,\n"
"  cons, vars,\n"
"  Module[\n"
"    {cp},\n"
"    Quiet[\n"
"      cp = Reduce[Exists[vars, cons],Reals], {Reduce::useq}\n"
"    ];\n"
"    simplePrint[cp];\n"
"    checkMessage;\n"
"    If[cp =!= False && cp =!= True,\n"
"      cp = LogicalExpand[Simplify[cp] ];\n"
"5A      cp = toReturnForm[cp];\n"
"    ];\n"
"    simplePrint[cp];\n"
"    cp\n"
"  ]\n"
"];\n"
"\n"
"\n"
"\n"
"publicMethod[\n"
"  applyTime2Expr,\n"
"  expr, time,\n"
"  Module[\n"
"    {appliedExpr},\n"
"\n"
"    appliedExpr = (expr /. t -> time);\n"
"    If[Element[appliedExpr, Reals] =!= False,\n"
"      toReturnForm[Simplify[appliedExpr]],\n"
"      Message[applyTime2Expr::nrls, appliedExpr]\n"
"    ]\n"
"  ]\n"
"];\n"
"\n"
"applyTime2Expr::nrls = \"`1` is not a real expression.\";\n"
"\n"
"\n"
"\n"
"\n"
"publicMethod[\n"
"  exprTimeShift,\n"
"  expr, time,\n"
"  toReturnForm[Simplify[expr /. t -> t - time]]\n"
"];\n"
"\n"
"publicMethod[\n"
"  exprTimeShiftInverse,\n"
"  expr, time,\n"
"  toReturnForm[expr /. t -> t + time]\n"
"];\n"
"\n"
"\n"
"publicMethod[\n"
"  equivalent,\n"
"  lhs, rhs,\n"
"  Module[\n"
"    {},\n"
"    ToString[Reduce[Implies[lhs, rhs] && Implies[rhs, lhs], Reals] ]\n"
"  ]\n"
"];";
}
} //mathematica
} //backend
} //hydla
