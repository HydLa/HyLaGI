@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 698
@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 713
@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 621
@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 621
@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 553
@SequentialSimulator.cpp 48 function: dfs   *current: %% PhaseType: 0
%% id: 0
%% step: -1
%% no parent
%% unadopted modules: {}
%% positive_asks
%% negative_asks
%% end_time: 0
--- variable map ---

--- parameter constraint ---
{}

@Simulator.cpp 163 function: process_one_todo   
--- Current Todo ---
%% PhaseType: 1
%% id: 1
%% step: 0
%% parent_id:0
%% unadopted modules: {}
%% positive_asks
%% negative_asks
%% current_time: 0
--- variable map ---

--- parameter constraint ---
{}

@Simulator.cpp 164 function: process_one_todo   
--- prev map ---

@mathematica/MathematicaLink.cpp 151 function: receive_to_return_packet   input: 
setCurrentTime[0]

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: publicRet$198: Null

@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 433
@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 370
@PhaseSimulator.cpp 160 function: make_results_from_todo   *todo: %% PhaseType: 1
%% id: 1
%% step: 0
%% parent_id:0
%% unadopted modules: {}
%% positive_asks
%% negative_asks
%% current_time: 0
--- variable map ---

--- parameter constraint ---
{}

@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 404
@PhaseSimulator.cpp 197 function: make_results_from_todo   parameter_cons: {}
@mathematica/MathematicaLink.cpp 151 function: receive_to_return_packet   input: 
addParameterConstraint[True]

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: publicRet$204: Null

@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 1411
@mathematica/MathematicaLink.cpp 151 function: receive_to_return_packet   input: 
addParameterConstraint[True]

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: publicRet$206: Null

@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 463
@mathematica/MathematicaLink.cpp 151 function: receive_to_return_packet   input: 
addAssumption[True]

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: {"as in addAssumption:", True}

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: publicRet$208: Null

@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 382
@PhaseSimulator.cpp 324 function: simulate_ms   
--- next unadopted module set ---

@PhaseSimulator.cpp 697 function: calculate_closure   diff_sum: {x=1, x'=1, y=1, y'=1}
@ConsistencyChecker.cpp 195 function: check_entailment   get_infix_string(guard): y=2
@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 407
@mathematica/MathematicaLink.cpp 151 function: receive_to_return_packet   input: 
addInitEquation[uy,
	prev[py, 0]]

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: publicRet$212: Null

@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 431
@mathematica/MathematicaLink.cpp 151 function: receive_to_return_packet   input: 
addConstraint[uy == 1 && Derivative[1][dy] == 1]

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: publicRet$214: Null

@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 38098
@mathematica/MathematicaLink.cpp 151 function: receive_to_return_packet   input: 
checkConsistencyPoint[uy == 2 && uy == 1 && Derivative[1][dy] == 1,
	uy == prev[py, 0],
	True,
	True,
	{},
	{ux, uy, Derivative[1][dx], Derivative[1][dy]},
	{prev[px, 0], prev[px, 1], prev[py, 0], prev[py, 1]},
	{},
	0]

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: {"assum: ", True}

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: consToSolve$305: {prev[py, 0] == 2, prev[py, 0] == 1}

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: solved$280: False, resultConstraint: Derivative[1][dy] == 1 && prev[py, 0] == 2 && prev[py, 0] == 1

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: cpTrue$280: False

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: cpFalse$280: True

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: publicRet$279: {{False}, {True}}

@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 15695
@PhaseSimulator.cpp 778 function: calculate_closure   
--- conflicted ask ---
y=2=>y=0
@PhaseSimulator.cpp 697 function: calculate_closure   diff_sum: {x=1, x'=1, y=1, y'=1}
@ConsistencyChecker.cpp 195 function: check_entailment   get_infix_string(guard): x=2
@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 547
@mathematica/MathematicaLink.cpp 151 function: receive_to_return_packet   input: 
addInitEquation[ux,
	prev[px, 0]]

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: publicRet$332: Null

@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 641
@mathematica/MathematicaLink.cpp 151 function: receive_to_return_packet   input: 
addConstraint[ux == 1 && Derivative[1][dx] == 1]

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: publicRet$334: Null

@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 8982
@mathematica/MathematicaLink.cpp 151 function: receive_to_return_packet   input: 
checkConsistencyPoint[ux == 2 && ux == 1 && Derivative[1][dx] == 1,
	ux == prev[px, 0],
	True,
	True,
	{},
	{ux, uy, Derivative[1][dx], Derivative[1][dy]},
	{prev[px, 0], prev[px, 1], prev[py, 0], prev[py, 1]},
	{},
	0]

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: {"assum: ", True}

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: consToSolve$397: {prev[px, 0] == 2, prev[px, 0] == 1}

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: solved$372: False, resultConstraint: Derivative[1][dx] == 1 && prev[px, 0] == 2 && prev[px, 0] == 1

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: cpTrue$372: False

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: cpFalse$372: True

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: publicRet$371: {{False}, {True}}

@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 8974
@PhaseSimulator.cpp 778 function: calculate_closure   
--- conflicted ask ---
x=2=>x=0
@PhaseSimulator.cpp 697 function: calculate_closure   diff_sum: {x=1, x'=1, y=1, y'=1}
@ConsistencyChecker.cpp 414 function: check_consistency   related[1/2]: {x=1, x'=1}
@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 543
@mathematica/MathematicaLink.cpp 151 function: receive_to_return_packet   input: 
addConstraint[ux == 1 && Derivative[1][dx] == 1]

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: publicRet$420: Null

@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 733
@mathematica/MathematicaLink.cpp 151 function: receive_to_return_packet   input: 
checkConsistencyPoint[ux == 1 && Derivative[1][dx] == 1,
	True,
	True,
	True,
	{},
	{ux, uy, Derivative[1][dx], Derivative[1][dy]},
	{prev[px, 0], prev[px, 1], prev[py, 0], prev[py, 1]},
	{},
	0]

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: {"assum: ", True}

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: consToSolve$425: {}

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: solved$424: True, resultConstraint: ux == 1 && Derivative[1][dx] == 1

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: cpFalse$424: False

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: publicRet$423: {{True}, {False}}

@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 2491
@mathematica/MathematicaLink.cpp 151 function: receive_to_return_packet   input: 
createVariableMap[ux == 1 && Derivative[1][dx] == 1,
	{ux, uy, Derivative[1][dx], Derivative[1][dy]},
	True,
	{},
	0]

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: listToProcess$434[[i$434]]: ux == 1, newVars$434[[1]]: ux

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: tmpCons$434: ux == 1

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: listToProcess$434[[i$434]]: Derivative[1][dx] == 1, newVars$434[[1]]: Derivative[1][dx]

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: tmpCons$434: Derivative[1][dx] == 1

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: tmpCons$433: ux == 1 && Derivative[1][dx] == 1, succeeded: True

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: {"tmpCons after adjustExprs in createVariableMap", {{ux == 1, Derivative[1][dx] == 1}}}

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: map$433: {{{{ux, 0}, 0, "1"}, {{dx, 1}, 0, "1"}}}

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: publicRet$432: {{{{ux, 0}, 0, "1"}, {{dx, 1}, 0, "1"}}}

@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 2609
@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 434
@ConsistencyChecker.cpp 414 function: check_consistency   related[2/2]: {y=1, y'=1}
@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 508
@mathematica/MathematicaLink.cpp 151 function: receive_to_return_packet   input: 
addConstraint[uy == 1 && Derivative[1][dy] == 1]

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: publicRet$445: Null

@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 710
@mathematica/MathematicaLink.cpp 151 function: receive_to_return_packet   input: 
checkConsistencyPoint[uy == 1 && Derivative[1][dy] == 1,
	True,
	True,
	True,
	{},
	{ux, uy, Derivative[1][dx], Derivative[1][dy]},
	{prev[px, 0], prev[px, 1], prev[py, 0], prev[py, 1]},
	{},
	0]

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: {"assum: ", True}

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: consToSolve$450: {}

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: solved$449: True, resultConstraint: uy == 1 && Derivative[1][dy] == 1

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: cpFalse$449: False

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: publicRet$448: {{True}, {False}}

@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 1903
@mathematica/MathematicaLink.cpp 151 function: receive_to_return_packet   input: 
createVariableMap[uy == 1 && Derivative[1][dy] == 1,
	{ux, uy, Derivative[1][dx], Derivative[1][dy]},
	True,
	{},
	0]

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: listToProcess$459[[i$459]]: uy == 1, newVars$459[[1]]: uy

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: tmpCons$459: uy == 1

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: listToProcess$459[[i$459]]: Derivative[1][dy] == 1, newVars$459[[1]]: Derivative[1][dy]

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: tmpCons$459: Derivative[1][dy] == 1

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: tmpCons$458: uy == 1 && Derivative[1][dy] == 1, succeeded: True

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: {"tmpCons after adjustExprs in createVariableMap", {{uy == 1, Derivative[1][dy] == 1}}}

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: map$458: {{{{uy, 0}, 0, "1"}, {{dy, 1}, 0, "1"}}}

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: publicRet$457: {{{{uy, 0}, 0, "1"}, {{dy, 1}, 0, "1"}}}

@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 2144
@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 509
@PhaseSimulator.cpp 367 function: simulate_ms   CONSISTENT: {}
@mathematica/MathematicaLink.cpp 151 function: receive_to_return_packet   input: 
getParameterConstraint[]

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: publicRet$468: {True}

@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 520
@PhaseSimulator.cpp 1546 function: make_next_todo   *phase: %% PhaseType: 1
%% id: 1
%% step: 0
%% parent_id:0
%% unadopted modules: {}
%% positive_asks
%% negative_asks
%% current_time: 0
--- variable map ---
x <=> 1
y <=> 1
x' <=> 1
y' <=> 1

--- parameter constraint ---
{}

@mathematica/MathematicaLink.cpp 151 function: receive_to_return_packet   input: 
removeRedundantParameters[0,
	0,
	{ux == 1, uy == 1, Derivative[1][dx] == 1, Derivative[1][dy] == 1},
	True]

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: parsInVM$472: {}

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: redundantPars$472: {}

@mathematica/MathematicaLink.cpp 153 function: receive_to_return_packet   trace: publicRet$471: {True}

@Backend.cpp 421 function: call   call_timer.get_elapsed_us(): 978
@Simulator.cpp 183 function: process_one_todo   
--- Result Phase ---
%% PhaseType: 1
%% id: 1
%% step: 0
%% parent_id:0
%% unadopted modules: {}
%% positive_asks
%% negative_asks
%% current_time: 0
%% end_time: 0
--- variable map ---
x <=> 1
y <=> 1
x' <=> 1
y' <=> 1

--- parameter constraint ---
{}

@SequentialSimulator.cpp 48 function: dfs   *current: %% PhaseType: 1
%% id: 1
%% step: 0
%% parent_id:0
%% unadopted modules: {}
%% positive_asks
%% negative_asks
%% current_time: 0
%% end_time: 0
--- variable map ---
x <=> 1
y <=> 1
x' <=> 1
y' <=> 1

--- parameter constraint ---
{}

@SequentialSimulator.cpp 48 function: dfs   *current: %% PhaseType: 2
%% id: 2
%% step: 1
%% parent_id:1
%% unadopted modules: {}
%% positive_asks
%% negative_asks
%% current_time: 0
--- variable map ---

--- parameter constraint ---
{}

@SequentialSimulator.cpp 42 function: simulate   %% simulation ended


Constraint[LogicalAnd[Equal[Variable[y],Number[10]],Equal[Differential[Variable[y]],Number[0]]]]
{
  "Constraint":{
    "LogicalAnd":{
      "Equal":{
        "Variable":"y",
        "Number":10
      },
      "Equal1":{
        "Differential":{
          "Variable":"y"
        },
        "Number":10
      }
    }
  }
}











