#include "vcs_math_source.h"

const char* vcs_math_source() {
  return 
"\n"
"$RecursionLimit = 1000;\n"
"\n"
"\n"
"$MaxExtraPrecision = 1000;\n"
"\n"
"\n"
" \n"
"SetAttributes[debugPrint, HoldAll];\n"
"\n"
"If[optUseDebugPrint,\n"
"  debugPrint[arg___] := Print[InputForm[{arg}]], \n"
"  \n"
"  debugPrint[arg___] := Null];\n"
"\n"
"\n"
"\n"
"\n"
" \n"
"inputPrint[name_, arg___] := Print[StringJoin[name, \"[\", delimiterAddedString[\",\", Map[(ToString[InputForm[#] ])&,{arg}] ], \"]\" ] ];\n"
"\n"
"\n"
"delimiterAddedString[del_, {h_}] := h;\n"
"\n"
"delimiterAddedString[del_, {h_, t__}] := StringJoin[h, del, delimiterAddedString[del, {t}] ];\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"getReverseRelop[relop_] := Switch[relop,\n"
"                                  Equal, Equal,\n"
"                                  Less, Greater,\n"
"                                  Greater, Less,\n"
"                                  LessEqual, GreaterEqual,\n"
"                                  GreaterEqual, LessEqual];\n"
"\n"
"\n"
"\n"
"\n"
"checkConsistencyPoint[] := (\n"
"  checkConsistencyPoint[constraint && tmpConstraint && guard, pConstraint, Union[variables, tmpVariables, guardVars]]\n"
");\n"
"\n"
"checkConsistencyPoint[cons_, pcons_, vars_] := (\n"
"  Check[\n"
"    Block[\n"
"      {cpTrue, cpFalse},\n"
"      inputPrint[\"checkConsistencyPoint\", cons, pcons, vars];\n"
"      Quiet[\n"
"        cpTrue = Reduce[Exists[vars, cons && pcons], Reals], {Reduce::useq}\n"
"      ];\n"
"      Quiet[\n"
"        cpFalse = Reduce[pcons && !cpTrue, Reals], {Reduce::useq}\n"
"      ];\n"
"      {cpTrue, cpFalse} = Map[(createMap[#, hasParameter, {}])&, {cpTrue, cpFalse}];\n"
"      {cpTrue, cpFalse}\n"
"    ],\n"
"    {0, $MessageList, ToString[{cpTrue, cpFalse}]}\n"
"  ]\n"
");\n"
"\n"
"\n"
"\n"
"checkConsistencyInterval[] :=  (\n"
"  checkConsistencyInterval[constraint && tmpConstraint, pConstraint, guard, guardVars, Union[variables, tmpVariables]]\n"
");\n"
"\n"
"appendZeroVars[vars_] := Join[vars, vars /. x_[t] -> x[0]];\n"
"\n"
"\n"
"checkConsistencyInterval[cons_, pcons_, gua_, gVars_, vars_] :=  \n"
"Block[\n"
"  {tStore, sol, otherCons, originalOther, tCons, dVars, otherVars, i, cpTrue, cpFalse},\n"
"  Check[\n"
"    inputPrint[\"checkConsistencyInterval\", cons, pcons, gua, gVars, vars];\n"
"    sol = exDSolve[cons, vars];\n"
"    If[sol[[1]] === overConstraint,\n"
"      Return[{False, pcons}]\n"
"    ];\n"
"    \n"
"    If[sol[[1]] === underConstraint,\n"
"      \n"
"      tStore = {};\n"
"      otherVars = vars;\n"
"      otherCons = cons,\n"
"      \n"
"      \n"
"      originalOther = And[And@@sol[[2]], gua];\n"
"      otherCons = False;\n"
"      dVars = sol[[3]];\n"
"      otherVars = sol[[4]];\n"
"      For[i = 1, i <= Length[sol[[1]] ], i++,\n"
"        tStore = Map[(# -> createIntegratedValue[#, sol[[1]] [[i]]])&, dVars];\n"
"        otherCons = Or[otherCons, originalOther /. tStore ]\n"
"      ]\n"
"    ];\n"
"    \n"
"    tCons = Reduce[Exists[Evaluate[Union[appendZeroVars[otherVars], gVars]], otherCons && pcons], Reals];\n"
"    If[tCons === False, Return[{False, pcons}] ];\n"
"    \n"
"    cpTrue = Reduce[Quiet[Minimize[{t, tCons && t > 0}, t], {Minimize::wksol, Minimize::infeas}][[1]] == 0, Reals];\n"
"    \n"
"    cpFalse = Reduce[pcons && !cpTrue, Reals];\n"
"    {cpTrue, cpFalse} = Map[(createMap[#, hasParameter, {}])&, {cpTrue, cpFalse}];\n"
"    {cpTrue, cpFalse}\n"
"    ,\n"
"    {0, $MessageList, {tStore, sol, otherCons, originalOther, tCons, dVars, otherVars, i, cpTrue, cpFalse}}\n"
"  ]\n"
"]\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"createVariableMap[] := createVariableMap[constraint, variables];\n"
"\n"
"\n"
"createVariableMap[cons_, vars_] := Block[\n"
"  {ret},\n"
"  inputPrint[\"createVariableMap\", cons, vars];\n"
"  ret = createMap[cons, hasVariable, vars];\n"
"  ret = Map[(Cases[#, Except[{parameter[___], _, _}] ])&, ret];\n"
"  debugPrint[ret];\n"
"  ret\n"
"];\n"
"\n"
"\n"
"createVariableMapInterval[] := createVariableMapInterval[constraint, variables, parameters];\n"
"\n"
"createVariableMapInterval[cons_, vars_, pars_] := Block[\n"
"  {sol, originalOther, otherCons, dVars, tStore, cStore, i, ret},\n"
"  inputPrint[\"createVariableMapInterval\", cons, vars, pars];\n"
"  sol = exDSolve[cons, vars];\n"
"  \n"
"  originalOther = And@@sol[[2]];\n"
"  cStore = False;\n"
"  dVars = sol[[3]];\n"
"  otherVars = sol[[4]];\n"
"  For[i = 1, i <= Length[sol[[1]] ], i++,\n"
"    tStore = Map[(# -> createIntegratedValue[#, sol[[1]] [[i]]])&, dVars];\n"
"    cStore = Or[cStore, (originalOther /. tStore) && And@@Map[(Equal@@#)&, tStore] ]\n"
"  ];\n"
"  ret = createMap[cStore && t>0, hasVariable, vars];\n"
"  ret = Map[(Cases[#, Except[{parameter[___], _, _}] ])&, ret];\n"
"  debugPrint[ret];\n"
"  ret\n"
"];\n"
"\n"
"createParameterMap[] := createMap[pConstraint, hasParameter, {}];\n"
"\n"
"createMap[cons_, judge_, vars_] := Block[\n"
"  {map},\n"
"  inputPrint[\"createMap\", cons, judge, vars];\n"
"  If[cons === True || cons === False, Return[cons]];\n"
"  \n"
"  map = Reduce[Exists[Evaluate[Cases[vars, prev[_,_]]], cons], vars, Reals];\n"
"  \n"
"  map = LogicalExpand[map];\n"
"  map = applyListToOr[map];\n"
"  map = Map[(applyList[#])&, map];\n"
"  \n"
"  map = Map[(convertExprs[ adjustExprs[#, judge] ])&, map];\n"
"  debugPrint[map];\n"
"  map\n"
"];\n"
"\n"
"\n"
"\n"
"\n"
"hasVariable[exprs_] := Length[StringCases[ToString[exprs], \"usrVar\" ~~ LetterCharacter]] > 0;\n"
"\n"
"\n"
"\n"
"getVariables[exprs_] := ToExpression[StringCases[ToString[exprs], \"usrVar\" ~~ LetterCharacter..]];\n"
"\n"
"\n"
"\n"
"\n"
"hasParameter[exprs_] := Length[StringCases[ToString[exprs], \"parameter[\" ~~ LetterCharacter]] > 0;\n"
"\n"
"\n"
"\n"
"\n"
"adjustExprs[andExprs_, judgeFunction_] := \n"
"  Fold[\n"
"    (If[Not[judgeFunction[#2[[1]] ] ] && judgeFunction[#2[[2]] ],\n"
"       \n"
"       Append[#1, getReverseRelop[Head[#2] ][#2[[2]], #2[[1]] ] ],\n"
"       Append[#1, #2]]) &,\n"
"    {},\n"
"    andExprs\n"
"  ];\n"
"\n"
"\n"
"resetConstraint[] := (\n"
"  constraint = True;\n"
"  pConstraint = True;\n"
"  tmpConstraint = True;\n"
"  variables = tmpVariables = prevVariables = {};\n"
"  isTemporary = False;\n"
"  guard = True;\n"
"  guardVars = {};\n"
"  parameters = {};\n"
");\n"
"\n"
"\n"
"addConstraint[cons_, vars_] := (\n"
"  If[isTemporary,\n"
"    tmpVariables = Union[tmpVariables, vars];\n"
"    tmpConstraint = Reduce[tmpConstraint && cons, tmpVariables, Reals],\n"
"	variables = Union[variables, vars];\n"
"	constraint = Reduce[constraint && cons, variables, Reals]\n"
"  ];\n"
"  debugPrint[cons, vars, constraint, variables, tmpConstraint, tmpVariables];\n"
");\n"
"\n"
"addVariables[vars_] := (\n"
"  If[isTemporary,\n"
"    tmpVariables = Union[tmpVariables, vars],\n"
"	variables = Union[variables, vars]\n"
"  ];\n"
"  debugPrint[vars, variables, tmpVariables];\n"
");\n"
"\n"
"setGuard[gu_, vars_] := (\n"
"  guard = gu;\n"
"  guardVars = vars;\n"
"  debugPrint[ gu, vars, guard, guardVars];\n"
");\n"
"\n"
"startTemporary[] := (\n"
"  isTemporary = True;\n"
");\n"
"\n"
"endTemporary[] := (\n"
"  isTemporary = False;\n"
"  resetTemporaryConstraint[];\n"
");\n"
"\n"
"resetTemporaryConstraint[] := (\n"
"  tmpConstraint = True;\n"
"  tmpVariables = {};\n"
"  guard = True;\n"
"  guardVars = {};\n"
");\n"
"\n"
"\n"
"addParameterConstraint[pcons_, pars_] := (\n"
"  pConstraint = Reduce[pConstraint && pcons, Reals];\n"
"  parameters = Union[parameters, pars];\n"
"  debugPrint[pConstraint, pars];\n"
");\n"
"\n"
"\n"
"\n"
"removeDash[var_] := Block[\n"
"   {ret},\n"
"   If[Head[var] === parameter, Return[var]];\n"
"   ret = var /. x_[t] -> x;\n"
"   If[MatchQ[Head[ret], Derivative[_]],\n"
"     ret /. Derivative[d_][x_] -> {x, d},\n"
"     {ret, 0}\n"
"   ]\n"
"];\n"
"\n"
"\n"
"\n"
"applyList[reduceSol_] :=\n"
"  If[Head[reduceSol] === And, List @@ reduceSol, List[reduceSol]];\n"
"\n"
"\n"
"\n"
"\n"
"applyListToOr[reduceSol_] :=\n"
"  If[Head[reduceSol] === Or, List @@ reduceSol, List[reduceSol]];\n"
"\n"
"\n"
"\n"
"\n"
"makeListFromPiecewise[minT_, others_] := Block[\n"
"  {tmpCondition = False},\n"
"  tmpCondition = Or @@ Map[(#[[2]])&, minT[[1]]];\n"
"  tmpCondition = Reduce[And[others, Not[tmpCondition]], Reals];\n"
"  If[ tmpCondition === False,\n"
"    minT[[1]],\n"
"    Append[minT[[1]], {minT[[2]], tmpCondition}]\n"
"  ]\n"
"];\n"
"\n"
"\n"
"\n"
" \n"
"calculateNextPointPhaseTime[maxTime_, discCause_] := \n"
"  calculateNextPointPhaseTime[maxTime, discCause, constraint, pConstraint, variables];\n"
"\n"
"\n"
"\n"
"\n"
"divideDisjunction[timeCond_] := Map[({timeCond[[1]], #})&, List@@timeCond[[2]]];\n"
"\n"
"\n"
"getExprCode[expr_] := Switch[Head[expr],\n"
"  Equal, 0,\n"
"  Less, 1,\n"
"  Greater, 2,\n"
"  LessEqual, 3,\n"
"  GreaterEqual, 4\n"
"];\n"
"\n"
"\n"
"replaceIntegerToString[num_] := If[num < 0, minus[IntegerString[num]], IntegerString[num] ];\n"
"integerString[expr_] := (\n"
"  expr /. (x_Rational :> Rational[replaceIntegerToString[Numerator[x] ], replaceIntegerToString[Denominator[x] ] ])\n"
"       /. (x_Integer :> replaceIntegerToString[x])\n"
");\n"
"\n"
"\n"
"\n"
"\n"
"convertExprs[list_] := Map[({removeDash[ #[[1]] ], getExprCode[#], integerString[FullSimplify[#[[2]] ] ] } )&, list];\n"
"\n"
"calculateNextPointPhaseTime[maxTime_, discCause_, cons_, pCons_, vars_] := Check[\n"
"  Block[\n"
"    {\n"
"      dSol,\n"
"      timeAppliedCauses,\n"
"      resultList,\n"
"      originalOther\n"
"    },\n"
"    \n"
"    inputPrint[\"calculateNextPointPhaseTime\", maxTime, discCause, cons, pCons, vars];\n"
"    \n"
"    \n"
"    dSol = exDSolve[cons, vars];\n"
"    \n"
"    \n"
"    \n"
"    dVars = dSol[[3]];\n"
"    timeAppliedCauses = False;\n"
"    For[i = 1, i <= Length[dSol[[1]] ], i++,\n"
"      tStore = Map[(# -> createIntegratedValue[#, dSol[[1]] [[i]]])&, dVars];\n"
"      timeAppliedCauses = Or[timeAppliedCauses, Or@@discCause /. tStore ]\n"
"    ];\n"
"    \n"
"    \n"
"      \n"
"    \n"
"    resultList = Quiet[Minimize[{t, (timeAppliedCauses || t == maxTime) && pCons && t>0}, {t}], \n"
"                           {Minimize::wksol, Minimize::infeas}];\n"
"    resultList = First[resultList];\n"
"\n"
"    If[Head[resultList] === Piecewise, resultList = makeListFromPiecewise[resultList, pCons], resultList = {{resultList, pCons}}];\n"
"    \n"
"    \n"
"    \n"
"    resultList = Map[({#[[1]],LogicalExpand[#[[2]] ]})&, resultList];\n"
"    resultList = Fold[(Join[#1, If[Head[#2[[2]]]===Or, divideDisjunction[#2], {#2}]])&,{}, resultList];\n"
"    resultList = Map[({#[[1]], Cases[applyList[#[[2]] ], Except[True]] })&, resultList];\n"
"    resultList = Map[({integerString[FullSimplify[#[[1]] ] ], convertExprs[adjustExprs[#[[2]], hasParameter ] ], If[FullSimplify[#[[1]] ] === FullSimplify[maxTime], 1, 0]})&, resultList];\n"
"    {1, resultList}\n"
"  ],\n"
"  {0, $MessageList}\n"
"];\n"
"\n"
"\n"
"getDerivativeCount[variable_[_]] := 0;\n"
"\n"
"getDerivativeCount[Derivative[n_][f_][_]] := n;\n"
"\n"
"\n"
"createIntegratedValue[variable_, integRule_] := (\n"
"  Simplify[\n"
"    variable /. Map[(Rule[#[[1]] /. x_[t]-> x, #[[2]]])&, integRule]\n"
"             /. Derivative[n_][f_] :> D[f, {t, n}] \n"
"             /. x_[t] -> x]\n"
");\n"
"\n"
"\n"
"\n"
"\n"
"exDSolve[expr_, vars_] := \n"
"Quiet[\n"
"  Block[\n"
"    {sol, dExpr, dVars, otherExpr, otherVars},\n"
"    \n"
"    sol = Reduce[Exists[Evaluate[Cases[vars, prev[_,_]]], expr], vars, Reals];\n"
"    {dExpr, dVars, otherExpr, otherVars} = splitExprs[sol];\n"
"    \n"
"    \n"
"    If[dExpr === {},\n"
"      \n"
"      Return[{underConstraint, otherExpr}]\n"
"    ];\n"
"    Check[\n"
"      Check[\n"
"        sol = DSolve[dExpr, dVars, t];\n"
"        {sol, otherExpr, dVars, otherVars},\n"
"        {underConstraint, otherExpr},\n"
"        {DSolve::underdet, Solve::svars}\n"
"      ],\n"
"      {overConstraint, otherExpr},\n"
"      {DSolve::overdet}\n"
"    ]\n"
"  ]\n"
"];\n"
"\n"
"\n"
"\n"
"\n"
"splitExprs[expr_] := Block[\n"
"  {dExprs, appendedTimeVars, dVars, iter, otherExprs, otherVars, getTimeVars, getNoInitialTimeVars, timeVars, exprStack},\n"
"  \n"
"  getTimeVars[list1_, list2_] := Union[list1, Cases[list2, _[t] | _[0], Infinity] /. x_[0] -> x[t]];\n"
"  getNoInitialTimeVars[list_] := Union[Cases[list, _[t], Infinity] /. Derivative[_][f_][_] -> f[t]];\n"
"  \n"
"  \n"
"  otherExprs = dExprs = appendedTimeVars = {};\n"
"  exprStack = List@@expr;\n"
"  iter = 0;\n"
"  While[Length[exprStack] > 0,\n"
"    iter++;\n"
"    timeVars = getNoInitialTimeVars[exprStack[[1]] ];\n"
"    \n"
"    If[Length[Select[timeVars, (FreeQ[appendedTimeVars, #])& ] ] > 1 && iter<Length[exprStack] ,\n"
"      exprStack = Append[exprStack, exprStack[[1]] ],\n"
"      iter = 0;\n"
"      If[Head[exprStack[[1]] ] =!= Equal || (Length[timeVars] > 0 && Length[Select[timeVars, (FreeQ[appendedTimeVars, #])& ] ] == 0),\n"
"        otherExprs = Append[otherExprs, exprStack[[1]] ],\n"
"        dExprs = Append[dExprs, exprStack[[1]] ];\n"
"        appendedTimeVars = Union[appendedTimeVars, timeVars]\n"
"      ];\n"
"    ];\n"
"    exprStack = Delete[exprStack, 1]\n"
"  ];\n"
"  \n"
"  \n"
"  dVars = Fold[(getTimeVars[#1,#2])&, {}, dExprs];\n"
"  otherVars = Fold[(getTimeVars[#1,#2])&, {}, otherExprs];\n"
"  {dExprs, dVars, otherExprs, otherVars}\n"
"];\n"
"\n"
"\n"
"\n"
"\n"
"applyTime2Expr[expr_, time_] := Block[\n"
"  {appliedExpr},\n"
"  debugPrint[expr, time];\n"
"  appliedExpr = Simplify[(expr /. t -> time)];\n"
"  If[Element[appliedExpr, Reals] =!= False,\n"
"    {1, integerString[appliedExpr]},\n"
"    {0}]\n"
"];\n"
"\n"
"\n"
"approxExpr[precision_, expr_] :=\n"
"  integerString[Rationalize[N[Simplify[expr], precision + 3], \n"
"              Divide[1, Power[10, precision]]]];\n"
"\n"
"\n"
"\n"
"\n"
"exprTimeShift[expr_, time_] := integerString[Simplify[expr /. t -> t - time ]]";
}