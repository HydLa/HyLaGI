@ParseTree.cpp 54 function: parse   
--- Parse Tree ---
--- node_tree ---
Parallel[Constraint[ConstraintCall<INIT()>],Weaker[Constraint[ConstraintCall<FALL()>],Constraint[ConstraintCall<BOUNCE()>]]]
--- variables ---

@ParseTree.cpp 55 function: parse   
--- Constraint Definition ---
key: BOUNCE<0> val: BOUNCE():=Constraint[Always[Ask[Equal[Previous[Variable[y]],Number[0]],Constraint[Equal[Differential[Variable[y]],Times[Divide[Negative[Number[4]],Number[5]],Previous[Differential[Variable[y]]]]]]]]]
key: FALL<0> val: FALL():=Constraint[Always[Equal[Differential[Differential[Variable[y]]],Negative[Number[10]]]]]
key: INIT<0> val: INIT():=Constraint[Greater[Variable[y],Number[0]]]

@ParseTree.cpp 56 function: parse   
--- Program Definition ---

@ParseTree.cpp 57 function: parse   
--- Expression List Definition ---

@ParseTree.cpp 58 function: parse   
--- Program List Definition ---

@ParseTree.cpp 64 function: parse   
--- Analyzed Parse Tree ---
--- node_tree ---
Parallel[Constraint[ConstraintCall<INIT()>[Greater[Variable[y],Number[0]]]],Weaker[Constraint[ConstraintCall<FALL()>[Always[Equal[Differential[Differential[Variable[y]]],Negative[Number[10]]]]]],Constraint[ConstraintCall<BOUNCE()>[Always[Ask[Equal[Previous[Variable[y]],Number[0]],Equal[Differential[Variable[y]],Times[Divide[Negative[Number[4]],Number[5]],Previous[Differential[Variable[y]]]]]]]]]]]
--- variables ---
y : 2

@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
resetVariables[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$714: Null

@Backend.cpp 421 function: call   resetVariables
timer elapsed: 204[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addVariable[uy,
	0]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$716: Null

@Backend.cpp 421 function: call   addVariable
timer elapsed: 232[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addVariable[uy,
	1]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$720: Null

@Backend.cpp 421 function: call   addVariable
timer elapsed: 245[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addVariable[uy,
	2]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$724: Null

@Backend.cpp 421 function: call   addVariable
timer elapsed: 206[us]
@HybridAutomatonConverter.cpp 68 function: HA_translate   *current: %% PhaseType: 0
%% id: 0
%% step: -1
%% no parent
%% unadopted modules: {}
%% positive_asks
%% negative_asks
%% end_time: 0
--- variable map ---

--- parameter constraint ---
{}

@Simulator.cpp 165 function: process_one_todo   
--- Current Todo ---
%% PhaseType: 1
%% id: 1
%% step: 0
%% parent_id:0
%% unadopted modules: {}
%% positive_asks
%% negative_asks
%% current_time: 0
--- variable map ---

--- parameter constraint ---
{}

@Simulator.cpp 166 function: process_one_todo   
--- prev map ---

@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
setCurrentTime[0]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$728: Null

@Backend.cpp 421 function: call   setCurrentTime
timer elapsed: 143[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
resetConstraint[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$730: Null

@Backend.cpp 421 function: call   resetConstraint
timer elapsed: 140[us]
@PhaseSimulator.cpp 162 function: make_results_from_todo   *todo: %% PhaseType: 1
%% id: 1
%% step: 0
%% parent_id:0
%% unadopted modules: {}
%% positive_asks
%% negative_asks
%% current_time: 0
--- variable map ---

--- parameter constraint ---
{}

@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
clearPrevConstraint[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$732: Null

@Backend.cpp 421 function: call   clearPrevConstraint
timer elapsed: 143[us]
@PhaseSimulator.cpp 199 function: make_results_from_todo   parameter_cons: {}
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addParameterConstraint[True]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"pConstraint", True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"pCons", True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$734: Null

@Backend.cpp 421 function: call   addParameterConstraint
timer elapsed: 872[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addParameterConstraint[True]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"pConstraint", True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"pCons", True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$736: Null

@Backend.cpp 421 function: call   addParameterConstraint
timer elapsed: 235[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addAssumption[True]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"as in addAssumption:", True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$738: Null

@Backend.cpp 421 function: call   addAssumption
timer elapsed: 165[us]
@PhaseSimulator.cpp 326 function: simulate_ms   
--- next unadopted module set ---

@PhaseSimulator.cpp 701 function: calculate_closure   diff_sum: {y>0, y''=-10}
@ConsistencyChecker.cpp 398 function: check_consistency   related[1/1]: {y>0, y''=-10}
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
resetConstraintForVariable[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$740: Null

@Backend.cpp 421 function: call   resetConstraintForVariable
timer elapsed: 146[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addConstraint[uy > 0 && Derivative[2][dy] == -10]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$742: Null

@Backend.cpp 421 function: call   addConstraint
timer elapsed: 2909[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
checkConsistencyPoint[uy > 0 && Derivative[2][dy] == -10,
	True,
	True,
	True,
	{},
	{uy, Derivative[1][dy], Derivative[2][dy]},
	{prev[py, 0], prev[py, 1], prev[py, 2]},
	{},
	0]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"assum: ", True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: consToSolve$750: {}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: solved$749: False, resultConstraint: Derivative[2][dy] == -10 && uy > 0

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: cpTrue$749: True

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: cpFalse$749: False

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$748: {{True}, {False}}

@Backend.cpp 421 function: call   checkConsistencyPoint
timer elapsed: 3575[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
createVariableMap[Derivative[2][dy] == -10 && uy > 0,
	{uy, Derivative[1][dy], Derivative[2][dy]},
	True,
	{},
	0]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: listToProcess$762[[i$762]]: Derivative[2][dy] == -10, newVars$762[[1]]: Derivative[2][dy]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: tmpCons$762: Derivative[2][dy] == -10

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: listToProcess$762[[i$762]]: uy > 0, newVars$762[[1]]: uy

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: tmpCons$762: uy > 0

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: tmpCons$761: Derivative[2][dy] == -10 && uy > 0, succeeded: True

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"tmpCons after adjustExprs in createVariableMap", {{Derivative[2][dy] == -10, uy > 0}}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: map$761: {{{{dy, 2}, 0, minus["10"]}, {{uy, 0}, 2, "0"}}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$760: {{{{dy, 2}, 0, minus["10"]}, {{uy, 0}, 2, "0"}}}

@Backend.cpp 421 function: call   createVariableMap
timer elapsed: 4387[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
getSizeOfConstraint[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$772: 312

@Backend.cpp 421 function: call   getSizeOfConstraint
timer elapsed: 176[us]
@PhaseSimulator.cpp 369 function: simulate_ms   CONSISTENT: {}
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
getParameterConstraint[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$774: {True}

@Backend.cpp 421 function: call   getParameterConstraint
timer elapsed: 199[us]
@PhaseSimulator.cpp 1557 function: make_next_todo   *phase: %% PhaseType: 1
%% id: 1
%% step: 0
%% parent_id:0
%% unadopted modules: {}
%% positive_asks
%% negative_asks
%% current_time: 0
--- variable map ---
y <=> (0, inf)
y'' <=> -10

--- parameter constraint ---
{}

@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
removeRedundantParameters[0,
	0,
	{uy > 0, Derivative[2][dy] == -10},
	True]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: parsInVM$778: {}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: redundantPars$778: {}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$777: {True}

@Backend.cpp 421 function: call   removeRedundantParameters
timer elapsed: 425[us]
@Simulator.cpp 185 function: process_one_todo   
--- Result Phase ---
%% PhaseType: 1
%% id: 1
%% step: 0
%% parent_id:0
%% unadopted modules: {}
%% positive_asks
%% negative_asks
%% current_time: 0
%% end_time: 0
--- variable map ---
y <=> (0, inf)
y'' <=> -10

--- parameter constraint ---
{}

@HybridAutomatonConverter.cpp 68 function: HA_translate   *current: %% PhaseType: 1
%% id: 1
%% step: 0
%% parent_id:0
%% unadopted modules: {}
%% positive_asks
%% negative_asks
%% current_time: 0
%% end_time: 0
--- variable map ---
y <=> (0, inf)
y'' <=> -10

--- parameter constraint ---
{}

@Simulator.cpp 165 function: process_one_todo   
--- Current Todo ---
%% PhaseType: 2
%% id: 2
%% step: 1
%% parent_id:1
%% unadopted modules: {}
%% positive_asks
%% negative_asks
%% current_time: 0
--- variable map ---

--- parameter constraint ---
{}

@Simulator.cpp 166 function: process_one_todo   
--- prev map ---

@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
resetConstraint[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$782: Null

@Backend.cpp 421 function: call   resetConstraint
timer elapsed: 200[us]
@PhaseSimulator.cpp 162 function: make_results_from_todo   *todo: %% PhaseType: 2
%% id: 2
%% step: 1
%% parent_id:1
%% unadopted modules: {}
%% positive_asks
%% negative_asks
%% current_time: 0
--- variable map ---

--- parameter constraint ---
{}

@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
clearPrevConstraint[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$784: Null

@Backend.cpp 421 function: call   clearPrevConstraint
timer elapsed: 191[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addPrevConstraint[prev[py, 0] > 0]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$786: Null

@Backend.cpp 421 function: call   addPrevGreater
timer elapsed: 225[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addPrevEqual[prev[py, 2],
	-10]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$788: Null

@Backend.cpp 421 function: call   addPrevEqual
timer elapsed: 217[us]
@PhaseSimulator.cpp 199 function: make_results_from_todo   parameter_cons: {}
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addParameterConstraint[True]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"pConstraint", True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"pCons", True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$790: Null

@Backend.cpp 421 function: call   addParameterConstraint
timer elapsed: 272[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addParameterConstraint[True]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"pConstraint", True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"pCons", True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$792: Null

@Backend.cpp 421 function: call   addParameterConstraint
timer elapsed: 267[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addAssumption[True]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"as in addAssumption:", True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$794: Null

@Backend.cpp 421 function: call   addAssumption
timer elapsed: 227[us]
@PhaseSimulator.cpp 326 function: simulate_ms   
--- next unadopted module set ---

@PhaseSimulator.cpp 701 function: calculate_closure   diff_sum: {y>0, y''=-10}
@ConsistencyChecker.cpp 179 function: check_entailment   get_infix_string(guard): y-=0
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
resetConstraintForVariable[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$796: Null

@Backend.cpp 421 function: call   resetConstraintForVariable
timer elapsed: 199[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addInitEquation[uy[0],
	prev[py, 0]]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$798: Null

@Backend.cpp 421 function: call   addInitEquation
timer elapsed: 220[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addInitEquation[Derivative[1][uy][0],
	prev[py, 1]]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$801: Null

@Backend.cpp 421 function: call   addInitEquation
timer elapsed: 235[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addConstraint[Derivative[2][uy][t] == -10]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$804: Null

@Backend.cpp 421 function: call   addConstraint
timer elapsed: 463[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
checkConsistencyInterval[uy[t] == 0 && Derivative[2][uy][t] == -10,
	uy[0] == prev[py, 0] && Derivative[1][uy][0] == prev[py, 1],
	True,
	{uy[t], Derivative[1][uy][t], Derivative[2][uy][t]},
	{prev[py, 2] -> -10},
	prev[py, 0] > 0,
	True,
	{}]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: exDSolve[uy[t] == 0 && Derivative[2][uy][t] == -10,
	{prev[py, 2] -> -10}]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: listExpr$811: {uy[t] == 0, Derivative[2][uy][t] == -10}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: prevs$812: {uy, Derivative[1][uy]}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {uy[t] == 0, uy''[t] == -10}: {uy[t] == 0, Derivative[2][uy][t] == -10}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {uy, uy}: {uy, uy}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: solwithconstant$812: overConstrained

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: searchResult$811: {{Derivative[2][uy][t] == -10}, {uy[t] == 0}, {uy}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: prevs$821: {uy, Derivative[1][uy]}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {uy''[t] == -10}: {Derivative[2][uy][t] == -10}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {uy}: {uy}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: solwithconstant$821: {{uy -> Function[{t}, -5*t^2 + C[1] + t*C[2]]}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: constants$821: {C[1], C[2]}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: inis$821: {{C[1] == prev[py, 0], C[2] == prev[py, 1]}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: solofconstant$821: {{C[1] -> prev[py, 0], C[2] -> prev[py, 1]}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: rules$811: {{uy[t] -> -5*t^2 + prev[py, 0] + t*prev[py, 1]}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: sol$808: overConstrained

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"sol after exDSolve", overConstrained}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$807: {{False}, {True}}

@Backend.cpp 421 function: call   checkConsistencyInterval
timer elapsed: 21561[us]
@PhaseSimulator.cpp 783 function: calculate_closure   
--- conflicted ask ---
y-=0=>y'=-4/5*y'-
@PhaseSimulator.cpp 701 function: calculate_closure   diff_sum: {y>0, y''=-10}
@ConsistencyChecker.cpp 398 function: check_consistency   related[1/1]: {y''=-10}
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
resetConstraintForVariable[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$845: Null

@Backend.cpp 421 function: call   resetConstraintForVariable
timer elapsed: 267[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addConstraint[Derivative[2][uy][t] == -10]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$847: Null

@Backend.cpp 421 function: call   addConstraint
timer elapsed: 346[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
checkConsistencyInterval[Derivative[2][uy][t] == -10,
	True,
	True,
	{uy[t], Derivative[1][uy][t], Derivative[2][uy][t]},
	{prev[py, 2] -> -10},
	prev[py, 0] > 0,
	True,
	{}]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: exDSolve[Derivative[2][uy][t] == -10,
	{prev[py, 2] -> -10}]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: listExpr$852: {Derivative[2][uy][t] == -10}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: resultRule$852: {uy[t] -> -5*t^2 + prev[py, 0] + t*prev[py, 1]}, resultCons$852: t > 0, {prev[py, 2] -> -10}: {prev[py, 2] -> -10}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: sol$851: {solved, or[and[]], {uy[t] -> -5*t^2 + prev[py, 0] + t*prev[py, 1]}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"sol after exDSolve", {solved, or[and[]], {uy[t] -> -5*t^2 + prev[py, 0] + t*prev[py, 1]}}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {{uy[t] -> -5*t^2 + prev[py, 0] + t*prev[py, 1], Derivative[1][uy][t] -> -10*t + prev[py, 1], Derivative[2][uy][t] -> -10}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: tRules$851: {uy[t] -> -5*t^2 + prev[py, 0] + t*prev[py, 1], Derivative[1][uy][t] -> -10*t + prev[py, 1], Derivative[2][uy][t] -> -10}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"hoge"}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {Derivative[2][uy][t] == -10}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {{prev[py, 2] -> -10}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {{uy[t] -> -5*t^2 + prev[py, 0] + t*prev[py, 1], Derivative[1][uy][t] -> -10*t + prev[py, 1], Derivative[2][uy][t] -> -10}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: tCons$851: or[and[]]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"cpFalse", cpFalse$851}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$850: {{prev[py, "0"] > "0"}, {False}}

@Backend.cpp 421 function: call   checkConsistencyInterval
timer elapsed: 4509[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
createVariableMapInterval[Derivative[2][uy][t] == -10,
	{prev[py, 2] -> -10},
	{uy[t], Derivative[1][uy][t], Derivative[2][uy][t]}]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: exDSolve[Derivative[2][uy][t] == -10,
	{prev[py, 2] -> -10}]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: listExpr$880: {Derivative[2][uy][t] == -10}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: resultRule$880: {uy[t] -> -5*t^2 + prev[py, 0] + t*prev[py, 1]}, resultCons$880: t > 0, {prev[py, 2] -> -10}: {prev[py, 2] -> -10}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"sol after exDSolve", {solved, or[and[]], {uy[t] -> -5*t^2 + prev[py, 0] + t*prev[py, 1]}}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$878: {{{{uy, 0}, 0, t^"2"*minus["5"] + prev[py, "0"] + t*prev[py, "1"]}, {{uy, 1}, 0, t*minus["10"] + prev[py, "1"]}, {{uy, 2}, 0, minus["10"]}}}

@Backend.cpp 421 function: call   createVariableMapInterval
timer elapsed: 2125[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
getSizeOfConstraint[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$912: 432

@Backend.cpp 421 function: call   getSizeOfConstraint
timer elapsed: 251[us]
@PhaseSimulator.cpp 369 function: simulate_ms   CONSISTENT: {}
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
getParameterConstraint[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$914: {True}

@Backend.cpp 421 function: call   getParameterConstraint
timer elapsed: 244[us]
@PhaseSimulator.cpp 1557 function: make_next_todo   *phase: %% PhaseType: 2
%% id: 2
%% step: 1
%% parent_id:1
%% unadopted modules: {}
%% positive_asks
%% negative_asks
%% current_time: 0
--- variable map ---
y <=> t^2*(-5)+y-+t*y'-
y' <=> t*(-10)+y'-
y'' <=> -10

--- parameter constraint ---
{}

@PrevReplacer.cpp 49 function: visit   *node: Variable[y]
@PrevReplacer.cpp 52 function: visit   v_name: y
@PrevReplacer.cpp 53 function: visit   diff_cnt: 0
@PrevReplacer.cpp 61 function: visit   range: (0, inf)
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addParameter[p[py, 0, 1]]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$917: {p[py, 0, 1]}

@Backend.cpp 421 function: call   addParameter
timer elapsed: 239[us]
@PrevReplacer.cpp 49 function: visit   *node: Variable[y]
@PrevReplacer.cpp 52 function: visit   v_name: y
@PrevReplacer.cpp 53 function: visit   diff_cnt: 1
@PrevReplacer.cpp 61 function: visit   range: (-inf, inf)
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addParameter[p[py, 1, 1]]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$919: {p[py, 0, 1], p[py, 1, 1]}

@Backend.cpp 421 function: call   addParameter
timer elapsed: 252[us]
@PrevReplacer.cpp 49 function: visit   *node: Variable[y]
@PrevReplacer.cpp 52 function: visit   v_name: y
@PrevReplacer.cpp 53 function: visit   diff_cnt: 1
@PrevReplacer.cpp 61 function: visit   range: p[y, 1, 1]
@PhaseSimulator.cpp 666 function: replace_prev2parameter   phase.get_parameter_constraint(): {0<p[y, 0, 1]}
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
resetConstraintForParameter[0 < p[py, 0, 1]]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$921: Null

@Backend.cpp 421 function: call   resetConstraintForParameter
timer elapsed: 369[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
exprTimeShift[-5*t^2 + p[py, 0, 1] + t*p[py, 1, 1],
	0]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$923: p[py, 0, 1] + t*(t*minus["5"] + p[py, 1, 1])

@Backend.cpp 421 function: call   exprTimeShift
timer elapsed: 1562[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
exprTimeShift[-10*t + p[py, 1, 1],
	0]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$934: t*minus["10"] + p[py, 1, 1]

@Backend.cpp 421 function: call   exprTimeShift
timer elapsed: 681[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
exprTimeShift[-10,
	0]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$941: minus["10"]

@Backend.cpp 421 function: call   exprTimeShift
timer elapsed: 327[us]
@PhaseSimulator.cpp 881 function: find_min_time   get_infix_string(guard): y-=0
@PhaseSimulator.cpp 887 function: find_min_time   phase->discrete_guards.size(): 0
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
substituteVM[uy[t] == 0,
	{uy[t] == -5*t^2 + p[py, 0, 1] + t*p[py, 1, 1]},
	0]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$944: t^"2"*minus["5"] + p[py, 0, 1] + t*p[py, 1, 1] == "0"

@Backend.cpp 421 function: call   substituteVM
timer elapsed: 633[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
calculateConsistentTime[-5*t^2 + p[py, 0, 1] + t*p[py, 1, 1] == 0,
	0,
	p[py, 0, 1] > 0,
	0]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: resultCons$960: -5*t^2 + p[py, 0, 1] + t*p[py, 1, 1] == 0 && 0 < t

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$959: t^"2"*minus["5"] + p[py, 0, 1] + t*p[py, 1, 1] == "0" && "0" < t

@Backend.cpp 421 function: call   calculateConsistentTime
timer elapsed: 774[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
minimizeTime[-5*t^2 + p[py, 0, 1] + t*p[py, 1, 1] == 0 && 0 < t,
	p[py, 0, 1] > 0,
	0,
	Infinity]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"parsInCons", {p[py, 0, 1], p[py, 1, 1]}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: necessaryPCons$979: p[py, 0, 1] > 0

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: restPCons$979: True

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"minT after Minimize:", {Piecewise[{{Infinity, p[py, 0, 1] <= 0}}, (p[py, 1, 1] + Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/10], {t -> Piecewise[{{(p[py, 1, 1] + Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/10, p[py, 0, 1] > 0}}, Indeterminate]}}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$978: {{(p[py, 1, 1] + ("20"*p[py, 0, 1] + p[py, 1, 1]^"2")^(Rational["1", "2"]))*Rational["1", "10"], 1, {p[py, 0, 1] > "0"}, -1}}

@Backend.cpp 421 function: call   minimizeTime
timer elapsed: 6622[us]
@PhaseSimulator.cpp 1717 function: make_next_todo   candidate.time: (p[y, 1, 1]+(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*1/10
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
simplify[(p[py, 1, 1] + Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/10]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1001: (p[py, 1, 1] + ("20"*p[py, 0, 1] + p[py, 1, 1]^"2")^(Rational["1", "2"]))*Rational["1", "10"]

@Backend.cpp 421 function: call   simplify
timer elapsed: 2764[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
applyTime2Expr[-5*t^2 + p[py, 0, 1] + t*p[py, 1, 1],
	(p[py, 1, 1] + Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/10]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1016: "0"

@Backend.cpp 421 function: call   applyTime2Expr
timer elapsed: 822[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
applyTime2Expr[-10*t + p[py, 1, 1],
	(p[py, 1, 1] + Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/10]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1020: minus["1"]*("20"*p[py, 0, 1] + p[py, 1, 1]^"2")^(Rational["1", "2"])

@Backend.cpp 421 function: call   applyTime2Expr
timer elapsed: 1345[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
applyTime2Expr[-10,
	(p[py, 1, 1] + Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/10]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1034: minus["10"]

@Backend.cpp 421 function: call   applyTime2Expr
timer elapsed: 422[us]
@Simulator.cpp 185 function: process_one_todo   
--- Result Phase ---
%% PhaseType: 2
%% id: 2
%% step: 1
%% parent_id:1
%% unadopted modules: {}
%% positive_asks
%% negative_asks
%% current_time: 0
%% end_time: (p[y, 1, 1]+(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*1/10
--- variable map ---
y <=> p[y, 0, 1]+t*(t*(-5)+p[y, 1, 1])
y' <=> t*(-10)+p[y, 1, 1]
y'' <=> -10

--- parameter constraint ---
{p[y, 0, 1]>0}

@HybridAutomatonConverter.cpp 68 function: HA_translate   *current: %% PhaseType: 2
%% id: 2
%% step: 1
%% parent_id:1
%% unadopted modules: {}
%% positive_asks
%% negative_asks
%% current_time: 0
%% end_time: (p[y, 1, 1]+(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*1/10
--- variable map ---
y <=> p[y, 0, 1]+t*(t*(-5)+p[y, 1, 1])
y' <=> t*(-10)+p[y, 1, 1]
y'' <=> -10

--- parameter constraint ---
{p[y, 0, 1]>0}

@Simulator.cpp 165 function: process_one_todo   
--- Current Todo ---
%% PhaseType: 1
%% id: 3
%% step: 2
%% parent_id:2
%% unadopted modules: {}
%% positive_asks
%% negative_asks
%% current_time: (p[y, 1, 1]+(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*1/10
--- variable map ---

--- parameter constraint ---
{p[y, 0, 1]>0}

@Simulator.cpp 166 function: process_one_todo   
--- prev map ---
y <=> 0
y' <=> -1*(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2)
y'' <=> -10

@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
setCurrentTime[(p[py, 1, 1] + Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/10]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1038: Null

@Backend.cpp 421 function: call   setCurrentTime
timer elapsed: 346[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
resetConstraint[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1040: Null

@Backend.cpp 421 function: call   resetConstraint
timer elapsed: 250[us]
@PhaseSimulator.cpp 162 function: make_results_from_todo   *todo: %% PhaseType: 1
%% id: 3
%% step: 2
%% parent_id:2
%% unadopted modules: {}
%% positive_asks
%% negative_asks
%% current_time: (p[y, 1, 1]+(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*1/10
--- variable map ---

--- parameter constraint ---
{p[y, 0, 1]>0}

@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
clearPrevConstraint[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1042: Null

@Backend.cpp 421 function: call   clearPrevConstraint
timer elapsed: 237[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addPrevEqual[prev[py, 0],
	0]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1044: Null

@Backend.cpp 421 function: call   addPrevEqual
timer elapsed: 278[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addPrevEqual[prev[py, 1],
	-Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2]]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1046: Null

@Backend.cpp 421 function: call   addPrevEqual
timer elapsed: 336[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addPrevEqual[prev[py, 2],
	-10]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1048: Null

@Backend.cpp 421 function: call   addPrevEqual
timer elapsed: 272[us]
@PhaseSimulator.cpp 199 function: make_results_from_todo   parameter_cons: {p[y, 0, 1]>0}
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addParameterConstraint[p[py, 0, 1] > 0]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"pConstraint", p[py, 0, 1] > 0}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"pCons", p[py, 0, 1] > 0}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1050: Null

@Backend.cpp 421 function: call   addParameterConstraint
timer elapsed: 390[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addParameterConstraint[True]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"pConstraint", p[py, 0, 1] > 0}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"pCons", True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1052: Null

@Backend.cpp 421 function: call   addParameterConstraint
timer elapsed: 372[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addAssumption[True]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"as in addAssumption:", True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1054: Null

@Backend.cpp 421 function: call   addAssumption
timer elapsed: 260[us]
@PhaseSimulator.cpp 326 function: simulate_ms   
--- next unadopted module set ---

@PhaseSimulator.cpp 701 function: calculate_closure   diff_sum: {y'=-4/5*y'-}
@ConsistencyChecker.cpp 394 function: check_consistency   get_infix_string(ask): y-=0=>y'=-4/5*y'-
@ConsistencyChecker.cpp 398 function: check_consistency   related[1/1]: {y''=-10, y'=-4/5*y'-}
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
resetConstraintForVariable[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1056: Null

@Backend.cpp 421 function: call   resetConstraintForVariable
timer elapsed: 243[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addInitEquation[uy,
	prev[py, 0]]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1058: Null

@Backend.cpp 421 function: call   addInitEquation
timer elapsed: 281[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addInitEquation[Derivative[1][dy],
	prev[py, 1]]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1061: Null

@Backend.cpp 421 function: call   addInitEquation
timer elapsed: 297[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addConstraint[Derivative[2][dy] == -10 && Derivative[1][dy] == (-4*prev[py, 1])/5]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1064: Null

@Backend.cpp 421 function: call   addConstraint
timer elapsed: 1484[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
checkConsistencyPoint[Derivative[2][dy] == -10 && Derivative[1][dy] == (-4*prev[py, 1])/5,
	uy == prev[py, 0] && Derivative[1][dy] == prev[py, 1],
	p[py, 0, 1] > 0,
	True,
	{prev[py, 0] -> 0, prev[py, 1] -> -Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2], prev[py, 2] -> -10},
	{uy, Derivative[1][dy], Derivative[2][dy]},
	{prev[py, 0], prev[py, 1], prev[py, 2]},
	{p[py, 0, 1], p[py, 1, 1]},
	(p[py, 1, 1] + Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/10]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"assum: ", True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: consToSolve$1071: {prev[py, 1] == 0}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: solved$1070: False, resultConstraint: Derivative[2][dy] == -10 && Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2] == 0

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: cpTrue$1070: False

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: cpFalse$1070: p[py, 0, 1] > 0

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1069: {{False}, {p[py, 0, 1] > "0"}}

@Backend.cpp 421 function: call   checkConsistencyPoint
timer elapsed: 4472[us]
@ConsistencyChecker.cpp 141 function: call_backend_check_consistency   get_infix_string(inconsistent): p[y, 0, 1]>0
@ConsistencyChecker.cpp 299 function: check_consistency_foreach   
@PhaseSimulator.cpp 359 function: simulate_ms   INCONSISTENT: {}
@IncrementalModuleSet.cpp 243 function: generate_new_ms   %% inconsistent module set : {BOUNCE, FALL}
@IncrementalModuleSet.cpp 249 function: generate_new_ms   %% maximal consistent module set : 
@IncrementalModuleSet.cpp 39 function: get_removable_module_sets   %% candidate modules : {BOUNCE, FALL}

@IncrementalModuleSet.cpp 40 function: get_removable_module_sets   %% current modules : {}

@IncrementalModuleSet.cpp 86 function: get_removable_module_sets   %% removable modules : {FALL} , 

@IncrementalModuleSet.cpp 285 function: generate_new_ms   %% new ms : {FALL}
@PhaseSimulator.cpp 326 function: simulate_ms   
--- next unadopted module set ---
FALL().

@PhaseSimulator.cpp 701 function: calculate_closure   diff_sum: {FALL().
, y'=-4/5*y'-}
@ConsistencyChecker.cpp 394 function: check_consistency   get_infix_string(ask): y-=0=>y'=-4/5*y'-
@ConsistencyChecker.cpp 398 function: check_consistency   related[1/1]: {y'=-4/5*y'-}
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
resetConstraintForVariable[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1093: Null

@Backend.cpp 421 function: call   resetConstraintForVariable
timer elapsed: 252[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addInitEquation[uy,
	prev[py, 0]]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1095: Null

@Backend.cpp 421 function: call   addInitEquation
timer elapsed: 284[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addConstraint[Derivative[1][dy] == (-4*prev[py, 1])/5]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1098: Null

@Backend.cpp 421 function: call   addConstraint
timer elapsed: 367[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
checkConsistencyPoint[Derivative[1][dy] == (-4*prev[py, 1])/5,
	uy == prev[py, 0],
	p[py, 0, 1] > 0,
	True,
	{prev[py, 0] -> 0, prev[py, 1] -> -Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2], prev[py, 2] -> -10},
	{uy, Derivative[1][dy], Derivative[2][dy]},
	{prev[py, 0], prev[py, 1], prev[py, 2]},
	{p[py, 0, 1], p[py, 1, 1]},
	(p[py, 1, 1] + Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/10]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"assum: ", True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: consToSolve$1103: {Derivative[1][dy] == (-4*prev[py, 1])/5}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: solved$1102: True, resultConstraint: 4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2] == 5*Derivative[1][dy]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: cpFalse$1102: False

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1101: {{p[py, 0, 1] > "0"}, {False}}

@Backend.cpp 421 function: call   checkConsistencyPoint
timer elapsed: 5224[us]
@ConsistencyChecker.cpp 140 function: call_backend_check_consistency   get_infix_string(consistent): p[y, 0, 1]>0
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
createVariableMap[4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2] == 5*Derivative[1][dy] && p[py, 0, 1] > 0,
	{uy, Derivative[1][dy], Derivative[2][dy]},
	True,
	{p[py, 0, 1], p[py, 1, 1]},
	(p[py, 1, 1] + Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/10]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: listToProcess$1114[[i$1114]]: 5*Derivative[1][dy] == 4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2], newVars$1114[[1]]: Derivative[1][dy]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: tmpCons$1114: Derivative[1][dy] == (4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: tmpCons$1113: Derivative[1][dy] == (4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5, succeeded: True

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"tmpCons after adjustExprs in createVariableMap", {{Derivative[1][dy] == (4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5}}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: map$1113: {{{{dy, 1}, 0, ("20"*p[py, 0, 1] + p[py, 1, 1]^"2")^(Rational["1", "2"])*Rational["4", "5"]}}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1112: {{{{dy, 1}, 0, ("20"*p[py, 0, 1] + p[py, 1, 1]^"2")^(Rational["1", "2"])*Rational["4", "5"]}}}

@Backend.cpp 421 function: call   createVariableMap
timer elapsed: 2826[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
getSizeOfConstraint[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1131: 712

@Backend.cpp 421 function: call   getSizeOfConstraint
timer elapsed: 258[us]
@PhaseSimulator.cpp 369 function: simulate_ms   CONSISTENT: {Constraint[ConstraintCall<FALL()>[Always[Equal[Differential[Differential[Variable[y]]],Negative[Number[10]]]]]]}
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
getParameterConstraint[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1133: {p[py, 0, 1] > "0"}

@Backend.cpp 421 function: call   getParameterConstraint
timer elapsed: 337[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
exactlyEqual[(4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5,
	-Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2]]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1138: False

@Backend.cpp 421 function: call   exactlyEqual
timer elapsed: 421[us]
@PhaseSimulator.cpp 1557 function: make_next_todo   *phase: %% PhaseType: 1
%% id: 3
%% step: 2
%% parent_id:2
%% unadopted modules: {FALL}
%% inconsistent modules: {BOUNCE, FALL}
%% inconsistent constraints: {y''=-10, y'=-4/5*y'-}
%% positive_asks
y-=0=>y'=-4/5*y'-
%% negative_asks
%% current_time: (p[y, 1, 1]+(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*1/10
--- variable map ---
y' <=> (20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2)*4/5

--- parameter constraint ---
{p[y, 0, 1]>0}

@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
removeRedundantParameters[(p[py, 1, 1] + Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/10,
	0,
	{uy == 0, Derivative[1][dy] == (4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5},
	p[py, 0, 1] > 0]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: parsInVM$1141: {p[py, 0, 1], p[py, 1, 1]}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: redundantPars$1141: {}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1140: {p[py, 0, 1] > "0"}

@Backend.cpp 421 function: call   removeRedundantParameters
timer elapsed: 794[us]
@Simulator.cpp 185 function: process_one_todo   
--- Result Phase ---
%% PhaseType: 1
%% id: 3
%% step: 2
%% parent_id:2
%% unadopted modules: {FALL}
%% inconsistent modules: {BOUNCE, FALL}
%% inconsistent constraints: {y''=-10, y'=-4/5*y'-}
%% positive_asks
y-=0=>y'=-4/5*y'-
%% negative_asks
%% current_time: (p[y, 1, 1]+(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*1/10
%% end_time: (p[y, 1, 1]+(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*1/10
--- variable map ---
y <=> 0
y' <=> (20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2)*4/5

--- parameter constraint ---
{p[y, 0, 1]>0}

@HybridAutomatonConverter.cpp 68 function: HA_translate   *current: %% PhaseType: 1
%% id: 3
%% step: 2
%% parent_id:2
%% unadopted modules: {FALL}
%% inconsistent modules: {BOUNCE, FALL}
%% inconsistent constraints: {y''=-10, y'=-4/5*y'-}
%% positive_asks
y-=0=>y'=-4/5*y'-
%% negative_asks
%% current_time: (p[y, 1, 1]+(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*1/10
%% end_time: (p[y, 1, 1]+(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*1/10
--- variable map ---
y <=> 0
y' <=> (20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2)*4/5

--- parameter constraint ---
{p[y, 0, 1]>0}

@Simulator.cpp 165 function: process_one_todo   
--- Current Todo ---
%% PhaseType: 2
%% id: 4
%% step: 3
%% parent_id:3
%% unadopted modules: {}
%% positive_asks
%% negative_asks
%% current_time: (p[y, 1, 1]+(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*1/10
--- variable map ---

--- parameter constraint ---
{p[y, 0, 1]>0}

@Simulator.cpp 166 function: process_one_todo   
--- prev map ---

@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
resetConstraint[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1148: Null

@Backend.cpp 421 function: call   resetConstraint
timer elapsed: 256[us]
@PhaseSimulator.cpp 162 function: make_results_from_todo   *todo: %% PhaseType: 2
%% id: 4
%% step: 3
%% parent_id:3
%% unadopted modules: {}
%% positive_asks
%% negative_asks
%% current_time: (p[y, 1, 1]+(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*1/10
--- variable map ---

--- parameter constraint ---
{p[y, 0, 1]>0}

@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
clearPrevConstraint[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1150: Null

@Backend.cpp 421 function: call   clearPrevConstraint
timer elapsed: 248[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addPrevEqual[prev[py, 0],
	0]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1152: Null

@Backend.cpp 421 function: call   addPrevEqual
timer elapsed: 296[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addPrevEqual[prev[py, 1],
	(4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1154: Null

@Backend.cpp 421 function: call   addPrevEqual
timer elapsed: 332[us]
@PhaseSimulator.cpp 199 function: make_results_from_todo   parameter_cons: {p[y, 0, 1]>0}
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addParameterConstraint[p[py, 0, 1] > 0]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"pConstraint", p[py, 0, 1] > 0}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"pCons", p[py, 0, 1] > 0}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1156: Null

@Backend.cpp 421 function: call   addParameterConstraint
timer elapsed: 396[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addParameterConstraint[True]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"pConstraint", p[py, 0, 1] > 0}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"pCons", True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1158: Null

@Backend.cpp 421 function: call   addParameterConstraint
timer elapsed: 394[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addAssumption[True]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"as in addAssumption:", True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1160: Null

@Backend.cpp 421 function: call   addAssumption
timer elapsed: 266[us]
@PhaseSimulator.cpp 326 function: simulate_ms   
--- next unadopted module set ---

@PhaseSimulator.cpp 701 function: calculate_closure   diff_sum: {FALL().
, y'=-4/5*y'-}
@ConsistencyChecker.cpp 179 function: check_entailment   get_infix_string(guard): y-=0
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
resetConstraintForVariable[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1162: Null

@Backend.cpp 421 function: call   resetConstraintForVariable
timer elapsed: 238[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addInitEquation[uy[0],
	prev[py, 0]]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1164: Null

@Backend.cpp 421 function: call   addInitEquation
timer elapsed: 287[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addInitEquation[Derivative[1][uy][0],
	prev[py, 1]]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1167: Null

@Backend.cpp 421 function: call   addInitEquation
timer elapsed: 281[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addConstraint[Derivative[2][uy][t] == -10]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1170: Null

@Backend.cpp 421 function: call   addConstraint
timer elapsed: 331[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
checkConsistencyInterval[uy[t] == 0 && Derivative[2][uy][t] == -10,
	uy[0] == prev[py, 0] && Derivative[1][uy][0] == prev[py, 1],
	True,
	{uy[t], Derivative[1][uy][t], Derivative[2][uy][t]},
	{prev[py, 0] -> 0, prev[py, 1] -> (4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5},
	True,
	p[py, 0, 1] > 0,
	{p[py, 0, 1], p[py, 1, 1]}]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: exDSolve[uy[t] == 0 && Derivative[2][uy][t] == -10,
	{prev[py, 0] -> 0, prev[py, 1] -> (4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5}]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: listExpr$1175: {uy[t] == 0, Derivative[2][uy][t] == -10}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: searchResult$1175: {{Derivative[2][uy][t] == -10}, {uy[t] == 0}, {uy}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: rules$1175: {{uy[t] -> -5*t^2 + prev[py, 0] + t*prev[py, 1]}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: sol$1174: overConstrained

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"sol after exDSolve", overConstrained}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1173: {{False}, {p[py, 0, 1] > "0"}}

@Backend.cpp 421 function: call   checkConsistencyInterval
timer elapsed: 1515[us]
@PhaseSimulator.cpp 783 function: calculate_closure   
--- conflicted ask ---
y-=0=>y'=-4/5*y'-
@PhaseSimulator.cpp 701 function: calculate_closure   diff_sum: {FALL().
, y'=-4/5*y'-}
@ConsistencyChecker.cpp 398 function: check_consistency   related[1/1]: {y''=-10}
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
resetConstraintForVariable[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1188: Null

@Backend.cpp 421 function: call   resetConstraintForVariable
timer elapsed: 246[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addInitEquation[uy[0],
	prev[py, 0]]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1190: Null

@Backend.cpp 421 function: call   addInitEquation
timer elapsed: 273[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addInitEquation[Derivative[1][uy][0],
	prev[py, 1]]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1193: Null

@Backend.cpp 421 function: call   addInitEquation
timer elapsed: 287[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addConstraint[Derivative[2][uy][t] == -10]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1196: Null

@Backend.cpp 421 function: call   addConstraint
timer elapsed: 326[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
checkConsistencyInterval[Derivative[2][uy][t] == -10,
	uy[0] == prev[py, 0] && Derivative[1][uy][0] == prev[py, 1],
	True,
	{uy[t], Derivative[1][uy][t], Derivative[2][uy][t]},
	{prev[py, 0] -> 0, prev[py, 1] -> (4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5},
	True,
	p[py, 0, 1] > 0,
	{p[py, 0, 1], p[py, 1, 1]}]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: exDSolve[Derivative[2][uy][t] == -10,
	{prev[py, 0] -> 0, prev[py, 1] -> (4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5}]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: listExpr$1201: {Derivative[2][uy][t] == -10}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: resultRule$1201: {uy[t] -> -5*t^2 + (4*t*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5}, resultCons$1201: t > 0,                                                                      2
                                  4 Sqrt[20 p[py, 0, 1] + p[py, 1, 1] ]
{prev[py, 0] -> 0, prev[py, 1] -> -------------------------------------}
                                                    5: {prev[py, 0] -> 0, prev[py, 1] -> (4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: sol$1200: {solved, or[and[]], {uy[t] -> -5*t^2 + (4*t*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"sol after exDSolve", {solved, or[and[]], {uy[t] -> -5*t^2 + (4*t*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5}}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {{uy[t] -> -5*t^2 + (4*t*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5, Derivative[1][uy][t] -> -10*t + (4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5, Derivative[2][uy][t] -> -10}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: tRules$1200: {uy[t] -> -5*t^2 + (4*t*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5, Derivative[1][uy][t] -> -10*t + (4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5, Derivative[2][uy][t] -> -10}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"hoge"}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {Derivative[2][uy][t] == -10}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {uy[0] == prev[py, 0] && Derivative[1][uy][0] == prev[py, 1]}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {{prev[py, 0] -> 0, prev[py, 1] -> (4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {uy[0] == 0 && Derivative[1][uy][0] == (4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {{uy[t] -> -5*t^2 + (4*t*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5, Derivative[1][uy][t] -> -10*t + (4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5, Derivative[2][uy][t] -> -10}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {0 == prev[py, 0] && (4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5 == prev[py, 1]}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: tCons$1200: or[and[]]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"cpFalse", cpFalse$1200}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1199: {{p[py, 0, 1] > "0"}, {False}}

@Backend.cpp 421 function: call   checkConsistencyInterval
timer elapsed: 2397[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
createVariableMapInterval[Derivative[2][uy][t] == -10,
	{prev[py, 0] -> 0, prev[py, 1] -> (4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5},
	{uy[t], Derivative[1][uy][t], Derivative[2][uy][t]}]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: exDSolve[Derivative[2][uy][t] == -10,
	{prev[py, 0] -> 0, prev[py, 1] -> (4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5}]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: listExpr$1224: {Derivative[2][uy][t] == -10}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: resultRule$1224: {uy[t] -> -5*t^2 + (4*t*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5}, resultCons$1224: t > 0,                                                                      2
                                  4 Sqrt[20 p[py, 0, 1] + p[py, 1, 1] ]
{prev[py, 0] -> 0, prev[py, 1] -> -------------------------------------}
                                                    5: {prev[py, 0] -> 0, prev[py, 1] -> (4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"sol after exDSolve", {solved, or[and[]], {uy[t] -> -5*t^2 + (4*t*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5}}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1222: {{{{uy, 0}, 0, t^"2"*minus["5"] + t*("20"*p[py, 0, 1] + p[py, 1, 1]^"2")^(Rational["1", "2"])*Rational["4", "5"]}, {{uy, 1}, 0, t*minus["10"] + ("20"*p[py, 0, 1] + p[py, 1, 1]^"2")^(Rational["1", "2"])*Rational["4", "5"]}, {{uy, 2}, 0, minus["10"]}}}

@Backend.cpp 421 function: call   createVariableMapInterval
timer elapsed: 2646[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
getSizeOfConstraint[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1268: 968

@Backend.cpp 421 function: call   getSizeOfConstraint
timer elapsed: 256[us]
@PhaseSimulator.cpp 369 function: simulate_ms   CONSISTENT: {}
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
getParameterConstraint[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1270: {p[py, 0, 1] > "0"}

@Backend.cpp 421 function: call   getParameterConstraint
timer elapsed: 340[us]
@PhaseSimulator.cpp 1557 function: make_next_todo   *phase: %% PhaseType: 2
%% id: 4
%% step: 3
%% parent_id:3
%% unadopted modules: {}
%% positive_asks
%% negative_asks
y-=0=>y'=-4/5*y'-
%% current_time: (p[y, 1, 1]+(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*1/10
--- variable map ---
y <=> t^2*(-5)+t*(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2)*4/5
y' <=> t*(-10)+(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2)*4/5
y'' <=> -10

--- parameter constraint ---
{p[y, 0, 1]>0}

@PhaseSimulator.cpp 666 function: replace_prev2parameter   phase.get_parameter_constraint(): {p[y, 0, 1]>0}
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
resetConstraintForParameter[p[py, 0, 1] > 0]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1275: Null

@Backend.cpp 421 function: call   resetConstraintForParameter
timer elapsed: 379[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
exprTimeShift[-5*t^2 + (4*t*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5,
	(p[py, 1, 1] + Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/10]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1277: (t*minus["10"] + p[py, 1, 1] + ("20"*p[py, 0, 1] + p[py, 1, 1]^"2")^(Rational["1", "2"]))*(t*minus["50"] + "5"*p[py, 1, 1] + "13"*("20"*p[py, 0, 1] + p[py, 1, 1]^"2")^(Rational["1", "2"]))*Rational[minus["1"], "100"]

@Backend.cpp 421 function: call   exprTimeShift
timer elapsed: 6816[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
exprTimeShift[-10*t + (4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5,
	(p[py, 1, 1] + Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/10]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1313: t*minus["10"] + p[py, 1, 1] + ("20"*p[py, 0, 1] + p[py, 1, 1]^"2")^(Rational["1", "2"])*Rational["9", "5"]

@Backend.cpp 421 function: call   exprTimeShift
timer elapsed: 3579[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
exprTimeShift[-10,
	(p[py, 1, 1] + Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/10]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1331: minus["10"]

@Backend.cpp 421 function: call   exprTimeShift
timer elapsed: 438[us]
@PhaseSimulator.cpp 881 function: find_min_time   get_infix_string(guard): y-=0
@PhaseSimulator.cpp 887 function: find_min_time   phase->discrete_guards.size(): 0
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
substituteVM[uy[t] == 0,
	{uy[t] == -5*t^2 + (4*t*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5},
	(p[py, 1, 1] + Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/10]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1334: t^"2"*minus["5"] + t*("20"*p[py, 0, 1] + p[py, 1, 1]^"2")^(Rational["1", "2"])*Rational["4", "5"] == "0"

@Backend.cpp 421 function: call   substituteVM
timer elapsed: 979[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
calculateConsistentTime[-5*t^2 + (4*t*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5 == 0,
	0,
	p[py, 0, 1] > 0,
	(p[py, 1, 1] + Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/10]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: resultCons$1358: -5*t^2 + (4*t*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5 == 0 && 0 < t

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1357: t^"2"*minus["5"] + t*("20"*p[py, 0, 1] + p[py, 1, 1]^"2")^(Rational["1", "2"])*Rational["4", "5"] == "0" && "0" < t

@Backend.cpp 421 function: call   calculateConsistentTime
timer elapsed: 1045[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
minimizeTime[-5*t^2 + (4*t*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5 == 0 && 0 < t,
	p[py, 0, 1] > 0,
	0,
	Infinity]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"parsInCons", {p[py, 0, 1], p[py, 1, 1]}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: necessaryPCons$1385: p[py, 0, 1] > 0

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: restPCons$1385: True

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"minT after Minimize:", {Piecewise[{{Infinity, p[py, 0, 1] <= 0}}, (4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/25], {t -> Piecewise[{{(4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/25, p[py, 0, 1] > 0}}, Indeterminate]}}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1384: {{("20"*p[py, 0, 1] + p[py, 1, 1]^"2")^(Rational["1", "2"])*Rational["4", "25"], 1, {p[py, 0, 1] > "0"}, -1}}

@Backend.cpp 421 function: call   minimizeTime
timer elapsed: 6686[us]
@PhaseSimulator.cpp 1717 function: make_next_todo   candidate.time: (20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2)*4/25
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
simplify[(4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/25 + (p[py, 1, 1] + Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/10]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1404: ("5"*p[py, 1, 1] + "13"*("20"*p[py, 0, 1] + p[py, 1, 1]^"2")^(Rational["1", "2"]))*Rational["1", "50"]

@Backend.cpp 421 function: call   simplify
timer elapsed: 2276[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
applyTime2Expr[-5*t^2 + (4*t*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5,
	(4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/25]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1423: "0"

@Backend.cpp 421 function: call   applyTime2Expr
timer elapsed: 534[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
applyTime2Expr[-10*t + (4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5,
	(4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/25]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1427: ("20"*p[py, 0, 1] + p[py, 1, 1]^"2")^(Rational["1", "2"])*Rational[minus["4"], "5"]

@Backend.cpp 421 function: call   applyTime2Expr
timer elapsed: 984[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
applyTime2Expr[-10,
	(4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/25]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1441: minus["10"]

@Backend.cpp 421 function: call   applyTime2Expr
timer elapsed: 409[us]
@Simulator.cpp 185 function: process_one_todo   
--- Result Phase ---
%% PhaseType: 2
%% id: 4
%% step: 3
%% parent_id:3
%% unadopted modules: {}
%% positive_asks
%% negative_asks
y-=0=>y'=-4/5*y'-
%% current_time: (p[y, 1, 1]+(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*1/10
%% end_time: (5*p[y, 1, 1]+13*(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*1/50
--- variable map ---
y <=> (t*(-10)+p[y, 1, 1]+(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*(t*(-50)+5*p[y, 1, 1]+13*(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*(-1)/100
y' <=> t*(-10)+p[y, 1, 1]+(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2)*9/5
y'' <=> -10

--- parameter constraint ---
{p[y, 0, 1]>0}

@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
checkInclude[0,
	{uy[t] == p[py, 0, 1] + t*(-5*t + p[py, 1, 1]), Derivative[1][uy][t] == -10*t + p[py, 1, 1], Derivative[2][uy][t] == -10},
	p[py, 0, 1] > 0,
	(p[py, 1, 1] + Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/10,
	{uy[t] == -((-10*t + p[py, 1, 1] + Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])*(-50*t + 5*p[py, 1, 1] + 13*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2]))/100, Derivative[1][uy][t] == -10*t + p[py, 1, 1] + (9*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5, Derivative[2][uy][t] == -10},
	p[py, 0, 1] > 0]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: listSmall$1446: {p[py, 0, 1], p[py, 1, 1]}, tmpSmallPm: p[py, 0, 1] > 0, listLarge$1446: {pL[py, 0, 1], pL[py, 1, 1]}, tmpLargePm: pL[py, 0, 1] > 0, allExpr$1446: pL[py, 0, 1] == 0 && 4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2] == 5*pL[py, 1, 1]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: ret$1446: False

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1445: False

@Backend.cpp 421 function: call   checkInclude
timer elapsed: 6712[us]
@HybridAutomatonConverter.cpp 68 function: HA_translate   *current: %% PhaseType: 2
%% id: 4
%% step: 3
%% parent_id:3
%% unadopted modules: {}
%% positive_asks
%% negative_asks
y-=0=>y'=-4/5*y'-
%% current_time: (p[y, 1, 1]+(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*1/10
%% end_time: (5*p[y, 1, 1]+13*(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*1/50
--- variable map ---
y <=> (t*(-10)+p[y, 1, 1]+(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*(t*(-50)+5*p[y, 1, 1]+13*(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*(-1)/100
y' <=> t*(-10)+p[y, 1, 1]+(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2)*9/5
y'' <=> -10

--- parameter constraint ---
{p[y, 0, 1]>0}

@Simulator.cpp 165 function: process_one_todo   
--- Current Todo ---
%% PhaseType: 1
%% id: 5
%% step: 4
%% parent_id:4
%% unadopted modules: {}
%% positive_asks
%% negative_asks
%% current_time: (5*p[y, 1, 1]+13*(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*1/50
--- variable map ---

--- parameter constraint ---
{p[y, 0, 1]>0}

@Simulator.cpp 166 function: process_one_todo   
--- prev map ---
y <=> 0
y' <=> (20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2)*(-4)/5
y'' <=> -10

@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
setCurrentTime[(5*p[py, 1, 1] + 13*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/50]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1452: Null

@Backend.cpp 421 function: call   setCurrentTime
timer elapsed: 388[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
resetConstraint[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1454: Null

@Backend.cpp 421 function: call   resetConstraint
timer elapsed: 256[us]
@PhaseSimulator.cpp 162 function: make_results_from_todo   *todo: %% PhaseType: 1
%% id: 5
%% step: 4
%% parent_id:4
%% unadopted modules: {}
%% positive_asks
%% negative_asks
%% current_time: (5*p[y, 1, 1]+13*(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*1/50
--- variable map ---

--- parameter constraint ---
{p[y, 0, 1]>0}

@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
clearPrevConstraint[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1456: Null

@Backend.cpp 421 function: call   clearPrevConstraint
timer elapsed: 266[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addPrevEqual[prev[py, 0],
	0]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1458: Null

@Backend.cpp 421 function: call   addPrevEqual
timer elapsed: 280[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addPrevEqual[prev[py, 1],
	(-4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1460: Null

@Backend.cpp 421 function: call   addPrevEqual
timer elapsed: 344[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addPrevEqual[prev[py, 2],
	-10]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1462: Null

@Backend.cpp 421 function: call   addPrevEqual
timer elapsed: 288[us]
@PhaseSimulator.cpp 199 function: make_results_from_todo   parameter_cons: {p[y, 0, 1]>0}
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addParameterConstraint[p[py, 0, 1] > 0]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"pConstraint", p[py, 0, 1] > 0}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"pCons", p[py, 0, 1] > 0}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1464: Null

@Backend.cpp 421 function: call   addParameterConstraint
timer elapsed: 394[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addParameterConstraint[True]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"pConstraint", p[py, 0, 1] > 0}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"pCons", True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1466: Null

@Backend.cpp 421 function: call   addParameterConstraint
timer elapsed: 366[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addAssumption[True]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"as in addAssumption:", True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1468: Null

@Backend.cpp 421 function: call   addAssumption
timer elapsed: 268[us]
@PhaseSimulator.cpp 326 function: simulate_ms   
--- next unadopted module set ---

@PhaseSimulator.cpp 701 function: calculate_closure   diff_sum: {y'=-4/5*y'-}
@ConsistencyChecker.cpp 394 function: check_consistency   get_infix_string(ask): y-=0=>y'=-4/5*y'-
@ConsistencyChecker.cpp 398 function: check_consistency   related[1/1]: {y''=-10, y'=-4/5*y'-}
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
resetConstraintForVariable[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1470: Null

@Backend.cpp 421 function: call   resetConstraintForVariable
timer elapsed: 244[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addInitEquation[uy,
	prev[py, 0]]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1472: Null

@Backend.cpp 421 function: call   addInitEquation
timer elapsed: 273[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addInitEquation[Derivative[1][dy],
	prev[py, 1]]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1475: Null

@Backend.cpp 421 function: call   addInitEquation
timer elapsed: 307[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addConstraint[Derivative[2][dy] == -10 && Derivative[1][dy] == (-4*prev[py, 1])/5]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1478: Null

@Backend.cpp 421 function: call   addConstraint
timer elapsed: 380[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
checkConsistencyPoint[Derivative[2][dy] == -10 && Derivative[1][dy] == (-4*prev[py, 1])/5,
	uy == prev[py, 0] && Derivative[1][dy] == prev[py, 1],
	p[py, 0, 1] > 0,
	True,
	{prev[py, 0] -> 0, prev[py, 1] -> (-4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5, prev[py, 2] -> -10},
	{uy, Derivative[1][dy], Derivative[2][dy]},
	{prev[py, 0], prev[py, 1], prev[py, 2]},
	{p[py, 0, 1], p[py, 1, 1]},
	(5*p[py, 1, 1] + 13*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/50]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"assum: ", True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: consToSolve$1483: {prev[py, 1] == 0}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: solved$1482: False, resultConstraint: Derivative[2][dy] == -10 && Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2] == 0

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: cpTrue$1482: False

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: cpFalse$1482: p[py, 0, 1] > 0

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1481: {{False}, {p[py, 0, 1] > "0"}}

@Backend.cpp 421 function: call   checkConsistencyPoint
timer elapsed: 4163[us]
@ConsistencyChecker.cpp 141 function: call_backend_check_consistency   get_infix_string(inconsistent): p[y, 0, 1]>0
@ConsistencyChecker.cpp 299 function: check_consistency_foreach   
@PhaseSimulator.cpp 359 function: simulate_ms   INCONSISTENT: {}
@IncrementalModuleSet.cpp 243 function: generate_new_ms   %% inconsistent module set : {BOUNCE, FALL}
@IncrementalModuleSet.cpp 249 function: generate_new_ms   %% maximal consistent module set : 
@IncrementalModuleSet.cpp 39 function: get_removable_module_sets   %% candidate modules : {BOUNCE, FALL}

@IncrementalModuleSet.cpp 40 function: get_removable_module_sets   %% current modules : {}

@IncrementalModuleSet.cpp 86 function: get_removable_module_sets   %% removable modules : {FALL} , 

@IncrementalModuleSet.cpp 285 function: generate_new_ms   %% new ms : {FALL}
@PhaseSimulator.cpp 326 function: simulate_ms   
--- next unadopted module set ---
FALL().

@PhaseSimulator.cpp 701 function: calculate_closure   diff_sum: {FALL().
, y'=-4/5*y'-}
@ConsistencyChecker.cpp 394 function: check_consistency   get_infix_string(ask): y-=0=>y'=-4/5*y'-
@ConsistencyChecker.cpp 398 function: check_consistency   related[1/1]: {y'=-4/5*y'-}
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
resetConstraintForVariable[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1505: Null

@Backend.cpp 421 function: call   resetConstraintForVariable
timer elapsed: 296[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addInitEquation[uy,
	prev[py, 0]]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1507: Null

@Backend.cpp 421 function: call   addInitEquation
timer elapsed: 307[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
addConstraint[Derivative[1][dy] == (-4*prev[py, 1])/5]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1510: Null

@Backend.cpp 421 function: call   addConstraint
timer elapsed: 372[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
checkConsistencyPoint[Derivative[1][dy] == (-4*prev[py, 1])/5,
	uy == prev[py, 0],
	p[py, 0, 1] > 0,
	True,
	{prev[py, 0] -> 0, prev[py, 1] -> (-4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5, prev[py, 2] -> -10},
	{uy, Derivative[1][dy], Derivative[2][dy]},
	{prev[py, 0], prev[py, 1], prev[py, 2]},
	{p[py, 0, 1], p[py, 1, 1]},
	(5*p[py, 1, 1] + 13*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/50]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"assum: ", True}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: consToSolve$1515: {Derivative[1][dy] == (-4*prev[py, 1])/5}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: solved$1514: True, resultConstraint: 16*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2] == 25*Derivative[1][dy]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: cpFalse$1514: False

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1513: {{p[py, 0, 1] > "0"}, {False}}

@Backend.cpp 421 function: call   checkConsistencyPoint
timer elapsed: 4642[us]
@ConsistencyChecker.cpp 140 function: call_backend_check_consistency   get_infix_string(consistent): p[y, 0, 1]>0
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
createVariableMap[16*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2] == 25*Derivative[1][dy] && p[py, 0, 1] > 0,
	{uy, Derivative[1][dy], Derivative[2][dy]},
	True,
	{p[py, 0, 1], p[py, 1, 1]},
	(5*p[py, 1, 1] + 13*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/50]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: listToProcess$1526[[i$1526]]: 25*Derivative[1][dy] == 16*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2], newVars$1526[[1]]: Derivative[1][dy]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: tmpCons$1526: Derivative[1][dy] == (16*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/25

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: tmpCons$1525: Derivative[1][dy] == (16*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/25, succeeded: True

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: {"tmpCons after adjustExprs in createVariableMap", {{Derivative[1][dy] == (16*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/25}}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: map$1525: {{{{dy, 1}, 0, ("20"*p[py, 0, 1] + p[py, 1, 1]^"2")^(Rational["1", "2"])*Rational["16", "25"]}}}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1524: {{{{dy, 1}, 0, ("20"*p[py, 0, 1] + p[py, 1, 1]^"2")^(Rational["1", "2"])*Rational["16", "25"]}}}

@Backend.cpp 421 function: call   createVariableMap
timer elapsed: 2049[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
getSizeOfConstraint[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1542: 712

@Backend.cpp 421 function: call   getSizeOfConstraint
timer elapsed: 254[us]
@PhaseSimulator.cpp 369 function: simulate_ms   CONSISTENT: {Constraint[ConstraintCall<FALL()>[Always[Equal[Differential[Differential[Variable[y]]],Negative[Number[10]]]]]]}
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
getParameterConstraint[]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1544: {p[py, 0, 1] > "0"}

@Backend.cpp 421 function: call   getParameterConstraint
timer elapsed: 339[us]
@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
exactlyEqual[(16*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/25,
	(-4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1549: False

@Backend.cpp 421 function: call   exactlyEqual
timer elapsed: 448[us]
@PhaseSimulator.cpp 1557 function: make_next_todo   *phase: %% PhaseType: 1
%% id: 5
%% step: 4
%% parent_id:4
%% unadopted modules: {FALL}
%% inconsistent modules: {BOUNCE, FALL}
%% inconsistent constraints: {y''=-10, y'=-4/5*y'-}
%% positive_asks
y-=0=>y'=-4/5*y'-
%% negative_asks
%% current_time: (5*p[y, 1, 1]+13*(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*1/50
--- variable map ---
y' <=> (20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2)*16/25

--- parameter constraint ---
{p[y, 0, 1]>0}

@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
removeRedundantParameters[(5*p[py, 1, 1] + 13*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/50,
	0,
	{uy == 0, Derivative[1][dy] == (16*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/25},
	p[py, 0, 1] > 0]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: parsInVM$1552: {p[py, 0, 1], p[py, 1, 1]}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: redundantPars$1552: {}

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1551: {p[py, 0, 1] > "0"}

@Backend.cpp 421 function: call   removeRedundantParameters
timer elapsed: 799[us]
@Simulator.cpp 185 function: process_one_todo   
--- Result Phase ---
%% PhaseType: 1
%% id: 5
%% step: 4
%% parent_id:4
%% unadopted modules: {FALL}
%% inconsistent modules: {BOUNCE, FALL}
%% inconsistent constraints: {y''=-10, y'=-4/5*y'-}
%% positive_asks
y-=0=>y'=-4/5*y'-
%% negative_asks
%% current_time: (5*p[y, 1, 1]+13*(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*1/50
%% end_time: (5*p[y, 1, 1]+13*(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*1/50
--- variable map ---
y <=> 0
y' <=> (20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2)*16/25

--- parameter constraint ---
{p[y, 0, 1]>0}

@mathematica/MathematicaLink.cpp 135 function: receive_to_return_packet   input: 
checkInclude[(p[py, 1, 1] + Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/10,
	{uy[t] == 0, Derivative[1][uy][t] == (4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/5},
	p[py, 0, 1] > 0,
	(5*p[py, 1, 1] + 13*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/50,
	{uy[t] == 0, Derivative[1][uy][t] == (16*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2])/25},
	p[py, 0, 1] > 0]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: listSmall$1560: {p[py, 0, 1], p[py, 1, 1]}, tmpSmallPm: p[py, 0, 1] > 0, listLarge$1560: {pL[py, 0, 1], pL[py, 1, 1]}, tmpLargePm: pL[py, 0, 1] > 0, allExpr$1560: 4*Sqrt[20*p[py, 0, 1] + p[py, 1, 1]^2] == 5*Sqrt[20*pL[py, 0, 1] + pL[py, 1, 1]^2]

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: ret$1560: True

@mathematica/MathematicaLink.cpp 137 function: receive_to_return_packet   trace: publicRet$1559: True

@Backend.cpp 421 function: call   checkInclude
timer elapsed: 11506[us]
@HybridAutomatonConverter.cpp 93 function: HA_translate   A loop is detected
@HybridAutomatonConverter.cpp 94 function: HA_translate   *todo: %% PhaseType: 1
%% id: 5
%% step: 4
%% parent_id:4
%% unadopted modules: {FALL}
%% inconsistent modules: {BOUNCE, FALL}
%% inconsistent constraints: {y''=-10, y'=-4/5*y'-}
%% positive_asks
y-=0=>y'=-4/5*y'-
%% negative_asks
%% current_time: (5*p[y, 1, 1]+13*(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*1/50
%% end_time: (5*p[y, 1, 1]+13*(20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2))*1/50
--- variable map ---
y <=> 0
y' <=> (20*p[y, 0, 1]+p[y, 1, 1]^2)^(1/2)*16/25

--- parameter constraint ---
{p[y, 0, 1]>0}

===== Automaton1 =====
digraph g{
"init" [color="#000000"];
"init" -> "Phase 1"[color="#000000"];
"Phase 1" [color="#000000"];
"Phase 1" -> "Phase 2"[color="#000000"];
"Phase 2" [color="#000000"];
"Phase 2" -> "Phase 3"[color="#000000"];
"Phase 3" [color="#000000"];
"Phase 3" -> "Phase 4"[color="#000000"];
"Phase 4" [color="#000000"];
"Phase 4" -> "Phase 3"[color="#000000"];
}
@HybridAutomatonConverter.cpp 55 function: simulate   %% simulation ended
Simulation Time : 1.003595 s
Finish Time : 1.005102 s

